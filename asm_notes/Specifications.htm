<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0045)http://doc.kodewerx.org/documents/gbatek.html -->
<HTML><HEAD><META content="IE=5.0000" http-equiv="X-UA-Compatible">
<TITLE>Specifications</TITLE>     
<META http-equiv="Content-Type" content="text/html; charset=windows-1252">
<META name="GENERATOR" content="MSHTML 11.00.10586.713"></HEAD>
<BODY text="#000000" bgcolor="#ffffff" link="#0033cc" alink="#0033cc" vlink="#0033cc" 
linkifying="false" linkified="7" linkifytime="2937"> 
<CENTER><A name="gbatek"></A><FONT size="+3">GBATEK</FONT><BR>Gameboy Advance 
Technical Info - Extracted from no$gba version 2.2b
<P></P></CENTER>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="30%" valign="top">
      <TABLE width="100%">
        <TBODY>
        <TR bgcolor="#cccccc">
          <TD><A name="gbareference"></A><FONT size="+2">&nbsp;GBA 
            Reference</FONT></TD></TR></TBODY></TABLE><BR><B>Overview</B><BR><A href="#technicaldata">Technical 
      Data</A><BR><A href="#memorymap">Memory 
      Map</A><BR><A 
      href="#iomap">I/O 
      Map</A><BR><BR><B>Hardware Programming</B><BR><A href="#lcdvideocontroller">LCD 
      Video Controller</A><BR><A href="#soundcontroller">Sound 
      Controller</A><BR><A href="#timers">Timers</A><BR><A 
      href="#dmatransfers">DMA 
      Transfers</A><BR><A href="#communicationports">Communication 
      Ports</A><BR><A href="#keypadinput">Keypad 
      Input</A><BR><A href="#interruptcontrol">Interrupt 
      Control</A><BR><A href="#systemcontrol">System 
      Control</A><BR><BR><B>Other</B><BR><A href="#cartridges">Cartridges</A><BR><A 
      href="#biosfunctions">BIOS 
      Functions</A><BR><A href="#unpredictablethings">Unpredictable 
      Things</A><BR><A href="#externalconnectors">External 
      Connectors</A><BR></TD>
    <TD width="40%">
      <TABLE width="100%">
        <TBODY>
        <TR bgcolor="#cccccc">
          <TD><A name="ndsreference"></A><FONT size="+2">&nbsp;NDS 
            Reference</FONT></TD></TR></TBODY></TABLE><BR><A href="#dsiomaps">DS 
      I/O Maps</A><BR><A href="#dsmemorymaps">DS 
      Memory Maps</A><BR><A href="#dsmemorycontrol">DS 
      Memory Control</A><BR><A href="#dsvideo">DS 
      Video</A><BR><A href="#dssound">DS 
      Sound</A><BR><A href="#dsvarious">DS 
      Various</A><BR><A href="#dsdmatransfers">DS 
      DMA Transfers</A><BR><A href="#dstimers">DS 
      Timers</A><BR><A href="#dsinterrupts">DS 
      Interrupts</A><BR><A href="#dsmaths">DS 
      Maths</A><BR><A href="#dskeypad">DS 
      Keypad</A><BR><A href="#dsinterprocesscommunicationipc">DS 
      Inter Process Communication</A><BR><A href="#dsrealtimeclockrtc">DS 
      Real-Time Clock (RTC)</A><BR><A href="#dsserialperipheralinterfacebusspi">DS 
      Serial Peripheral Interface Bus</A><BR><A href="#dstouchscreencontrollertsc">DS 
      Touch Screen Controller (TSC)</A><BR><A href="#dspowermanagement">DS 
      Power Management</A><BR><A href="#dscartridgesencryptionfirmware">DS 
      Cartridges, Encryption, Firmware</A><BR><A href="#dsxboo">DS 
      Xboo</A><BR><A href="#dsbackwardscompatiblegbamode">DS 
      Backwards-compatible GBA-Mode</A><BR></TD>
    <TD width="30%">
      <TABLE width="100%">
        <TBODY>
        <TR bgcolor="#cccccc">
          <TD><A name="cpureference"></A><FONT size="+2">&nbsp;CPU 
            Reference</FONT></TD></TR></TBODY></TABLE><BR><B>General 
      Information</B><BR><A href="#cpuoverview">CPU 
      Overview</A><BR><A href="#cpuregisterset">CPU 
      Register Set</A><BR><A href="#cpuflags">CPU 
      Flags</A><BR><A href="#cpuexceptions">CPU 
      Exceptions</A><BR><BR><B>The Instruction Sets</B><BR><A href="#thumbinstructionset">THUMB 
      Instruction Set</A><BR><A href="#arminstructionset">ARM 
      Instruction Set</A><BR><A href="#pseudoinstructionsanddirectives">Pseudo 
      Opcodes &amp; Directives</A><BR><BR><B>Further Information</B><BR><A href="#armcp15systemcontrolcoprocessor">ARM 
      System Control CP15</A><BR><A href="#cpuinstructioncycletimes">CPU 
      Clock Cycles</A><BR><A href="#cpuversions">CPU 
      Versions</A><BR><A href="#cpudatasheet">CPU 
      Data Sheet</A><BR><BR><B>About GBATEK</B><BR><A href="#aboutthisdocument">About 
      this Document</A><BR></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="technicaldata"></A><FONT size="+2">&nbsp;Technical 
    Data</FONT></TD></TR></TBODY></TABLE><BR><B>CPU Modes</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  ARM Mode     ARM7TDMI 32bit RISC CPU, 16.78MHz, 32bit opcodes (GBA)
  THUMB Mode   ARM7TDMI 32bit RISC CPU, 16.78MHz, 16bit opcodes (GBA)
  CGB Mode     Z80/8080-style 8bit CPU, 4.2MHz or 8.4MHz  (CGB compatibility)
  DMG Mode     Z80/8080-style 8bit CPU, 4.2MHz (monochrome gameboy compatib.)
</PRE></TD></TR></TBODY></TABLE><B>Internal 
Memory</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  BIOS ROM     16 KBytes
  Work RAM     288 KBytes (32K in-chip + 256K on-board)
  VRAM         96 KBytes
  OAM          1 KByte (128 OBJs 3x16bit, 32 OBJ-Rotation/Scalings 4x16bit)
  Palette RAM  1 KByte (256 BG colors, 256 OBJ colors)
</PRE></TD></TR></TBODY></TABLE><B>Video</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Display      240x160 pixels (2.9 inch TFT color LCD display)
  BG layers    4 background layers
  BG types     Tile/map based, or Bitmap based
  BG colors    256 colors, or 16 colors/16 palettes, or 32768 colors
  OBJ colors   256 colors, or 16 colors/16 palettes
  OBJ size     12 types (in range 8x8 up to 64x64 dots)
  OBJs/Screen  max. 128 OBJs of any size (up to 64x64 dots each)
  OBJs/Line    max. 128 OBJs of 8x8 dots size (under best circumstances)
  Priorities   OBJ/OBJ: 0-127, OBJ/BG: 0-3, BG/BG: 0-3
  Effects      Rotation/Scaling, alpha blending, fade-in/out, mosaic, window
  Backlight    GBA SP only (optionally by light on/off toggle button)
</PRE></TD></TR></TBODY></TABLE><B>Sound</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Analogue     4 channel CGB compatible (3x square wave, 1x noise)
  Digital      2 DMA sound channels
  Output       Built-in speaker (mono), or headphones socket (stereo)
</PRE></TD></TR></TBODY></TABLE><B>Controls</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Gamepad      4 Direction Keys, 6 Buttons
</PRE></TD></TR></TBODY></TABLE><B>Communication 
Ports</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Serial Port  Various transfer modes, 4-Player Link, Single Game Pak play
</PRE></TD></TR></TBODY></TABLE><B>External 
Memory</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  GBA Game Pak max. 32MB ROM or flash ROM + max 64K SRAM
  CGB Game Pak max. 32KB ROM + 8KB SRAM (more memory requires banking)
</PRE></TD></TR></TBODY></TABLE><B>Case 
Dimensions</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Size (mm)    GBA: 145x81x25 - GBA SP: 82x82x24 (closed), 155x82x24 (stretch)
</PRE></TD></TR></TBODY></TABLE><B>Power 
Supply</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Battery GBA  GBA: 2x1.5V DC (AA), Life-time approx. 15 hours
  Battery SP   GBA SP: Built-in rechargeable Lithium ion battery, 3.7V 600mAh
  External     GBA: 3.3V DC 350mA - GBA SP: 5.2V DC 320mA
</PRE></TD></TR></TBODY></TABLE><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> ----------------------------------------------------------------------------
        ____._____________...___.____               _______________________
   ____/    :  CARTRIDGE  SIO   :    \____         | _____________________ |
  | L       _____________________  LED  R |        ||                     ||
  |        |                     |        |        ||   2.9" TFT SCREEN   ||
  |   ||   |   2.9" TFT SCREEN   |    (A) |        || 240x160pix  61x40mm ||
  | |====| | 240x160pix  61x40mm | (B)    |        ||   WITH BACKLIGHT    ||
  |   ||   |    NO BACKLIGHT     |  ::::  |        ||                     ||
  |        |                     | SPEAKR |        ||_____________________||
  | STRT() |_____________________|  ::::  |        |  GAME BOY ADVANCE SP  |
  | SLCT()     GAME BOY ADVANCE    VOLUME |        |_______________________|
  |____  OFF-ON  BATTERY 2xAA PHONES  _==_|        |_|________|________|_|_|
       \__.##.__________________,,___/             |L    EXT1     EXT2    R|
                                   .::'            |          (*)      LEDSo
                                .::'     (OPENED)  (VOL_||_           (A)  o
   GBA SP SIDE VIEW          .::'                  |  |_  _| ,,,,,(B)      |
   (CLOSED)               .::'        (STRETCHED)  |    ||   ;SPK;         |
  ...................... _ ......................  |         '''''      ON #
  :_____________________(_).....................:  |       SLCT STRT    OFF#
  |. . . . . . . .'.'.   _|                        | CART.  ()   ()        |
  |_CARTRIDGE_:_BATT._:_|_| &lt;-- EXT1/EXT2          |_:___________________:_|
</PRE></TD></TR></TBODY></TABLE><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> ----------------------------------------------------------------------------
     _____________________________________
    |        _____________________        |
    |       |                     |       |
    |       |   2.9" TFT SCREEN   |       |
    |       | 240x160pix  61x40mm |       |
    |       |      BACKLIGHT      |       |
    | ::::: |       3D GFX        | ::::: |
    | ::::: |_____________________| ::::: |
   _|        _          ______   _        |_
  |L|_______| |________|      |_| |_______|R|
  |_______   _____________________   _______|
  |  PWR  | |                     | |SEL STA|
  |   _   | |   2.9" TFT SCREEN   | |       |
  | _| |_ | | 240x160pix  61x40mm | |   X   |
  ||_   _|| |      BACKLIGHT      | | Y   A |
  |  |_|  | |    TOUCH SCREEN     | |   B   |
  |       | |_____________________| |       |
  |_______|             NintendoDS  |_______|
  |         MIC                LEDS         |
  |_________________________________________|
       VOL        SLOT2(GBA)     MIC/PHONES
</PRE></TD></TR></TBODY></TABLE><BR>The separate CPU modes cannot be 
operated simultaneously. Switching is allowed between ARM and THUMB modes only 
(that are the two GBA modes).<BR>This manual does not describe CGB and DMG 
modes, both are completely different than GBA modes, and both cannot be accessed 
from inside of GBA modes anyways.<BR><BR><B>GBA SP Notes</B><BR>Deluxe version 
of the original GBA. With backlight, new folded laptop-style case, and built-in 
rechargeable battery. Appears to be 100% compatible with GBA, there seems to be 
no way to detect SPs by software.<BR><BR><B>Nintendo DS (Dual Screen) 
Notes</B><BR>New handheld with two screens, backwards compatible with GBA games, 
it is NOT backwards compatible with older 8bit games (mono/color gameboys) 
though..<BR>Also, the DS has no link port, so that GBA games will thus work only 
in single player mode, link-port accessoires like printers cannot be used, and
 most unfortunately multiboot won't work (trying to press Select+Start at
 powerup will just lock up the DS).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="memorymap"></A><FONT size="+2">&nbsp;Memory 
  Map</FONT></TD></TR></TBODY></TABLE><BR><B>General Internal Memory</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  00000000-00003FFF   BIOS - System ROM         (16 KBytes)
  00004000-01FFFFFF   Not used
  02000000-0203FFFF   WRAM - On-board Work RAM  (256 KBytes) 2 Wait
  02040000-02FFFFFF   Not used
  03000000-03007FFF   WRAM - In-chip Work RAM   (32 KBytes)
  03008000-03FFFFFF   Not used
  04000000-040003FE   I/O Registers
  04000400-04FFFFFF   Not used
</PRE></TD></TR></TBODY></TABLE><B>Internal 
Display Memory</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  05000000-050003FF   BG/OBJ Palette RAM        (1 Kbyte)
  05000400-05FFFFFF   Not used
  06000000-06017FFF   VRAM - Video RAM          (96 KBytes)
  06018000-06FFFFFF   Not used
  07000000-070003FF   OAM - OBJ Attributes      (1 Kbyte)
  07000400-07FFFFFF   Not used
</PRE></TD></TR></TBODY></TABLE><B>External 
Memory (Game Pak)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  08000000-09FFFFFF   Game Pak ROM/FlashROM (max 32MB) - Wait State 0
  0A000000-0BFFFFFF   Game Pak ROM/FlashROM (max 32MB) - Wait State 1
  0C000000-0DFFFFFF   Game Pak ROM/FlashROM (max 32MB) - Wait State 2
  0E000000-0E00FFFF   Game Pak SRAM    (max 64 KBytes) - 8bit Bus width
  0E010000-0FFFFFFF   Not used
</PRE></TD></TR></TBODY></TABLE><B>Unused 
Memory Area</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  10000000-FFFFFFFF   Not used (upper 4bits of address bus unused)
</PRE></TD></TR></TBODY></TABLE><BR><B>Default 
WRAM Usage</B><BR>By default, the 256 bytes at 03007F00h-03007FFFh in Work RAM 
are reserved for Interrupt vector, Interrupt Stack, and BIOS Call Stack. The
 remaining WRAM is free for whatever use (including User Stack, which is
 initially located at 03007F00h).<BR><BR><B>Address Bus Width and CPU Read/Write 
Access Widths</B><BR>Shows the Bus-Width, supported read and write widths, and 
the clock cycles for 8/16/32bit accesses.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Region        Bus   Read      Write     Cycles
  BIOS ROM      32    8/16/32   -         1/1/1
  Work RAM 32K  32    8/16/32   8/16/32   1/1/1
  I/O           32    8/16/32   8/16/32   1/1/1
  OAM           32    8/16/32   16/32     1/1/1 *
  Work RAM 256K 16    8/16/32   8/16/32   3/3/6 **
  Palette RAM   16    8/16/32   16/32     1/1/2 *
  VRAM          16    8/16/32   16/32     1/1/2 *
  GamePak ROM   16    8/16/32   -         5/5/8 **/***
  GamePak Flash 16    8/16/32   16/32     5/5/8 **/***
  GamePak SRAM  8     8         8         5     **
</PRE></TD></TR></TBODY></TABLE>Timing 
Notes:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  *   Plus 1 cycle if GBA accesses video memory at the same time.
  **  Default waitstate settings, see System Control chapter.
  *** Separate timings for sequential, and non-sequential accesses.
  One cycle equals approx. 59.59ns (ie. 16.78MHz clock).
</PRE></TD></TR></TBODY></TABLE>All 
memory (except GamePak SRAM) can be accessed by 16bit and 32bit 
DMA.<BR><BR><B>GamePak Memory</B><BR>Only DMA3 (and the CPU of course) may 
access GamePak ROM. GamePak SRAM can be accessed by the CPU only - restricted to 
bytewise 8bit transfers. SRAM is supposed as external WRAM expansion - not for 
battery-buffered data storage - for that purpose it'd be more recommended to use 
a Flash ROM chip somewhere located in the ROM area.<BR>For details about 
configuration of GamePak Waitstates, read respective chapter.<BR>SRAM should be 
accessed only through library ???<BR><BR><B>VRAM, OAM, and Palette RAM 
Access</B><BR>These memory regions can be accessed during H-Blank or V-Blank 
only (unless display is disabled by Forced Blank bit in DISPCNT register).<BR>
There is an additional restriction for OAM memory: Accesses during H-Blank are 
allowed only if 'H-Blank Interval Free' in DISPCNT is set (which'd reduce number 
of display-able OBJs though).<BR>The CPU appears to be able to access 
VRAM/OAM/Palette at any time, a waitstate (one clock cycle) being inserted 
automatically in case that the display controller was accessing memory 
simultaneously. (Ie. unlike as in old 8bit gameboy, the data will not get 
lost.)<BR><BR><B>CPU Mode Performance</B><BR>Note that the GamePak ROM bus is 
limited to 16bits, thus executing ARM instructions (32bit opcodes) from inside 
of GamePak ROM would result in a not so good performance. So, it'd be more 
recommended to use THUMB instruction (16bit opcodes) which'd allow each opcode 
to be read at once.<BR>(ARM instructions can be used at best performance by 
copying code from GamePak ROM into internal Work RAM)<BR><BR><B>Data 
Format</B><BR>Even though the ARM CPU itself would allow to select between
 Little-Endian and Big-Endian format by using an external circuit, in the GBA no 
such circuit exists, and the data format is always Little-Endian. That is, when 
accessing 16bit or 32bit data in memory, the least significant bits are stored 
in the first byte (smallest address), and the most significant bits in the last 
byte. (Ie. same as for 80x86 and Z80 CPUs.)<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="iomap"></A><FONT size="+2">&nbsp;I/O 
Map</FONT></TD></TR></TBODY></TABLE><BR><B>LCD I/O Registers</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000000h  2    R/W  DISPCNT   LCD Control
  4000002h  2    R/W  -         Undocumented - Green Swap
  4000004h  2    R/W  DISPSTAT  General LCD Status (STAT,LYC)
  4000006h  2    R    VCOUNT    Vertical Counter (LY)
  4000008h  2    R/W  BG0CNT    BG0 Control
  400000Ah  2    R/W  BG1CNT    BG1 Control
  400000Ch  2    R/W  BG2CNT    BG2 Control
  400000Eh  2    R/W  BG3CNT    BG3 Control
  4000010h  2    W    BG0HOFS   BG0 X-Offset
  4000012h  2    W    BG0VOFS   BG0 Y-Offset
  4000014h  2    W    BG1HOFS   BG1 X-Offset
  4000016h  2    W    BG1VOFS   BG1 Y-Offset
  4000018h  2    W    BG2HOFS   BG2 X-Offset
  400001Ah  2    W    BG2VOFS   BG2 Y-Offset
  400001Ch  2    W    BG3HOFS   BG3 X-Offset
  400001Eh  2    W    BG3VOFS   BG3 Y-Offset
  4000020h  2    W    BG2PA     BG2 Rotation/Scaling Parameter A (dx)
  4000022h  2    W    BG2PB     BG2 Rotation/Scaling Parameter B (dmx)
  4000024h  2    W    BG2PC     BG2 Rotation/Scaling Parameter C (dy)
  4000026h  2    W    BG2PD     BG2 Rotation/Scaling Parameter D (dmy)
  4000028h  4    W    BG2X      BG2 Reference Point X-Coordinate
  400002Ch  4    W    BG2Y      BG2 Reference Point Y-Coordinate
  4000030h  2    W    BG3PA     BG3 Rotation/Scaling Parameter A (dx)
  4000032h  2    W    BG3PB     BG3 Rotation/Scaling Parameter B (dmx)
  4000034h  2    W    BG3PC     BG3 Rotation/Scaling Parameter C (dy)
  4000036h  2    W    BG3PD     BG3 Rotation/Scaling Parameter D (dmy)
  4000038h  4    W    BG3X      BG3 Reference Point X-Coordinate
  400003Ch  4    W    BG3Y      BG3 Reference Point Y-Coordinate
  4000040h  2    W    WIN0H     Window 0 Horizontal Dimensions
  4000042h  2    W    WIN1H     Window 1 Horizontal Dimensions
  4000044h  2    W    WIN0V     Window 0 Vertical Dimensions
  4000046h  2    W    WIN1V     Window 1 Vertical Dimensions
  4000048h  2    R/W  WININ     Inside of Window 0 and 1
  400004Ah  2    R/W  WINOUT    Inside of OBJ Window &amp; Outside of Windows
  400004Ch  2    W    MOSAIC    Mosaic Size
  400004Eh       -    -         Not used
  4000050h  2    R/W  BLDCNT    Color Special Effects Selection
  4000052h  2    W    BLDALPHA  Alpha Blending Coefficients
  4000054h  2    W    BLDY      Brightness (Fade-In/Out) Coefficient
  4000056h       -    -         Not used
</PRE></TD></TR></TBODY></TABLE><B>Sound 
Registers</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000060h  2  R/W  SOUND1CNT_L Channel 1 Sweep register       (NR10)
  4000062h  2  R/W  SOUND1CNT_H Channel 1 Duty/Length/Envelope (NR11, NR12)
  4000064h  2  R/W  SOUND1CNT_X Channel 1 Frequency/Control    (NR13, NR14)
  4000066h     -    -           Not used
  4000068h  2  R/W  SOUND2CNT_L Channel 2 Duty/Length/Envelope (NR21, NR22)
  400006Ah     -    -           Not used
  400006Ch  2  R/W  SOUND2CNT_H Channel 2 Frequency/Control    (NR23, NR24)
  400006Eh     -    -           Not used
  4000070h  2  R/W  SOUND3CNT_L Channel 3 Stop/Wave RAM select (NR30)
  4000072h  2  R/W  SOUND3CNT_H Channel 3 Length/Volume        (NR31, NR32)
  4000074h  2  R/W  SOUND3CNT_X Channel 3 Frequency/Control    (NR33, NR34)
  4000076h     -    -           Not used
  4000078h  2  R/W  SOUND4CNT_L Channel 4 Length/Envelope      (NR41, NR42)
  400007Ah     -    -           Not used
  400007Ch  2  R/W  SOUND4CNT_H Channel 4 Frequency/Control    (NR43, NR44)
  400007Eh     -    -           Not used
  4000080h  2  R/W  SOUNDCNT_L  Control Stereo/Volume/Enable   (NR50, NR51)
  4000082h  2  R/W  SOUNDCNT_H  Control Mixing/DMA Control
  4000084h  2  R/W  SOUNDCNT_X  Control Sound on/off           (NR52)
  4000086h     -    -           Not used
  4000088h  2  BIOS SOUNDBIAS   Sound PWM Control
  400008Ah  ..   -    -         Not used
  4000090h 2x10h R/W  WAVE_RAM  Channel 3 Wave Pattern RAM (2 banks!!)
  40000A0h  4    W    FIFO_A    Channel A FIFO, Data 0-3
  40000A4h  4    W    FIFO_B    Channel B FIFO, Data 0-3
  40000A8h       -    -         Not used
</PRE></TD></TR></TBODY></TABLE><B>DMA 
Transfer Channels</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  40000B0h  4    W    DMA0SAD   DMA 0 Source Address
  40000B4h  4    W    DMA0DAD   DMA 0 Destination Address
  40000B8h  2    W    DMA0CNT_L DMA 0 Word Count
  40000BAh  2    R/W  DMA0CNT_H DMA 0 Control
  40000BCh  4    W    DMA1SAD   DMA 1 Source Address
  40000C0h  4    W    DMA1DAD   DMA 1 Destination Address
  40000C4h  2    W    DMA1CNT_L DMA 1 Word Count
  40000C6h  2    R/W  DMA1CNT_H DMA 1 Control
  40000C8h  4    W    DMA2SAD   DMA 2 Source Address
  40000CCh  4    W    DMA2DAD   DMA 2 Destination Address
  40000D0h  2    W    DMA2CNT_L DMA 2 Word Count
  40000D2h  2    R/W  DMA2CNT_H DMA 2 Control
  40000D4h  4    W    DMA3SAD   DMA 3 Source Address
  40000D8h  4    W    DMA3DAD   DMA 3 Destination Address
  40000DCh  2    W    DMA3CNT_L DMA 3 Word Count
  40000DEh  2    R/W  DMA3CNT_H DMA 3 Control
  40000E0h       -    -         Not used
</PRE></TD></TR></TBODY></TABLE><B>Timer 
Registers</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000100h  2    R/W  TM0CNT_L  Timer 0 Counter/Reload
  4000102h  2    R/W  TM0CNT_H  Timer 0 Control
  4000104h  2    R/W  TM1CNT_L  Timer 1 Counter/Reload
  4000106h  2    R/W  TM1CNT_H  Timer 1 Control
  4000108h  2    R/W  TM2CNT_L  Timer 2 Counter/Reload
  400010Ah  2    R/W  TM2CNT_H  Timer 2 Control
  400010Ch  2    R/W  TM3CNT_L  Timer 3 Counter/Reload
  400010Eh  2    R/W  TM3CNT_H  Timer 3 Control
  4000110h       -    -         Not used
</PRE></TD></TR></TBODY></TABLE><B>Serial 
Communication (1)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000120h  4    R/W  SIODATA32 SIO Data (Normal-32bit Mode) (shared with below!)
  4000120h  2    R/W  SIOMULTI0 SIO Data 0 (Parent)    (Multi-Player Mode)
  4000122h  2    R/W  SIOMULTI1 SIO Data 1 (1st Child) (Multi-Player Mode)
  4000124h  2    R/W  SIOMULTI2 SIO Data 2 (2nd Child) (Multi-Player Mode)
  4000126h  2    R/W  SIOMULTI3 SIO Data 3 (3rd Child) (Multi-Player Mode)
  4000128h  2    R/W  SIOCNT    SIO Control Register
  400012Ah  2    R/W  SIOMLT_SEND SIO Data (Local of Multi-Player) (shared below)
  400012Ah  2    R/W  SIODATA8  SIO Data (Normal-8bit and UART Mode)
  400012Ch       -    -         Not used
</PRE></TD></TR></TBODY></TABLE><B>Keypad 
Input</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000130h  2    R    KEYINPUT  Key Status
  4000132h  2    R/W  KEYCNT    Key Interrupt Control
</PRE></TD></TR></TBODY></TABLE><B>Serial 
Communication (2)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000134h  2    R/W  RCNT      SIO Mode Select/General Purpose Data
  4000136h  -    -    IR        Ancient - Infrared Register (Prototypes only)
  4000138h       -    -         Not used
  4000140h  2    R/W  JOYCNT    SIO JOY Bus Control
  4000142h       -    -         Not used
  4000150h  4    R/W  JOY_RECV  SIO JOY Bus Receive Data
  4000154h  4    R/W  JOY_TRANS SIO JOY Bus Transmit Data
  4000158h  2    R/?  JOYSTAT   SIO JOY Bus Receive Status
  400015Ah       -    -         Not used
</PRE></TD></TR></TBODY></TABLE><B>Interrupt, 
Waitstate, and Power-Down Control</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000200h  2    R/W  IE        Interrupt Enable Register
  4000202h  2    R/W  IF        Interrupt Request Flags / IRQ Acknowledge
  4000204h  2    R/W  WAITCNT   Game Pak Waitstate Control
  4000206h       -    -         Not used
  4000208h  2    R/W  IME       Interrupt Master Enable Register
  400020Ah       -    -         Not used
  4000300h  1    R/W  POSTFLG   Undocumented - Post Boot Flag
  4000301h  1    W    HALTCNT   Undocumented - Power Down Control
  4000302h       -    -         Not used
  4000410h  ?    ?    ?         Undocumented - Purpose Unknown / Bug ??? 0FFh
  4000411h       -    -         Not used
  4000800h  4    R/W  ?         Undocumented - Internal Memory Control (R/W)
  4000804h       -    -         Not used
  4xx0800h  4    R/W  ?         Mirrors of 4000800h (repeated each 64K)
</PRE></TD></TR></TBODY></TABLE><BR>
All further addresses at 4XXXXXXh are unused and do not contain mirrors of the 
I/O area, with the only exception that 4000800h is repeated each 64K (ie.
 mirrored at 4010800h, 4020800h, etc.)<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdvideocontroller"></A><FONT size="+2">&nbsp;LCD Video 
      Controller</FONT></TD></TR></TBODY></TABLE><BR><B>Registers</B><BR><A href="#lcdiodisplaycontrol">LCD 
I/O Display Control</A><BR><A href="#lcdiointerruptsandstatus">LCD 
I/O Interrupts and Status</A><BR><A href="#lcdiobgcontrol">LCD 
I/O BG Control</A><BR><A href="#lcdiobgscrolling">LCD 
I/O BG Scrolling</A><BR><A href="#lcdiobgrotationscaling">LCD 
I/O BG Rotation/Scaling</A><BR><A href="#lcdiowindowfeature">LCD 
I/O Window Feature</A><BR><A href="#lcdiomosaicfunction">LCD 
I/O Mosaic Function</A><BR><A href="#lcdiocolorspecialeffects">LCD 
I/O Color Special Effects</A><BR><BR><B>VRAM</B><BR><A href="#lcdvramoverview">LCD 
VRAM Overview</A><BR><A href="#lcdvramcharacterdata">LCD 
VRAM Character Data</A><BR><A href="#lcdvrambgscreendataformatbgmap">LCD 
VRAM BG Screen Data Format (BG Map)</A><BR><A href="#lcdvrambitmapbgmodes">LCD 
VRAM Bitmap BG Modes</A><BR><BR><B>Sprites</B><BR><A href="#lcdobjoverview">LCD 
OBJ - Overview</A><BR><A href="#lcdobjoamattributes">LCD 
OBJ - OAM Attributes</A><BR><A href="#lcdobjoamrotationscalingparameters">LCD 
OBJ - OAM Rotation/Scaling Parameters</A><BR><A href="#lcdobjvramcharactertilemapping">LCD 
OBJ - VRAM Character (Tile) Mapping</A><BR><BR><B>Other</B><BR><A href="#lcdcolorpalettes">LCD 
Color Palettes</A><BR><A href="#lcddimensionsandtimings">LCD 
Dimensions and Timings</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdiodisplaycontrol"></A><FONT size="+2">&nbsp;LCD I/O 
      Display Control</FONT></TD></TR></TBODY></TABLE><BR><B>4000000h - DISPCNT - LCD 
Control (Read/Write)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-2   BG Mode                (0-5=Video Mode 0-5, 6-7=Prohibited)
  3     Reserved for BIOS      (CGB Mode - cannot be changed after startup)
  4     Display Frame Select   (0-1=Frame 0-1) (for BG Modes 4,5 only)
  5     H-Blank Interval Free  (1=Allow access to OAM during H-Blank)
  6     OBJ Character VRAM Mapping (0=Two dimensional, 1=One dimensional)
  7     Forced Blank           (1=Allow access to VRAM,Palette,OAM)
  8     Screen Display BG0  (0=Off, 1=On)
  9     Screen Display BG1  (0=Off, 1=On)
  10    Screen Display BG2  (0=Off, 1=On)
  11    Screen Display BG3  (0=Off, 1=On)
  12    Screen Display OBJ  (0=Off, 1=On)
  13    Window 0 Display Flag   (0=Off, 1=On)
  14    Window 1 Display Flag   (0=Off, 1=On)
  15    OBJ Window Display Flag (0=Off, 1=On)
</PRE></TD></TR></TBODY></TABLE><BR>
The table summarizes the facilities of the separate BG modes (video modes).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE><B>  Mode  Rot/Scal Layers Size               Tiles Colors       Features</B>
  0     No       0123   256x256..512x515   1024  16/16..256/1 SFMABP
  1     Mixed    012-   (BG0,BG1 as above Mode 0, BG2 as below Mode 2)
  2     Yes      --23   128x128..1024x1024 256   256/1        S-MABP
  3     Yes      --?-   240x160            1     32768        --MABP
  4     Yes      --??   240x160            2     256/1        --MABP
  5     Yes      --??   160x128            2     32768        --MABP
</PRE></TD></TR></TBODY></TABLE>Features: 
S)crolling, F)lip, M)osaic, A)lphaBlending, B)rightness, P)riority.<BR><BR>BG 
Modes 0-2 are Tile/Map-based. BG Modes 3-5 are Bitmap-based, in these modes 1 or 
2 Frames (ie. bitmaps, or 'full screen tiles') exists, if two frames exist, 
either one can be displayed, and the other one can be redrawn in 
background.<BR><BR><B>Blanking Bits</B><BR>Setting Forced Blank (Bit 7) causes 
the video controller to display white lines, and all VRAM, Palette RAM, and OAM 
may be accessed.<BR>"When the internal HV synchronous counter cancels a forced 
blank during a display period, the display begins from the beginning, following 
the display of two vertical lines." What ???<BR>Setting H-Blank Interval Free 
(Bit 5) allows to access OAM during H-Blank time - using this feature reduces 
the number of sprites that can be displayed per line.<BR><BR><B>Display Enable 
Bits</B><BR>By default, BG0-3 and OBJ Display Flags (Bit 8-12) are used to 
enable/disable BGs and OBJ. When enabling Window 0 and/or 1 (Bit 13-14), color 
special effects may be used, and BG0-3 and OBJ are controlled by the 
window(s).<BR><BR><B>Frame Selection</B><BR>In BG Modes 4 and 5 (Bitmap modes), 
either one of the two bitmaps/frames may be displayed (Bit 4), allowing the user 
to update the other (invisible) frame in background. In BG Mode 3, only one 
frame exists.<BR>In BG Modes 0-2 (Tile/Map based modes), a similar effect may be 
gained by altering the base address(es) of BG Map and/or BG Character 
data.<BR><BR><B>4000002h - Undocumented - Green Swap (R/W)</B><BR>Normally, red 
green blue intensities for a group of two pixels is output as BGRbgr (uppercase 
for left pixel at even xloc, lowercase for right pixel at odd xloc). When the 
Green Swap bit is set, each pixel group is output as BgRbGr (ie. green intensity 
of each two pixels exchanged).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Green Swap  (0=Normal, 1=Swap)
  1-15  Not used
</PRE></TD></TR></TBODY></TABLE>This 
feature appears to be applied to the final picture (ie. after mixing the 
separate BG and OBJ layers). Eventually intended for other display types (with 
other pin-outs). With normal GBA hardware it is just producing an interesting 
dirt effect.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdiointerruptsandstatus"></A><FONT size="+2">&nbsp;LCD I/O 
      Interrupts and Status</FONT></TD></TR></TBODY></TABLE><BR><B>4000004h - DISPSTAT 
- General LCD Status (Read/Write)</B><BR>Display status and Interrupt control. 
The H-Blank conditions are generated once per scanline, including for the 
'hidden' scanlines during V-Blank.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     V-Blank flag   (Read only) (1=VBlank)
  1     H-Blank flag   (Read only) (1=HBlank)
  2     V-Counter flag (Read only) (1=Match)
  3     V-Blank IRQ Enable         (1=Enable)
  4     H-Blank IRQ Enable         (1=Enable)
  5     V-Counter IRQ Enable       (1=Enable)
  6-7   Not used
  8-15  V-Count Setting            (0-227)
</PRE></TD></TR></TBODY></TABLE>The 
V-Count-Setting value is much the same as LYC of older gameboys, when its value 
is identical to the content of the VCOUNT register then the V-Counter flag is 
set (Bit 2), and (if enabled in Bit 5) an interrupt is 
requested.<BR><BR><B>4000006h - VCOUNT - Vertical Counter (Read only)</B><BR>
Indicates the currently drawn scanline, values in range from 160-227 indicate 
'hidden' scanlines within VBlank area.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-7   Current scanline (0-227)
  8-15  Not Used
</PRE></TD></TR></TBODY></TABLE>Note: 
This is much the same than the 'LY' register of older gameboys.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdiobgcontrol"></A><FONT size="+2">&nbsp;LCD I/O BG 
      Control</FONT></TD></TR></TBODY></TABLE><BR><B>4000008h - BG0CNT - BG0 Control 
(R/W) (BG Modes 0,1 only)</B><BR><B>400000Ah - BG1CNT - BG1 Control (R/W) (BG 
Modes 0,1 only)</B><BR><B>400000Ch - BG2CNT - BG2 Control (R/W) (BG Modes 0,1,2 
only)</B><BR><B>400000Eh - BG3CNT - BG3 Control (R/W) (BG Modes 0,2 
only)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-1   BG Priority           (0-3, 0=Highest)
  2-3   Character Base Block  (0-3, in units of 16 KBytes) (=BG Tile Data)
  4-5   Not used (must be zero)
  6     Mosaic                (0=Disable, 1=Enable)
  7     Colors/Palettes       (0=16/16, 1=256/1)
  8-12  Screen Base Block     (0-31, in units of 2 KBytes) (=BG Map Data)
  13    Display Area Overflow (0=Transparent, 1=Wraparound; BG2CNT/BG3CNT only)
  14-15 Screen Size (0-3)
</PRE></TD></TR></TBODY></TABLE>Internal 
Screen Size (dots) and size of BG Map (bytes):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Value  Text Mode      Rotation/Scaling Mode
  0      256x256 (2K)   128x128   (256 bytes)
  1      512x256 (4K)   256x256   (1K)
  2      256x512 (4K)   512x512   (4K)
  3      512x512 (8K)   1024x1024 (16K)
</PRE></TD></TR></TBODY></TABLE>In 
case that some or all BGs are set to same priority then BG0 is having the 
highest, and BG3 the lowest priority.<BR><BR>In 'Text Modes', the screen size is 
organized as follows: The screen consists of one or more 256x256 pixel (32x32 
tiles) areas. When Size=0: only 1 area (SC0), when Size=1 or Size=2: two areas 
(SC0,SC1 either horizontally or vertically arranged next to each other), when 
Size=3: four areas (SC0,SC1 in upper row, SC2,SC3 in lower row). Whereas SC0 is
 defined by the normal BG Map base address (Bit 8-12 of BG#CNT), SC1 uses same 
address +2K, SC2 address +4K, SC3 address +6K. When the screen is scrolled it'll 
always wraparound.<BR><BR>In 'Rotation/Scaling Modes', the screen size is 
organized as follows, only one area (SC0) of variable size 128x128..1024x1024 
pixels (16x16..128x128 tiles) exists (SC0). When the screen is rotated/scaled
 (or scrolled?) so that the LCD viewport reaches outside of the
 background/screen area, then BG may be either displayed as transparent or 
wraparound (Bit 13 of BG#CNT).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdiobgscrolling"></A><FONT size="+2">&nbsp;LCD I/O BG 
      Scrolling</FONT></TD></TR></TBODY></TABLE><BR><B>4000010h - BG0HOFS - BG0 
X-Offset (W)</B><BR><B>4000012h - BG0VOFS - BG0 Y-Offset (W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-8   Offset (0-511)
  9-15  Not used
</PRE></TD></TR></TBODY></TABLE>Specifies 
the coordinate of the upperleft first visible dot of BG0 background layer, ie. 
used to scroll the BG0 area.<BR><BR><B>4000014h - BG1HOFS - BG1 X-Offset 
(W)</B><BR><B>4000016h - BG1VOFS - BG1 Y-Offset (W)</B><BR>Same as above BG0HOFS 
and BG0VOFS for BG1 respectively.<BR><BR><B>4000018h - BG2HOFS - BG2 X-Offset 
(W)</B><BR><B>400001Ah - BG2VOFS - BG2 Y-Offset (W)</B><BR>Same as above BG0HOFS 
and BG0VOFS for BG2 respectively.<BR><BR><B>400001Ch - BG3HOFS - BG3 X-Offset 
(W)</B><BR><B>400001Eh - BG3VOFS - BG3 Y-Offset (W)</B><BR>Same as above BG0HOFS 
and BG0VOFS for BG3 respectively.<BR><BR>The above BG scrolling registers are 
exclusively used in Text modes, ie. for all layers in BG Mode 0, and for the 
first two layers in BG mode 1.<BR>In other BG modes (Rotation/Scaling and Bitmap 
modes) above registers are ignored. Instead, the screen may be scrolled by 
modifying the BG Rotation/Scaling Reference Point registers.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdiobgrotationscaling"></A><FONT size="+2">&nbsp;LCD I/O BG 
      Rotation/Scaling</FONT></TD></TR></TBODY></TABLE><BR><B>4000028h - BG2X_L - BG2 
Reference Point X-Coordinate, lower 16 bit (W)</B><BR><B>400002Ah - BG2X_H - BG2 
Reference Point X-Coordinate, upper 12 bit (W)</B><BR><B>400002Ch - BG2Y_L - BG2 
Reference Point Y-Coordinate, lower 16 bit (W)</B><BR><B>400002Eh - BG2Y_H - BG2 
Reference Point Y-Coordinate, upper 12 bit (W)</B><BR>These registers are 
replacing the BG scrolling registers which are used for Text mode, ie. the X/Y 
coordinates specify the source position from inside of the BG Map/Bitmap of the 
pixel to be displayed at upper left of the GBA display. The normal BG scrolling 
registers are ignored in Rotation/Scaling and Bitmap modes.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-7   Fractional portion (8 bits)
  8-26  Integer portion    (19 bits)
  27    Sign               (1 bit)
  28-31 Not used
</PRE></TD></TR></TBODY></TABLE>Because 
values are shifted left by eight, fractional portions may be specified in steps 
of 1/256 pixels (this would be relevant only if the screen is actually rotated 
or scaled). Normal signed 32bit values may be written to above registers (the 
most significant bits will be ignored and the value will be cut-down to 28bits, 
but this is no actual problem because signed values have set all MSBs to the 
same value).<BR><BR><B>Internal Reference Point Registers</B><BR>The above 
reference points are automatically copied to internal registers during each 
vblank, specifying the origin for the first scanline. The internal registers are 
then incremented by dmx and dmy after each scanline.<BR>Caution: Writing to a 
reference point register by software outside of the Vblank period does 
immediately copy the new value to the corresponding internal register, that 
means: in the current frame, the new value specifies the origin of the 
&lt;current&gt; scanline (instead of the topmost scanline).<BR><BR><B>4000020h - 
BG2PA - BG2 Rotation/Scaling Parameter A (alias dx) (W)</B><BR><B>4000022h - 
BG2PB - BG2 Rotation/Scaling Parameter B (alias dmx) (W)</B><BR><B>4000024h - 
BG2PC - BG2 Rotation/Scaling Parameter C (alias dy)  (W)</B><BR><B>4000026h - 
BG2PD - BG2 Rotation/Scaling Parameter D (alias dmy) (W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-7   Fractional portion (8 bits)
  8-14  Integer portion    (7 bits)
  15    Sign               (1 bit)
</PRE></TD></TR></TBODY></TABLE>See 
below for details.<BR><BR><B>400003Xh - BG3X_L/H, BG3Y_L/H, BG3PA-D - BG3 
Rotation/Scaling Parameters</B><BR>Same as above BG2 Reference Point, and 
Rotation/Scaling Parameters, for BG3 respectively.<BR><BR><B>dx (PA) and dy 
(PC)</B><BR>When transforming a horizontal line, dx and dy specify the resulting
 gradient and magnification for that line. For example:<BR>Horizontal line, 
length=100, dx=1, and dy=1. The resulting line would be drawn at 45 degrees, 
f(y)=1/1*x. Note that this would involve that line is magnified, the new length 
is SQR(100^2+100^2)=141.42. Yup, exactly - that's the old a^2 + b^2 = c^2 
formula.<BR><BR><B>dmx (PB) and dmy (PD)</B><BR>These values define the 
resulting gradient and magnification for transformation of vertical lines. 
However, when rotating a square area (which is surrounded by horizontal and 
vertical lines), then the desired result should be usually a rotated 
&lt;square&gt; area (ie. not a parallelogram, for example).<BR>Thus, dmx and dmy 
must be defined in direct relationship to dx and dy, taking the example above, 
we'd have to set dmx=-1, and dmy=1, f(x)=-1/1*y.<BR><BR><B>Area Overflow</B><BR>
In result of rotation/scaling it may often happen that areas outside of the 
actual BG area become moved into the LCD viewport. Depending of the Area 
Overflow bit (BG2CNT and BG3CNT, Bit 13) these areas may be either displayed (by 
wrapping the BG area), or may be displayed transparent.<BR>This works only in BG 
modes 1 and 2. The area overflow is ignored in Bitmap modes (BG modes 3-5), the 
outside of the Bitmaps is always transparent.<BR><BR>--- more details and 
confusing or helpful formulas ---<BR><BR><B>The following parameters are 
required for Rotation/Scaling</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Rotation Center X and Y Coordinates (x0,y0)
  Rotation Angle                      (alpha)
  Magnification X and Y Values        (xMag,yMag)
</PRE></TD></TR></TBODY></TABLE>The 
display is rotated by 'alpha' degrees around the center.<BR>The displayed 
picture is magnified by 'xMag' along x-Axis (Y=y0) and 'yMag' along y-Axis 
(X=x0).<BR><BR><B>Calculating Rotation/Scaling Parameters A-D</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  A = Cos (alpha) / xMag    ;distance moved in direction x, same line
  B = Sin (alpha) / xMag    ;distance moved in direction x, next line
  C = Sin (alpha) / yMag    ;distance moved in direction y, same line
  D = Cos (alpha) / yMag    ;distance moved in direction y, next line
</PRE></TD></TR></TBODY></TABLE><BR><B>Calculating 
the position of a rotated/scaled dot</B><BR>Using the following expressions,<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  x0,y0    Rotation Center
  x1,y1    Old Position of a pixel (before rotation/scaling)
  x2,y2    New position of above pixel (after rotation scaling)
  A,B,C,D  BG2PA-BG2PD Parameters (as calculated above)
</PRE></TD></TR></TBODY></TABLE>the 
following formula can be used to calculate x2,y2:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  x2 = A(x1-x0) + B(y1-y0) + x0
  y2 = C(x1-x0) + D(y1-y0) + y0
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdiowindowfeature"></A><FONT size="+2">&nbsp;LCD I/O Window 
      Feature</FONT></TD></TR></TBODY></TABLE><BR>The Window Feature may be used to 
split the screen into four regions. The BG0-3,OBJ layers and Color Special 
Effects can be separately enabled or disabled in each of these 
regions.<BR><BR><B>The DISPCNT Register</B><BR>DISPCNT Bits 13-15 are used to 
enable Window 0, Window 1, and/or OBJ Window regions, if any of these regions is 
enabled then the "Outside of Windows" region is automatically enabled, too.<BR>
DISPCNT Bits 8-12 are kept used as master enable bits for the BG0-3,OBJ layers, 
a layer is displayed only if both DISPCNT and WININ/OUT enable bits are 
set.<BR><BR><B>4000040h - WIN0H - Window 0 Horizontal Dimensions 
(W)</B><BR><B>4000042h - WIN1H - Window 1 Horizontal Dimensions (W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-7   X2, Rightmost coordinate of window, plus 1
  8-15  X1, Leftmost coordinate of window
</PRE></TD></TR></TBODY></TABLE>Garbage 
values of X2&gt;240 or X1&gt;X2 are interpreted as X2=240.<BR><BR><B>4000044h - 
WIN0V - Window 0 Vertical Dimensions (W)</B><BR><B>4000046h - WIN1V - Window 1 
Vertical Dimensions (W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-7   Y2, Bottom-most coordinate of window, plus 1
  8-15  Y1, Top-most coordinate of window
</PRE></TD></TR></TBODY></TABLE>Garbage 
values of Y2&gt;160 or Y1&gt;Y2 are interpreted as Y2=160.<BR><BR><B>4000048h - 
WININ - Control of Inside of Window(s) (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-3   Window 0 BG0-BG3 Enable Bits     (0=No Display, 1=Display)
  4     Window 0 OBJ Enable Bit          (0=No Display, 1=Display)
  5     Window 0 Color Special Effect    (0=Disable, 1=Enable)
  6-7   Not used
  8-11  Window 1 BG0-BG3 Enable Bits     (0=No Display, 1=Display)
  12    Window 1 OBJ Enable Bit          (0=No Display, 1=Display)
  13    Window 1 Color Special Effect    (0=Disable, 1=Enable)
  14-15 Not used
</PRE></TD></TR></TBODY></TABLE><BR><B>400004Ah 
- WINOUT - Control of Outside of Windows &amp; Inside of OBJ Window 
(R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-3   Outside BG0-BG3 Enable Bits      (0=No Display, 1=Display)
  4     Outside OBJ Enable Bit           (0=No Display, 1=Display)
  5     Outside Color Special Effect     (0=Disable, 1=Enable)
  6-7   Not used
  8-11  OBJ Window BG0-BG3 Enable Bits   (0=No Display, 1=Display)
  12    OBJ Window OBJ Enable Bit        (0=No Display, 1=Display)
  13    OBJ Window Color Special Effect  (0=Disable, 1=Enable)
  14-15 Not used
</PRE></TD></TR></TBODY></TABLE><BR><B>The 
OBJ Window</B><BR>The dimension of the OBJ Window is specified by OBJs which are 
having the "OBJ Mode" attribute being set to "OBJ Window". Any non-transparent
 dots of any such OBJs are marked as OBJ Window area. The OBJ itself is not 
displayed.<BR>The color, palette, and display priority of these OBJs are 
ignored. Both DISPCNT Bits 12 and 15 must be set when defining OBJ Window 
region(s).<BR><BR><B>Window Priority</B><BR>In case that more than one window is 
enabled, and that these windows do overlap, Window 0 is having highest priority, 
Window 1 medium, and Obj Window lowest priority. Outside of Window is having 
zero priority, it is used for all dots which are not inside of any window 
region.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdiomosaicfunction"></A><FONT size="+2">&nbsp;LCD I/O Mosaic 
      Function</FONT></TD></TR></TBODY></TABLE><BR><B>400004Ch - MOSAIC - Mosaic Size 
(W)</B><BR>The Mosaic function can be separately enabled/disabled for BG0-BG3 by
 BG0CNT-BG3CNT Registers, as well as for each OBJ0-127 by OBJ attributes in OAM 
memory. Also, setting all of the bits below to zero effectively disables the 
mosaic function.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-3   BG Mosaic H-Size  (minus 1)
  4-7   BG Mosaic V-Size  (minus 1)
  8-11  OBJ Mosaic H-Size (minus 1)
  12-15 OBJ Mosaic V-Size (minus 1)
</PRE></TD></TR></TBODY></TABLE>Example: 
When setting H-Size to 5, then pixels 0-5 of each display row are colorized as 
pixel 0, pixels 6-11 as pixel 6, pixels 12-17 as pixel 12, and so on.<BR><BR>
Normally, a 'mosaic-pixel' is colorized by the color of the upperleft covered 
pixel. In many cases it might be more desireful to use the color of the pixel in 
the center of the covered area - this effect may be gained by scrolling the 
background (or by adjusting the OBJ position, as far as upper/left rows/columns 
of OBJ are transparent).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdiocolorspecialeffects"></A><FONT size="+2">&nbsp;LCD I/O 
      Color Special Effects</FONT></TD></TR></TBODY></TABLE><BR>Two types of Special 
Effects are supported: Alpha Blending (Semi-Transparency) allows to combine 
colors of two selected surfaces. Brightness Increase/Decrease adjust the 
brightness of the selected surface.<BR><BR><B>4000050h - BLDCNT - Color Special 
Effects Selection (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     BG0 1st Target Pixel (Background 0)
  1     BG1 1st Target Pixel (Background 1)
  2     BG2 1st Target Pixel (Background 2)
  3     BG3 1st Target Pixel (Background 3)
  4     OBJ 1st Target Pixel (Top-most OBJ pixel)
  5     BD  1st Target Pixel (Backdrop)
  6-7   Color Special Effect (0-3, see below)
         0 = None                (Special effects disabled)
         1 = Alpha Blending      (1st+2nd Target mixed)
         2 = Brightness Increase (1st Target becomes whiter)
         3 = Brightness Decrease (1st Target becomes blacker)
  8     BG0 2nd Target Pixel (Background 0)
  9     BG1 2nd Target Pixel (Background 1)
  10    BG2 2nd Target Pixel (Background 2)
  11    BG3 2nd Target Pixel (Background 3)
  12    OBJ 2nd Target Pixel (Top-most OBJ pixel)
  13    BD  2nd Target Pixel (Backdrop)
  14-15 Not used
</PRE></TD></TR></TBODY></TABLE>Selects 
the 1st Target layer(s) for special effects. For Alpha
 Blending/Semi-Transparency, it does also select the 2nd Target layer(s), which 
should have next lower display priority as the 1st Target.<BR>However, any 
combinations are possible, including that all layers may be selected as both 
1st+2nd target, in that case the top-most pixel will be used as 1st target, and 
the next lower pixel as 2nd target.<BR><BR><B>4000052h - BLDALPHA - Alpha 
Blending Coefficients (W)</B><BR>Used for Color Special Effects Mode 1, and for 
Semi-Transparent OBJs.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-4   EVA Coefficient (1st Target) (0..16 = 0/16..16/16, 17..31=16/16)
  5-7   Not used
  8-12  EVB Coefficient (2nd Target) (0..16 = 0/16..16/16, 17..31=16/16)
  13-15 Not used
</PRE></TD></TR></TBODY></TABLE>For 
this effect, the top-most non-transparent pixel must be selected as 1st Target, 
and the next-lower non-transparent pixel must be selected as 2nd Target, if so - 
and only if so, then color intensities of 1st and 2nd Target are mixed together 
by using the parameters in BLDALPHA register, for each pixel each R, G, B 
intensities are calculated separately:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  I = MIN ( 31, I1st*EVA + I2nd*EVB )
</PRE></TD></TR></TBODY></TABLE>Otherwise 
- for example, if only one target exists, or if a non-transparent non-2nd-target 
pixel is moved between the two targets, or if 2nd target has higher display 
priority than 1st target - then only the top-most pixel is displayed (at normal 
intensity, regardless of BLDALPHA).<BR><BR><B>4000054h - BLDY - Brightness 
(Fade-In/Out) Coefficient (W)</B><BR>Used for Color Special Effects Modes 2 and 
3.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-4   EVY Coefficient (Brightness) (0..16 = 0/16..16/16, 17..31=16/16)
  5-15  Not used
</PRE></TD></TR></TBODY></TABLE>For 
each pixel each R, G, B intensities are calculated separately:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  I = I1st + (31-I1st)*EVY   ;For Brightness Increase
  I = I1st - (I1st)*EVY      ;For Brightness Decrease
</PRE></TD></TR></TBODY></TABLE>The 
color intensities of any selected 1st target surface(s) are increased or 
decreased by using the parameter in BLDY register.<BR><BR><B>Semi-Transparent 
OBJs</B><BR>OBJs that are defined as 'Semi-Transparent' in OAM memory are always
 selected as 1st Target (regardless of BLDCNT Bit 4), and are always using Alpha 
Blending mode (regardless of BLDCNT Bit 6-7).<BR>The BLDCNT register may be used 
to perform Brightness effects on the OBJ (and/or other BG/BD layers). However, 
if a semi-transparent OBJ pixel does overlap a 2nd target pixel, then 
semi-transparency becomes priority, and the brightness effect will not take 
place (neither on 1st, nor 2nd target).<BR><BR><B>The OBJ Layer</B><BR>Before 
special effects are applied, the display controller computes the OBJ priority 
ordering, and isolates the top-most OBJ pixel. In result, only the top-most OBJ 
pixel is recursed at the time when processing special effects. Ie. alpha 
blending and semi-transparency can be used for OBJ-to-BG or BG-to-OBJ , but not 
for OBJ-to-OBJ.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdvramoverview"></A><FONT size="+2">&nbsp;LCD VRAM 
      Overview</FONT></TD></TR></TBODY></TABLE><BR>The GBA contains 96 Kbytes VRAM 
built-in, located at address 06000000-06017FFF, depending on the BG Mode used as 
follows:<BR><BR><B>BG Mode 0,1,2 (Tile/Map based Modes)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  06000000-0600FFFF  64 KBytes shared for BG Map and Tiles
  06010000-06017FFF  32 KBytes OBJ Tiles
</PRE></TD></TR></TBODY></TABLE>The 
shared 64K area can be split into BG Map area(s), and BG Tiles area(s), the 
respective addresses for Map and Tile areas are set up by BG0CNT-BG3CNT 
registers. The Map address may be specified in units of 2K (steps of 800h), the 
Tile address in units of 16K (steps of 4000h).<BR><BR><B>BG Mode 0,1 (Tile/Map 
based Text mode)</B><BR>The tiles may have 4bit or 8bit color depth, minimum map 
size is 32x32 tiles, maximum is 64x64 tiles, up to 1024 tiles can be used per 
map.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Item        Depth     Required Memory
  One Tile    4bit      20h bytes
  One Tile    8bit      40h bytes
  1024 Tiles  4bit      8000h (32K)
  1024 Tiles  8bit      10000h (64K) - excluding some bytes for BG map
  BG Map      32x32     800h (2K)
  BG Map      64x64     2000h (8K)
</PRE></TD></TR></TBODY></TABLE><BR><B>BG 
Mode 1,2 (Tile/Map based Rotation/Scaling mode)</B><BR>The tiles may have 8bit 
color depth only, minimum map size is 16x16 tiles, maximum is 128x128 tiles, up 
to 256 tiles can be used per map.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Item        Depth     Required Memory
  One Tile    8bit      40h bytes
  256  Tiles  8bit      4000h (16K)
  BG Map      16x16     100h bytes
  BG Map      128x128   4000h (16K)
</PRE></TD></TR></TBODY></TABLE><BR><B>BG 
Mode 3 (Bitmap based Mode for still images)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  06000000-06013FFF  80 KBytes Frame 0 buffer (only 75K actually used)
  06014000-06017FFF  16 KBytes OBJ Tiles
</PRE></TD></TR></TBODY></TABLE><BR><B>BG 
Mode 4,5 (Bitmap based Modes)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  06000000-06009FFF  40 KBytes Frame 0 buffer (only 37.5K used in Mode 4)
  0600A000-06013FFF  40 KBytes Frame 1 buffer (only 37.5K used in Mode 4)
  06014000-06017FFF  16 KBytes OBJ Tiles
</PRE></TD></TR></TBODY></TABLE><BR><B>Note</B><BR>
Additionally to the above VRAM, the GBA also contains 1 KByte Palette RAM (at 
05000000h) and 1 KByte OAM (at 07000000h) which are both used by the display 
controller as well.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdvramcharacterdata"></A><FONT size="+2">&nbsp;LCD VRAM 
      Character Data</FONT></TD></TR></TBODY></TABLE><BR>Each character (tile) 
consists of 8x8 dots (64 dots in total). The color depth may be either 4bit or 
8bit (see BG0CNT-BG3CNT).<BR><BR><B>4bit depth (16 colors, 16 palettes)</B><BR>
Each tile occupies 32 bytes of memory, the first 4 bytes for the topmost row of 
the tile, and so on. Each byte representing two dots, the lower 4 bits define 
the color for the left (!) dot, the upper 4 bits the color for the right 
dot.<BR><BR><B>8bit depth (256 colors, 1 palette)</B><BR>Each tile occupies 64 
bytes of memory, the first 8 bytes for the topmost row of the tile, and so on. 
Each byte selects the palette entry for each dot.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdvrambgscreendataformatbgmap"></A><FONT size="+2">&nbsp;LCD 
      VRAM BG Screen Data Format (BG Map)</FONT></TD></TR></TBODY></TABLE><BR>The 
display background consists of 8x8 dot tiles, the arrangement of these tiles is 
specified by the BG Screen Data (BG Map). The separate entries in this map are 
as follows:<BR><BR><B>Text BG Screen (2 bytes per entry)</B><BR>Specifies the 
tile number and attributes. Note that BG tile numbers are always specified in 
steps of 1 (unlike OBJ tile numbers which are using steps of two in 256 color/1 
palette mode).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-9   Tile Number     (0-1023) (a bit less in 256 color mode, because
                           there'd be otherwise no room for the bg map)
  10    Horizontal Flip (0=Normal, 1=Mirrored)
  11    Vertical Flip   (0=Normal, 1=Mirrored)
  12-15 Palette Number  (0-15)    (Not used in 256 color/1 palette mode)
</PRE></TD></TR></TBODY></TABLE>A 
Text BG Map always consists of 32x32 entries (256x256 pixels), 400h entries = 
800h bytes. However, depending on the BG Size, one, two, or four of these Maps 
may be used together, allowing to create backgrounds of 256x256, 512x256, 
256x512, or 512x512 pixels, if so, the first map (SC0) is located at base+0, the 
next map (SC1) at base+800h, and so on.<BR><BR><B>Rotation/Scaling BG Screen (1 
byte per entry)</B><BR>In this mode, only 256 tiles can be used. There are no 
x/y-flip attributes, the color depth is always 256 colors/1 palette.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-7   Tile Number     (0-255)
</PRE></TD></TR></TBODY></TABLE>The 
dimensions of Rotation/Scaling BG Maps depend on the BG size. For size 0-3 that 
are: 16x16 tiles (128x128 pixels), 32x32 tiles (256x256 pixels), 64x64 tiles 
(512x512 pixels), or 128x128 tiles (1024x1024 pixels).<BR><BR>The size and VRAM 
base address of the separate BG maps for BG0-3 are set up by BG0CNT-BG3CNT 
registers.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdvrambitmapbgmodes"></A><FONT size="+2">&nbsp;LCD VRAM 
      Bitmap BG Modes</FONT></TD></TR></TBODY></TABLE><BR>In BG Modes 3-5 the 
background is defined in form of a bitmap (unlike as for Tile/Map based BG 
modes). Bitmaps are implemented as BG2, with Rotation/Scaling support. As bitmap 
modes are occupying 80KBytes of BG memory, only 16KBytes of VRAM can be used for 
OBJ tiles.<BR><BR><B>BG Mode 3 - 240x160 pixels, 32768 colors</B><BR>Two bytes 
are associated to each pixel, directly defining one of the 32768 colors (without 
using palette data, and thus not supporting a 'transparent' BG color).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-4   Red Intensity   (0-31)
  5-9   Green Intensity (0-31)
  10-14 Blue Intensity  (0-31)
  15    Not used
</PRE></TD></TR></TBODY></TABLE>The 
first 480 bytes define the topmost line, the next 480 the next line, and so on. 
The background occupies 75 KBytes (06000000-06012BFF), most of the 80 Kbytes BG 
area, not allowing to redraw an invisible second frame in background, so this 
mode is mostly recommended for still images only.<BR><BR><B>BG Mode 4 - 240x160 
pixels, 256 colors (out of 32768 colors)</B><BR>One byte is associated to each 
pixel, selecting one of the 256 palette entries. Color 0 (backdrop) is 
transparent, and OBJs may be displayed behind the bitmap.<BR>The first 240 bytes 
define the topmost line, the next 240 the next line, and so on. The background 
occupies 37.5 KBytes, allowing two frames to be used (06000000-060095FF for 
Frame 0, and 0600A000-060135FF for Frame 1).<BR><BR><B>BG Mode 5 - 160x128 
pixels, 32768 colors</B><BR>Colors are defined as for Mode 3 (see above), but 
horizontal and vertical size are cut down to 160x128 pixels only - smaller than 
the physical dimensions of the LCD screen.<BR>The background occupies exactly 40 
KBytes, so that BG VRAM may be split into two frames (06000000-06009FFF for 
Frame 0, and 0600A000-06013FFF for Frame 1).<BR><BR>In BG modes 4,5, one Frame 
may be displayed (selected by DISPCNT Bit 4), the other Frame is invisible and 
may be redrawn in background.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdobjoverview"></A><FONT size="+2">&nbsp;LCD OBJ - 
      Overview</FONT></TD></TR></TBODY></TABLE><BR><B>General</B><BR>Objects (OBJs) 
are moveable sprites. Up to 128 OBJs (of any size, up to 64x64 dots each) can be 
displayed per screen, and under best circumstances up to 128 OBJs (of small 8x8 
dots size) can be displayed per horizontal display line.<BR><BR><B>Maximum 
Number of Sprites per Line</B><BR>The total available OBJ rendering cycles per 
line are<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  1210  (=304*4-6)   If "H-Blank Interval Free" bit in DISPCNT register is 0
  954   (=240*4-6)   If "H-Blank Interval Free" bit in DISPCNT register is 1
</PRE></TD></TR></TBODY></TABLE>The 
required rendering cycles are (depending on horizontal OBJ size)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Cycles per &lt;n&gt; Pixels    OBJ Type              OBJ Type Screen Pixel Range
  n*1 cycles               Normal OBJs           8..64 pixels
  10+n*2 cycles            Rotation/Scaling OBJs 8..64 pixels   (area clipped)
  10+n*2 cycles            Rotation/Scaling OBJs 16..128 pixels (double size)
</PRE></TD></TR></TBODY></TABLE>Caution:<BR>
The maximum number of OBJs per line is also affected by undisplayed (offscreen) 
OBJs which are having higher priority than displayed OBJs.<BR>To avoid this, 
move displayed OBJs to the begin of OAM memory (ie. OBJ0 has highest priority, 
OBJ127 lowest).<BR>Otherwise (in case that the program logic expects OBJs at 
fixed positions in OAM) at least take care to set the OBJ size of undisplayed
 OBJs to 8x8 with Rotation/Scaling disabled (this reduces the overload).<BR>Does 
the above also apply for VERTICALLY OFFSCREEN (or VERTICALLY not on CURRENT 
LINE) sprites ???<BR><BR><B>VRAM - Character Data</B><BR>OBJs are always 
combined of one or more 8x8 pixel Tiles (much like BG Tiles in BG Modes 0-2). 
However, OBJ Tiles are stored in a separate area in VRAM: 06010000-06017FFF (32 
KBytes) in BG Mode 0-2, or 06014000-06017FFF (16 KBytes) in BG Mode 3-5.<BR>
Depending on the size of the above area (16K or 32K), and on the OBJ color depth 
(4bit or 8bit), 256-1024 8x8 dots OBJ Tiles can be defined.<BR><BR><B>OAM - 
Object Attribute Memory</B><BR>This memory area contains Attributes which 
specify position, size, color depth, etc. appearance for each of the 128 OBJs. 
Additionally, it contains 32 OBJ Rotation/Scaling Parameter groups. OAM is 
located at 07000000-070003FF (sized 1 KByte).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdobjoamattributes"></A><FONT size="+2">&nbsp;LCD OBJ - OAM 
      Attributes</FONT></TD></TR></TBODY></TABLE><BR><B>OBJ Attributes</B><BR>There 
are 128 entries in OAM for each OBJ0-OBJ127. Each entry consists of 6 bytes 
(three 16bit Attributes). Attributes for OBJ0 are located at 07000000, for OBJ1 
at 07000008, OBJ2 at 07000010, and so on.<BR><BR>As you can see, there are blank 
spaces at 07000006, 0700000E, 07000016, etc. - these 16bit values are used for 
OBJ Rotation/Scaling (as described in the next chapter) - they are not directly 
related to the separate OBJs.<BR><BR><B>OBJ Attribute 0 (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-7   Y-Coordinate           (0-255)
  8     Rotation/Scaling Flag  (0=Off, 1=On)
  When Rotation/Scaling used (Attribute 0, bit 8 set):
    9     Double-Size Flag     (0=Normal, 1=Double)
  When Rotation/Scaling not used (Attribute 0, bit 8 cleared):
    9     OBJ Disable          (0=Normal, 1=Not displayed)
  10-11 OBJ Mode  (0=Normal, 1=Semi-Transparent, 2=OBJ Window, 3=Prohibited)
  12    OBJ Mosaic             (0=Off, 1=On)
  13    Colors/Palettes        (0=16/16, 1=256/1)
  14-15 OBJ Shape              (0=Square,1=Horizontal,2=Vertical,3=Prohibited)
</PRE></TD></TR></TBODY></TABLE>Caution: 
A very large OBJ (of 128 pixels vertically, ie. a 64 pixels OBJ in a Double Size 
area) located at Y&gt;128 will be treated as at Y&gt;-128, the OBJ is then 
displayed parts offscreen at the TOP of the display, it is then NOT displayed at 
the bottom.<BR><BR><B>OBJ Attribute 1 (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-8   X-Coordinate           (0-511)
  When Rotation/Scaling used (Attribute 0, bit 8 set):
    9-13  Rotation/Scaling Parameter Selection (0-31)
          (Selects one of the 32 Rotation/Scaling Parameters that
          can be defined in OAM, for details read next chapter.)
  When Rotation/Scaling not used (Attribute 0, bit 8 cleared):
    9-11  Not used
    12    Horizontal Flip      (0=Normal, 1=Mirrored)
    13    Vertical Flip        (0=Normal, 1=Mirrored)
  14-15 OBJ Size               (0..3, depends on OBJ Shape, see Attr 0)
          Size  Square   Horizontal  Vertical
          0     8x8      16x8        8x16
          1     16x16    32x8        8x32
          2     32x32    32x16       16x32
          3     64x64    64x32       32x64
</PRE></TD></TR></TBODY></TABLE><BR><B>OBJ 
Attribute 2 (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-9   Character Name          (0-1023=Tile Number)
  10-11 Priority relative to BG (0-3; 0=Highest)
  12-15 Palette Number   (0-15) (Not used in 256 color/1 palette mode)
</PRE></TD></TR></TBODY></TABLE><BR><B>Notes:</B><BR><BR><B>OBJ 
Mode</B><BR>The OBJ Mode may be Normal, Semi-Transparent, or OBJ Window.<BR>
Semi-Transparent means that the OBJ is used as 'Alpha Blending 1st Target' 
(regardless of BLDCNT register, for details see chapter about Color Special 
Effects).<BR>OBJ Window means that the OBJ is not displayed, instead, dots with
 non-zero color are used as mask for the OBJ Window, see DISPCNT and WINOUT for 
details.<BR><BR><B>OBJ Tile Number</B><BR>There are two situations which may 
divide the amount of available tiles by two (by four if both situations 
apply):<BR><BR>1. When using the 256 Colors/1 Palette mode, only each second 
tile may be used, the lower bit of the tile number should be zero (in
 2-dimensional mapping mode, the bit is completely ignored).<BR><BR>2. When 
using BG Mode 3-5 (Bitmap Modes), only tile numbers 512-1023 may be used. That 
is because lower 16K of OBJ memory are used for BG. Attempts to use tiles 0-511 
are ignored (not displayed).<BR><BR><B>Priority</B><BR>In case that the 
'Priority relative to BG' is the same than the priority of one of the background 
layers, then the OBJ becomes higher priority and is displayed on top of that BG 
layer.<BR>Caution: Take care not to mess up BG Priority and OBJ priority. For
 example, the following would cause garbage to be displayed:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  OBJ No. 0 with Priority relative to BG=1   ;hi OBJ prio, lo BG prio
  OBJ No. 1 with Priority relative to BG=0   ;lo OBJ prio, hi BG prio
</PRE></TD></TR></TBODY></TABLE>That 
is, OBJ0 is always having priority above OBJ1-127, so assigning a lower BG 
Priority to OBJ0 than for OBJ1-127 would be a bad idea.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdobjoamrotationscalingparameters"></A><FONT 
      size="+2">&nbsp;LCD OBJ - OAM Rotation/Scaling 
  Parameters</FONT></TD></TR></TBODY></TABLE><BR>As described in the previous 
chapter, there are blank spaces between each of the 128 OBJ Attribute Fields in 
OAM memory. These 128 16bit gaps are used to store OBJ Rotation/Scaling 
Parameters.<BR><BR><B>Location of Rotation/Scaling Parameters in OAM</B><BR>Four 
16bit parameters (PA,PB,PC,PD) are required to define a complete group of 
Rotation/Scaling data. These are spread across OAM as such:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  1st Group - PA=07000006, PB=0700000E, PC=07000016, PD=0700001E
  2nd Group - PA=07000026, PB=0700002E, PC=07000036, PD=0700003E
  etc.
</PRE></TD></TR></TBODY></TABLE>By 
using all blank space (128 x 16bit), up to 32 of these groups (4 x 16bit each) 
can be defined in OAM.<BR><BR><B>OBJ Rotation/Scaling PA,PB,PC,PD Parameters 
(R/W)</B><BR>Each OBJ that uses Rotation/Scaling may select between any of the 
above 32 parameter groups. For details, refer to the previous chapter about OBJ 
Attributes.<BR>The meaning of the separate PA,PB,PC,PD values is identical as 
for BG, for details read the chapter about BG Rotation/Scaling.<BR><BR><B>OBJ 
Reference Point &amp; Rotation Center</B><BR>The OBJ Reference Point is the 
upper left of the OBJ, ie. OBJ X/Y coordinates: X+0, Y+0.<BR>The OBJ Rotation 
Center is always (or should be usually?) in the middle of the object, ie. for a 
8x32 pixel OBJ, this would be at the OBJ X/Y coordinates: X+4, and 
Y+16.<BR><BR><B>OBJ Double-Size Bit (for OBJs that use Rotation/Scaling)</B><BR>
When Double-Size is zero: The sprite is rotated, and then display inside of the 
normal-sized (not rotated) rectangular area - the edges of the rotated sprite 
will become invisible if they reach outside of that area.<BR>When Double-Size is 
set: The sprite is rotated, and then display inside of the double-sized (not 
rotated) rectangular area - this ensures that the edges of the rotated sprite 
remain visible even if they would reach outside of the normal-sized area. 
(Except that, for example, rotating a 8x32 pixel sprite by 90 degrees would 
still cut off parts of the sprite as the double-size area isn't large 
enough.)<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdobjvramcharactertilemapping"></A><FONT size="+2">&nbsp;LCD 
      OBJ - VRAM Character (Tile) Mapping</FONT></TD></TR></TBODY></TABLE><BR>Each OBJ 
tile consists of 8x8 dots, however, bigger OBJs can be displayed by combining 
several 8x8 tiles. The horizontal and vertical size for each OBJ may be 
separately defined in OAM, possible H/V sizes are 8,16,32,64 dots - allowing 
'square' OBJs to be used (such like 8x8, 16x16, etc) as well as 'rectangular' 
OBJs (such like 8x32, 64x16, etc.)<BR><BR>When displaying an OBJ that contains 
of more than one 8x8 tile, one of the following two mapping modes can be used. 
In either case, the tile number of the upperleft tile must be specified in OAM 
memory.<BR><BR><B>Two Dimensional Character Mapping (DISPCNT Bit 6 
cleared)</B><BR>This mapping mode assumes that the 1024 OBJ tiles are arranged 
as a matrix of 32x32 tiles / 256x256 pixels (In 256 color mode: 16x32 tiles /
 128x256 pixels). Ie. the upper row of this matrix contains tiles 00h-1Fh, the 
next row tiles 20h-3Fh, and so on.<BR>For example, when displaying a 16x16 pixel 
OBJ, with tile number set to 04h; The upper row of the OBJ will consist of tile 
04h and 05h, the next row of 24h and 25h. (In 256 color mode: 04h and 06h, 24h 
and 26h.)<BR><BR><B>One Dimensional Character Mapping (DISPCNT Bit 6 
set)</B><BR>In this mode, tiles are mapped each after each other from 
00h-3FFh.<BR>Using the same example as above, the upper row of the OBJ will 
consist of tile 04h and 05h, the next row of tile 06h and 07h. (In 256 color
 mode: 04h and 06h, 08h and 0Ah.)<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcdcolorpalettes"></A><FONT size="+2">&nbsp;LCD Color 
      Palettes</FONT></TD></TR></TBODY></TABLE><BR><B>Color Palette RAM</B><BR>BG and 
OBJ palettes are using separate memory regions:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  05000000-050001FF - BG Palette RAM (512 bytes, 256 colors)
  05000200-050003FF - OBJ Palette RAM (512 bytes, 256 colors)
</PRE></TD></TR></TBODY></TABLE>Each 
BG and OBJ palette RAM may be either split into 16 palettes with 16 colors each, 
or may be used as a single palette with 256 colors.<BR>Note that some OBJs may 
access palette RAM in 16 color mode, while other OBJs may use 256 color mode at 
the same time. Same for BG0-BG3 layers.<BR><BR><B>Transparent Colors</B><BR>
Color 0 of all BG and OBJ palettes is transparent. Even though palettes are 
described as 16 (256) color palettes, only 15 (255) colors are actually 
visible.<BR><BR><B>Backdrop Color</B><BR>Color 0 of BG Palette 0 is used as 
backdrop color. This color is displayed if an area of the screen is not covered 
by any non-transparent BG or OBJ dots.<BR><BR><B>Color Definitions</B><BR>Each 
color occupies two bytes (same as for 32768 color BG modes):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-4   Red Intensity   (0-31)
  5-9   Green Intensity (0-31)
  10-14 Blue Intensity  (0-31)
  15    Not used
</PRE></TD></TR></TBODY></TABLE><BR><B>Intensities</B><BR>
Under normal circumstances (light source/viewing angle), the intensities 0-14 
are practically all black, and only intensities 15-31 are resulting in visible 
medium..bright colors.<BR><BR>Note: The intensity problem appears in the 8bit 
CGB "compatibility" mode either. The original CGB display produced the opposite 
effect: Intensities 0-14 resulted in dark..medium colors, and intensities 15-31
 resulted in bright colors. Any "medium" colors of CGB games will appear
 invisible/black on GBA hardware, and only very bright colors will be
 visible.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="lcddimensionsandtimings"></A><FONT size="+2">&nbsp;LCD 
      Dimensions and Timings</FONT></TD></TR></TBODY></TABLE><BR><B>Horizontal 
Dimensions</B><BR>The drawing time for each dot is 4 CPU cycles.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Visible     240 dots,  57.221 us,    960 cycles - 78% of h-time
  H-Blanking   68 dots,  16.212 us,    272 cycles - 22% of h-time
  Total       308 dots,  73.433 us,   1232 cycles - ca. 13.620 kHz
</PRE></TD></TR></TBODY></TABLE>VRAM 
and Palette RAM may be accessed during H-Blanking. OAM can accessed only if 
"H-Blank Interval Free" bit in DISPCNT register is set.<BR><BR><B>Vertical 
Dimensions</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Visible (*) 160 lines, 11.749 ms, 197120 cycles - 70% of v-time
  V-Blanking   68 lines,  4.994 ms,  83776 cycles - 30% of v-time
  Total       228 lines, 16.743 ms, 280896 cycles - ca. 59.737 Hz
</PRE></TD></TR></TBODY></TABLE>All 
VRAM, OAM, and Palette RAM may be accessed during V-Blanking.<BR>Note that no 
H-Blank interrupts are generated within V-Blank period.<BR><BR><B>System 
Clock</B><BR>The system clock is 16.78MHz (16*1024*1024 Hz), one cycle is thus
 approx. 59.59ns.<BR><BR>(*) Even though vertical screen size is 160 lines, the 
upper 8 lines are not &lt;really&gt; visible, these lines are covered by a 
shadow when holding the GBA orientated towards a light source, the lines are 
effectively black - and should not be used to display important 
information.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="soundcontroller"></A><FONT size="+2">&nbsp;Sound 
      Controller</FONT></TD></TR></TBODY></TABLE><BR>The GBA supplies four 'analogue' 
sound channels for Tone and Noise (mostly compatible to CGB sound), as well as 
two 'digital' sound channels (which can be used to replay 8bit DMA sample 
data).<BR><BR><A href="#soundchannel1tonesweep">Sound 
Channel 1 - Tone &amp; Sweep</A><BR><A href="#soundchannel2tone">Sound 
Channel 2 - Tone</A><BR><A href="#soundchannel3waveoutput">Sound 
Channel 3 - Wave Output</A><BR><A href="#soundchannel4noise">Sound 
Channel 4 - Noise</A><BR><A href="#soundchannelaandbdmasound">Sound 
Channel A and B - DMA Sound</A><BR><BR><A href="#soundcontrolregisters">Sound 
Control Registers</A><BR><A href="#comparisonofcgbandgbasound">Comparison 
of CGB and GBA Sound</A><BR><BR>The GBA includes only a single (mono) speaker 
built-in, each channel may be output to either left and/or right channels by 
using the external line-out connector (for stereo headphones, etc).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="soundchannel1tonesweep"></A><FONT size="+2">&nbsp;Sound 
      Channel 1 - Tone &amp; Sweep</FONT></TD></TR></TBODY></TABLE><BR><B>4000060h - 
SOUND1CNT_L (NR10) - Channel 1 Sweep register (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit        Expl.
  0-2   R/W  Number of sweep shift      (n=0-7)
  3     R/W  Sweep Frequency Direction  (0=Increase, 1=Decrease)
  4-6   R/W  Sweep Time; units of 7.8ms (0-7, min=7.8ms, max=54.7ms)
  7-15  -    Not used
</PRE></TD></TR></TBODY></TABLE>Sweep 
is disabled by setting Sweep Time to zero, if so, the direction bit should be 
set.<BR>The change of frequency (NR13,NR14) at each shift is calculated by the
 following formula where X(0) is initial freq &amp; X(t-1) is last freq:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  X(t) = X(t-1) +/- X(t-1)/2^n
</PRE></TD></TR></TBODY></TABLE><BR><B>4000062h 
- SOUND1CNT_H (NR11, NR12) - Channel 1 Duty/Len/Envelope (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit        Expl.
  0-5   W    Sound length; units of (64-n)/256s  (0-63)
  6-7   R/W  Wave Pattern Duty                   (0-3, see below)
  8-10  R/W  Envelope Step-Time; units of n/64s  (1-7, 0=No Envelope)
  11    R/W  Envelope Direction                  (0=Decrease, 1=Increase)
  12-15 R/W  Initial Volume of envelope          (1-15, 0=No Sound)
</PRE></TD></TR></TBODY></TABLE>Wave 
Duty:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0: 12.5% ( -_______-_______-_______ )
  1: 25%   ( --______--______--______ )
  2: 50%   ( ----____----____----____ ) (normal)
  3: 75%   ( ------__------__------__ )
</PRE></TD></TR></TBODY></TABLE>The 
Length value is used only if Bit 6 in NR14 is set.<BR><BR><B>4000064h - 
SOUND1CNT_X (NR13, NR14) - Channel 1 Frequency/Control (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit        Expl.
  0-10  W    Frequency; 131072/(2048-n)Hz  (0-2047)
  11-13 -    Not used
  14    R/W  Length Flag  (1=Stop output when length in NR11 expires)
  15    W    Initial      (1=Restart Sound)
</PRE></TD></TR></TBODY></TABLE><BR><B>4000066h 
- Not used</B><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="soundchannel2tone"></A><FONT size="+2">&nbsp;Sound Channel 2 
      - Tone</FONT></TD></TR></TBODY></TABLE><BR>This sound channel works exactly as 
channel 1, except that it doesn't have a Tone Envelope/Sweep 
Register.<BR><BR><B>4000068h - SOUND2CNT_L (NR21, NR22) - Channel 2 
Duty/Length/Envelope (R/W)</B><BR><B>400006Ah - Not used</B><BR><B>400006Ch - 
SOUND2CNT_H (NR23, NR24) - Channel 2 Frequency/Control (R/W)</B><BR><B>400006Eh 
- Not used</B><BR>For details, refer to channel 1 description.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="soundchannel3waveoutput"></A><FONT size="+2">&nbsp;Sound 
      Channel 3 - Wave Output</FONT></TD></TR></TBODY></TABLE><BR>This channel can be 
used to output digital sound, the length of the sample buffer (Wave RAM) can be 
either 32 or 64 digits (4bit samples). This sound channel can be also used to 
output normal tones when initializing the Wave RAM by a square wave. This 
channel doesn't have a volume envelope register.<BR><BR><B>4000070h - 
SOUND3CNT_L (NR30) - Channel 3 Stop/Wave RAM select (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit        Expl.
  0-4   -    Not used
  5     R/W  Wave RAM Dimension   (0=One bank/32 digits, 1=Two banks/64 digits)
  6     R/W  Wave RAM Bank Number (0-1, see below)
  7     R/W  Sound Channel 3 Off  (0=Stop, 1=Playback)
  8-15  -    Not used
</PRE></TD></TR></TBODY></TABLE>The 
currently selected Bank Number (Bit 6) will be played back, while
 reading/writing to/from wave RAM will address the other (not selected) bank. 
When dimension is set to two banks, output will start by replaying the currently 
selected bank.<BR><BR><B>4000072h - SOUND3CNT_H (NR31, NR32) - Channel 3 
Length/Volume (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit        Expl.
  0-7   W    Sound length; units of (256-n)/256s  (0-255)
  8-12  -    Not used.
  13-14 R/W  Sound Volume  (0=Mute/Zero, 1=100%, 2=50%, 3=25%)
  15    R/W  Force Volume  (0=Use above, 1=Force 75% regardless of above)
</PRE></TD></TR></TBODY></TABLE>The 
Length value is used only if Bit 6 in NR34 is set.<BR><BR><B>4000074h - 
SOUND3CNT_X (NR33, NR34) - Channel 3 Frequency/Control (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit        Expl.
  0-10  W    Sample Rate; 2097152/(2048-n) Hz   (0-2047)
  11-13 -    Not used
  14    R/W  Length Flag  (1=Stop output when length in NR31 expires)
  15    W    Initial      (1=Restart Sound)
</PRE></TD></TR></TBODY></TABLE>The 
above sample rate specifies the number of wave RAM digits per second, the actual 
tone frequency depends on the wave RAM content, for example:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Wave RAM, single bank 32 digits   Tone Frequency
  FFFFFFFFFFFFFFFF0000000000000000  65536/(2048-n) Hz
  FFFFFFFF00000000FFFFFFFF00000000  131072/(2048-n) Hz
  FFFF0000FFFF0000FFFF0000FFFF0000  262144/(2048-n) Hz
  FF00FF00FF00FF00FF00FF00FF00FF00  524288/(2048-n) Hz
  F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0  1048576/(2048-n) Hz
</PRE></TD></TR></TBODY></TABLE><BR><B>4000076h 
- Not used</B><BR><BR><B>4000090h - WAVE_RAM0_L - Channel 3 Wave Pattern RAM 
(W/R)</B><BR><B>4000092h - WAVE_RAM0_H - Channel 3 Wave Pattern RAM 
(W/R)</B><BR><B>4000094h - WAVE_RAM1_L - Channel 3 Wave Pattern RAM 
(W/R)</B><BR><B>4000096h - WAVE_RAM1_H - Channel 3 Wave Pattern RAM 
(W/R)</B><BR><B>4000098h - WAVE_RAM2_L - Channel 3 Wave Pattern RAM 
(W/R)</B><BR><B>400009Ah - WAVE_RAM2_H - Channel 3 Wave Pattern RAM 
(W/R)</B><BR><B>400009Ch - WAVE_RAM3_L - Channel 3 Wave Pattern RAM 
(W/R)</B><BR><B>400009Eh - WAVE_RAM3_H - Channel 3 Wave Pattern RAM 
(W/R)</B><BR>This area contains 16 bytes (32 x 4bits) Wave Pattern data which is
 output by channel 3. Data is played back ordered as follows: MSBs of 1st byte, 
followed by LSBs of 1st byte, followed by MSBs of 2nd byte, and so on - this 
results in a confusing ordering when filling Wave RAM in units of 16bit data - 
ie. samples would be then located in Bits 4-7, 0-3, 12-15, 8-11.<BR><BR>In the 
GBA, two Wave Patterns exists (each 32 x 4bits), either one may be played (as 
selected in NR30 register), the other bank may be accessed by the users. After 
all 32 samples have been played, output of the same bank (or other bank, as 
specified in NR30) will be automatically restarted.<BR><BR>Internally, Wave RAM 
is a giant shift-register, there is no pointer which is addressing the currently 
played digit. Instead, the entire 128 bits are shifted, and the 4 least 
significant bits are output.<BR>Thus, when reading from Wave RAM, data might 
have changed its position. And, when writing to Wave RAM all data should be 
updated (it'd be no good idea to assume that old data is still located at the 
same position where it has been written to previously).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="soundchannel4noise"></A><FONT size="+2">&nbsp;Sound Channel 4 
      - Noise</FONT></TD></TR></TBODY></TABLE><BR>This channel is used to output white 
noise. This is done by randomly switching the amplitude between high and low at 
a given frequency. Depending on the frequency the noise will appear 'harder' or 
'softer'.<BR><BR>It is also possible to influence the function of the random 
generator, so the that the output becomes more regular, resulting in a limited
 ability to output Tone instead of Noise.<BR><BR><B>4000078h - SOUND4CNT_L 
(NR41, NR42) - Channel 4 Length/Envelope (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit        Expl.
  0-5   W    Sound length; units of (64-n)/256s  (0-63)
  6-7   -    Not used
  8-10  R/W  Envelope Step-Time; units of n/64s  (1-7, 0=No Envelope)
  11    R/W  Envelope Direction                  (0=Decrease, 1=Increase)
  12-15 R/W  Initial Volume of envelope          (1-15, 0=No Sound)
</PRE></TD></TR></TBODY></TABLE>The 
Length value is used only if Bit 6 in NR44 is set.<BR><BR><B>400007Ah - Not 
used</B><BR><BR><B>400007Ch - SOUND4CNT_H (NR43, NR44) - Channel 4 
Frequency/Control (R/W)</B><BR>The amplitude is randomly switched between high 
and low at the given frequency. A higher frequency will make the noise to appear 
'softer'.<BR>When Bit 3 is set, the output will become more regular, and some
 frequencies will sound more like Tone than Noise.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit        Expl.
  0-2   R/W  Dividing Ratio of Frequencies (r)
  3     R/W  Counter Step/Width (0=15 bits, 1=7 bits)
  4-7   R/W  Shift Clock Frequency (s)
  8-13  -    Not used
  14    R/W  Length Flag  (1=Stop output when length in NR41 expires)
  15    W    Initial      (1=Restart Sound)
</PRE></TD></TR></TBODY></TABLE>Frequency 
= 524288 Hz / r / 2^(s+1)     ;For r=0 assume r=0.5 instead<BR><BR><B>400007Eh - 
Not used</B><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="soundchannelaandbdmasound"></A><FONT size="+2">&nbsp;Sound 
      Channel A and B - DMA Sound</FONT></TD></TR></TBODY></TABLE><BR>The GBA contains 
two DMA sound channels (A and B), each allowing to replay digital sound (signed 
8bit data, ie. -128..+127). Data can be transferred from INTERNAL memory (not 
sure if EXTERNAL memory works also ???) to FIFO by using DMA channel 1 or 2, the 
sample rate is generated by using one of the Timers.<BR><BR><B>40000A0h - 
FIFO_A_L - Sound A FIFO, Data 0 and Data 1 (W)</B><BR><B>40000A2h - FIFO_A_H - 
Sound A FIFO, Data 2 and Data 3 (W)</B><BR>These two registers may receive 32bit 
(4 bytes) of audio data (Data 0-3, Data 0 being located in least significant 
byte which is replayed first).<BR>Internally, the capacity of the FIFO is 8 x 
32bit (32 bytes), allowing to buffer a small amount of samples. As the name says 
(First In First Out), oldest data is replayed first.<BR><BR><B>40000A4h - 
FIFO_B_L - Sound B FIFO, Data 0 and Data 1 (W)</B><BR><B>40000A6h - FIFO_B_H - 
Sound B FIFO, Data 2 and Data 3 (W)</B><BR>Same as above, for Sound 
B.<BR><BR><B>Initializing DMA-Sound Playback</B><BR>- Select Timer 0 or 1 in 
SOUNDCNT_H control register.<BR>- Clear the FIFO.<BR>- Manually write a sample 
byte to the FIFO.<BR>- Initialize transfer mode for DMA 1 or 2.<BR>- Initialize 
DMA Sound settings in sound control register.<BR>- Start the 
timer.<BR><BR><B>DMA-Sound Playback Procedure</B><BR>The pseudo-procedure below 
is automatically repeated.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  If Timer overflows then
    Move 8bit data from FIFO to sound circuit.
    If FIFO contains only 4 x 32bits (16 bytes) then
      Request more data per DMA
      Receive 4 x 32bit (16 bytes) per DMA
    Endif
  Endif
</PRE></TD></TR></TBODY></TABLE>This 
playback mechanism will be repeated forever, regardless of the actual length of 
the sample buffer.<BR><BR><B>Synchronizing Sample Buffers</B><BR>The buffer-end 
may be determined by counting sound Timer IRQs (each sample byte), or sound DMA 
IRQs (each 16th sample byte). Both methods would require a lot of CPU time (IRQ 
processing), and both would fail if interrupts are disabled for a longer 
period.<BR>Better solutions would be to synchronize the sample rate/buffer 
length with V-blanks, or to use a second timer (in count up/slave mode) which
 produces an IRQ after the desired number of samples.<BR><BR><B>The Sample 
Rate</B><BR>The GBA hardware does internally re-sample all sound output to 
32.768kHz (default SOUNDBIAS setting). It'd thus do not make much sense to use
 higher DMA/Timer rates. Best re-sampling accuracy can be gained by using
 DMA/Timer rates of 32.768kHz, 16.384kHz, or 8.192kHz (ie. fragments of the 
physical output rate).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="soundcontrolregisters"></A><FONT size="+2">&nbsp;Sound 
      Control Registers</FONT></TD></TR></TBODY></TABLE><BR><B>4000080h - SOUNDCNT_L 
(NR50, NR51) - Channel L/R Volume/Enable (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-2   Sound 1-4 Master volume RIGHT (0-7)
  3     Not used
  4-6   Sound 1-4 Master Volume LEFT (0-7)
  7     Not used
  8-11  Sound 1-4 Enable Flags RIGHT (each Bit 8-11, 0=Disable, 1=Enable)
  12-15 Sound 1-4 Enable Flags LEFT (each Bit 12-15, 0=Disable, 1=Enable)
</PRE></TD></TR></TBODY></TABLE><BR><B>4000082h 
- SOUNDCNT_H (GBA only) - DMA Sound Control/Mixing (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-1   Sound # 1-4 Volume   (0=25%, 1=50%, 2=100%, 3=Prohibited)
  2     DMA Sound A Volume   (0=50%, 1=100%)
  3     DMA Sound B Volume   (0=50%, 1=100%)
  4-7   Not used
  8     DMA Sound A Enable RIGHT (0=Disable, 1=Enable)
  9     DMA Sound A Enable LEFT  (0=Disable, 1=Enable)
  10    DMA Sound A Timer Select (0=Timer 0, 1=Timer 1)
  11    DMA Sound A Reset FIFO   (1=Reset)
  12    DMA Sound B Enable RIGHT (0=Disable, 1=Enable)
  13    DMA Sound B Enable LEFT  (0=Disable, 1=Enable)
  14    DMA Sound B Timer Select (0=Timer 0, 1=Timer 1)
  15    DMA Sound B Reset FIFO   (1=Reset)
</PRE></TD></TR></TBODY></TABLE><BR><B>4000084h 
- SOUNDCNT_X (NR52) - Sound on/off (R/W)</B><BR>When not using sound output, 
write 00h to this register to save power consumption. While Bit 7 is cleared, 
all other sound registers cannot be accessed, and their content must be 
re-initialized when re-enabling sound.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Sound 1 ON flag (Read Only)
  1     Sound 2 ON flag (Read Only)
  2     Sound 3 ON flag (Read Only)
  3     Sound 4 ON flag (Read Only)
  4-6   Not used
  7     All sound on/off  (0: stop all sound circuits) (Read/Write)
  8-15  Not used
</PRE></TD></TR></TBODY></TABLE>Bits 
0-3 are automatically set when starting sound output, and are automatically 
cleared when a sound ends. (Ie. when the length expires, as far as length is 
enabled. The bits are NOT reset when an volume envelope 
ends.)<BR><BR><B>4000086h - Not used</B><BR><BR><B>4000088h - SOUNDBIAS - Sound 
PWM Control (R/W, see below)</B><BR>This register controls the final sound 
output. The default setting is 0200h, it is normally not required to change this 
value.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  0-9    Bias Level     (Default=200h, converting signed samples into unsigned)
  10-13  Not used
  14-15  Amplitude Resolution/Sampling Cycle (Default=0, see below)
</PRE></TD></TR></TBODY></TABLE>Amplitude 
Resolution/Sampling Cycle (0-3):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0  9bit / 32.768kHz   (Default, best for DMA channels A,B)
  1  8bit / 65.536kHz
  2  7bit / 131.072kHz
  3  6bit / 262.144kHz  (Best for FM channels 1-4)
</PRE></TD></TR></TBODY></TABLE>For 
more information on this register, read the descriptions 
below.<BR><BR><B>400008Ah - Not used</B><BR><B>400008Ch - Not 
used</B><BR><B>400008Eh - Not used</B><BR><BR><B>Mixing of the separate channels 
into 10bit</B><BR>The current output levels of all six channels are added 
together by hardware, resulting in a signed value, typically in range 
-512..+511. The bias level (typically 200h = 512 decimal) is added to the result 
to convert it into an unsigned 10bit value, range 0..+1023. Values smaller than 
0 or greater than 1023 appear to be clipped.<BR><BR><B>Resampling to 32.768kHz / 
9bit (default)</B><BR>The FM channels 1-4 are internally generated at 
262.144kHz, and DMA sound A-B could be theoretically generated at timer rates up 
to 16.78MHz. However, the final sound output is resampled to a rate of
 32.768kHz, at 9bit depth (the above 10bit value, divided by two). If necessary, 
rates higher than 32.768kHz can be selected in the SOUNDBIAS register, that 
would result in a depth smaller than 9bit though.<BR><BR><B>PWM (Pulse Width 
Modulation) Output 16.78MHz / 1bit</B><BR>Okay, now comes the actual output. The 
GBA can output only two voltages (low and high), these 'bits' are output at 
system clock speed (16.78MHz). If using the default 32.768kHz sampling rate, 
then 512 bits are output per sample (512*32K=16M). Each sample value (9bit 
range, N=0..511), would be then output as N low bits, followed by 512-N high
 bits. The resulting 'noise' is smoothed down by capacitors, by the speaker, and 
by human hearing, so that it will effectively sound like clean D/A converted 
9bit voltages at 32kHz sampling rate.<BR><BR><B>Changing the BIAS Level</B><BR>
Normally use 200h for clean sound output. A value of 000h might make sense 
during periods when no sound is output (causing the PWM circuit to output 
low-bits only, which is eventually reducing the power consumption, and/or 
preventing 32KHz noise). Note: Using the SoundBias function (SWI 19h) allows to 
change the level by slowly incrementing or decrementing it (without hard scratch 
noise).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="comparisonofcgbandgbasound"></A><FONT 
      size="+2">&nbsp;Comparison of CGB and GBA 
Sound</FONT></TD></TR></TBODY></TABLE><BR>The GBA sound controller is mostly the 
same than that of older monochrome gameboy and CGB. The following changes have 
been done:<BR><BR><B>New Sound Channels</B><BR>Two new sound channels have been 
added that may be used to replay 8bit digital sound. Sample rate and sample data 
must be supplied by using a Timer and a DMA channel.<BR><BR><B>New Control 
Registers</B><BR>The SOUNDCNT_H register controls the new DMA channels - as well 
as mixing with the four old channels. The SOUNDBIAS register controls the final 
sound output.<BR><BR><B>Sound Channel 3 Changes</B><BR>The length of the Wave 
RAM is doubled by dividing it into two banks of 32 digits each, either one or 
both banks may be replayed (one after each other), for details check NR30 Bit 
5-6. Optionally, the sound may be output at 75% volume, for details check NR32 
Bit 7.<BR><BR><B>Changed Control Registers</B><BR>NR50 is not supporting Vin 
signals (that's been an external sound input from cartridge).<BR><BR><B>Changed 
I/O Addresses</B><BR>The GBAs sound register are located at 04000060-040000AE 
instead of at FF10-FF3F as in CGB and monochrome gameboy. However, note that 
there have been new blank spaces inserted between some of the separate registers 
- therefore it is NOT possible to port CGB software to GBA just by changing the 
sound base address.<BR><BR><B>Accessing I/O Registers</B><BR>In some cases two 
of the old 8bit registers are packed into a 16bit register and may be accessed 
as such.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="timers"></A><FONT 
size="+2">&nbsp;Timers</FONT></TD></TR></TBODY></TABLE><BR>The GBA includes four 
incrementing 16bit timers.<BR>Timer 0 and 1 can be used to supply the sample 
rate for DMA sound channel A and/or B.<BR><BR><B>4000100h - TM0CNT_L - Timer 0 
Counter/Reload (R/W)</B><BR><B>4000104h - TM1CNT_L - Timer 1 Counter/Reload 
(R/W)</B><BR><B>4000108h - TM2CNT_L - Timer 2 Counter/Reload 
(R/W)</B><BR><B>400010Ch - TM3CNT_L - Timer 3 Counter/Reload (R/W)</B><BR>
Writing to these registers initializes the &lt;reload&gt; value (but does not
 directly affect the current counter value). Reading returns the current
&lt; counter&gt; value (or the recent/frozen counter value if the timer has been 
stopped).<BR>The reload value is copied into the counter only upon following two
 situations: Automatically upon timer overflows, or when the timer start bit 
becomes changed from 0 to 1.<BR>Note: When simultaneously changing the start bit 
from 0 to 1, and setting the reload value at the same time (by a single 32bit 
I/O operation), then the newly written reload value is recognized as new counter 
value.<BR><BR><B>4000102h - TM0CNT_H - Timer 0 Control (R/W)</B><BR><B>4000106h 
- TM1CNT_H - Timer 1 Control (R/W)</B><BR><B>400010Ah - TM2CNT_H - Timer 2 
Control (R/W)</B><BR><B>400010Eh - TM3CNT_H - Timer 3 Control (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-1   Prescaler Selection (0=F/1, 1=F/64, 2=F/256, 3=F/1024)
  2     Count-up Timing   (0=Normal, 1=See below)
  3-5   Not used
  6     Timer IRQ Enable  (0=Disable, 1=IRQ on Timer overflow)
  7     Timer Start/Stop  (0=Stop, 1=Operate)
  8-15  Not used
</PRE></TD></TR></TBODY></TABLE>When 
Count-up Timing is enabled, the prescaler value is ignored, instead the time is 
incremented each time when the previous counter overflows. This function cannot 
be used for Timer 0 (as it is the first timer).<BR>F = System Clock 
(16.78MHz).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dmatransfers"></A><FONT size="+2">&nbsp;DMA 
    Transfers</FONT></TD></TR></TBODY></TABLE><BR><B>Overview</B><BR>The GBA 
includes four DMA channels, the highest priority is assigned to DMA0, followed 
by DMA1, DMA2, and DMA3. DMA Channels with lower priority are paused until 
channels with higher priority have completed.<BR>The CPU is paused when DMA 
transfers are active, however, the CPU is operating during the periods when 
Sound/Blanking DMA transfers are paused.<BR><BR><B>Special features of the 
separate DMA channels</B><BR>DMA0 - highest priority, best for timing critical 
transfers (eg. HBlank DMA).<BR>DMA1 and DMA2 - can be used to feed digital 
sample data to the Sound FIFOs.<BR>DMA3 - can be used to write to Game Pak 
ROM/FlashROM (but not GamePak SRAM).<BR>Beside for that, each DMA 0-3 may be 
used for whatever general purposes.<BR><BR><B>40000B0h,0B2h - DMA0SAD - DMA 0 
Source Address (W) (internal memory)</B><BR><B>40000BCh,0BEh - DMA1SAD - DMA 1 
Source Address (W) (any memory)</B><BR><B>40000C8h,0CAh - DMA2SAD - DMA 2 Source 
Address (W) (any memory)</B><BR><B>40000D4h,0D6h - DMA3SAD - DMA 3 Source 
Address (W) (any memory)</B><BR>The most significant address bits are ignored, 
only the least significant 27 or 28 bits are used (max 07FFFFFFh internal 
memory, or max 0FFFFFFFh any memory - except SRAM ???!).<BR><BR><B>40000B4h,0B6h 
- DMA0DAD - DMA 0 Destination Address (W) (internal 
memory)</B><BR><B>40000C0h,0C2h - DMA1DAD - DMA 1 Destination Address (W) 
(internal memory)</B><BR><B>40000CCh,0CEh - DMA2DAD - DMA 2 Destination Address 
(W) (internal memory)</B><BR><B>40000D8h,0DAh - DMA3DAD - DMA 3 Destination 
Address (W) (any memory)</B><BR>The most significant address bits are ignored, 
only the least significant 27 or 28 bits are used (max. 07FFFFFFh internal 
memory or 0FFFFFFFh any memory - except SRAM ???!).<BR><BR><B>40000B8h - 
DMA0CNT_L - DMA 0 Word Count (W) (14 bit, 1..4000h)</B><BR><B>40000C4h - 
DMA1CNT_L - DMA 1 Word Count (W) (14 bit, 1..4000h)</B><BR><B>40000D0h - 
DMA2CNT_L - DMA 2 Word Count (W) (14 bit, 1..4000h)</B><BR><B>40000DCh - 
DMA3CNT_L - DMA 3 Word Count (W) (16 bit, 1..10000h)</B><BR>Specifies the number 
of data units to be transferred, each unit is 16bit or 32bit depending on the 
transfer type, a value of zero is treated as max length (ie. 4000h, or 10000h 
for DMA3).<BR><BR><B>40000BAh - DMA0CNT_H - DMA 0 Control 
(R/W)</B><BR><B>40000C6h - DMA1CNT_H - DMA 1 Control (R/W)</B><BR><B>40000D2h - 
DMA2CNT_H - DMA 2 Control (R/W)</B><BR><B>40000DEh - DMA3CNT_H - DMA 3 Control 
(R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-4   Not used
  5-6   Dest Addr Control  (0=Increment,1=Decrement,2=Fixed,3=Increment/Reload)
  7-8   Source Adr Control (0=Increment,1=Decrement,2=Fixed,3=Prohibited)
  9     DMA Repeat                   (0=Off, 1=On) (Must be zero if Bit 11 set)
  10    DMA Transfer Type            (0=16bit, 1=32bit)
  11    Game Pak DRQ  - DMA3 only -  (0=Normal, 1=DRQ &lt;from&gt; Game Pak, DMA3)
  12-13 DMA Start Timing  (0=Immediately, 1=VBlank, 2=HBlank, 3=Special)
          The 'Special' setting (Start Timing=3) depends on the DMA channel:
          DMA0=Prohibited, DMA1/DMA2=Sound FIFO, DMA3=Video Capture
  14    IRQ upon end of Word Count   (0=Disable, 1=Enable)
  15    DMA Enable                   (0=Off, 1=On)
</PRE></TD></TR></TBODY></TABLE>After 
changing the Enable bit from 0 to 1, wait 2 clock cycles before accessing any 
DMA related registers.<BR><BR>When accessing OAM (7000000h) or OBJ VRAM 
(6010000h) by HBlank Timing, then the "H-Blank Interval Free" bit in DISPCNT 
register must be set.<BR><BR><B>Source and Destination Address and Word Count 
Registers</B><BR>The SAD, DAD, and CNT_L registers are holding the initial start
 addresses, and initial length. The hardware does NOT change the content of 
these registers during or after the transfer.<BR>The actual transfer takes place 
by using internal pointer/counter registers. The initial values are copied into 
internal regs under the following circumstances:<BR>Upon DMA Enable (Bit 15) 
changing from 0 to 1: Reloads SAD, DAD, CNT_L.<BR>Upon Repeat: Reloads CNT_L, 
and optionally DAD (Increment+Reload).<BR><BR><B>DMA Repeat bit</B><BR>If the 
Repeat bit is cleared: The Enable bit is automatically cleared after the 
specified number of data units has been transferred.<BR>If the Repeat bit is 
set: The Enable bit remains set after the transfer, and the transfer will be 
restarted each time when the Start condition (eg. HBlank, Fifo) becomes true. 
The specified number of data units is transferred &lt;each&gt; time when the 
transfer is (re-)started. The transfer will be repeated forever, until it gets 
stopped by software.<BR><BR><B>Sound DMA (FIFO Timing Mode) (DMA1 and DMA2 
only)</B><BR>In this mode, the DMA Repeat bit must be set, and the destination
 address must be FIFO_A (040000A0h) or FIFO_B (040000A4h).<BR>Upon DMA request 
from sound controller, 4 units of 32bits (16 bytes) are transferred (both Word 
Count register and DMA Transfer Type bit are ignored). The destination address 
will not be incremented in FIFO mode.<BR>Keep in mind that DMA channels of 
higher priority may offhold sound DMA. For example, when using a 64 kHz sample 
rate, 16 bytes of sound DMA data are requested each 0.25ms (4 kHz), at this time 
another 16 bytes are still in the FIFO so that there's still 0.25ms time to 
satisfy the DMA request. Thus DMAs with higher priority should not be operated 
for longer than 0.25ms. (This problem does not arise for HBlank transfers as
 HBlank time is limited to 16.212us.)<BR><BR><B>Game Pak DMA</B><BR>Only DMA 4 
may be used to transfer data to/from Game Pak ROM or Flash ROM - it cannot 
access Game Pak SRAM though (as SRAM data bus is limited to 8bit units). In 
normal mode, DMA is requested as long until Word Count becomes zero. When 
setting the 'Game Pack DRQ' bit, then the cartridge must contain an external 
circuit which outputs a /DREQ signal. Note that there is only one pin for /DREQ 
and /IREQ, thus the cartridge may not supply /IREQs while using DRQ 
mode.<BR><BR><B>Video Capture Mode (DMA3 only)</B><BR>Intended to copy a bitmap 
from memory (or from external hardware/camera) to VRAM. When using this transfer 
mode, set the repeat bit, and write the number of data units (per scanline) to 
the word count register. Capture works similar like HBlank DMA, however, the 
transfer is started when VCOUNT=2, it is then repeated each scanline, and it 
gets stopped when VCOUNT=162.<BR><BR><B>Transfer End</B><BR>The DMA Enable flag 
(Bit 15) is automatically cleared upon completion of the transfer. The user may 
also clear this bit manually in order to stop the transfer (obviously this is 
possible for Sound/Blanking DMAs only, in all other cases the CPU is stopped 
until the transfer completes by itself).<BR><BR><B>Transfer Rate/Timing</B><BR>
Except for the first data unit, all units are transferred by sequential reads 
and writes. For n data units, the DMA transfer time is:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  2N+2(n-1)S+xI
</PRE></TD></TR></TBODY></TABLE>Of which, 1N+(n-1)S are 
read cycles, and the other 1N+(n-1)S are write cycles, actual number of cycles 
depends on the waitstates and bus-width of the source and destination areas (as 
described in CPU Instruction Cycle Times chapter). Internal time for DMA 
processing is 2I (normally), or 4I (if both source and destination are in 
gamepak memory area).<BR><BR>DMA lockup when stopping while starting ???<BR>
Capture delayed, Capture Enable=AutoCleared ???<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="communicationports"></A><FONT size="+2">&nbsp;Communication 
      Ports</FONT></TD></TR></TBODY></TABLE><BR>The GBAs Serial Port may be used in 
various different communication modes. Normal mode may exchange data between two 
GBAs (or to transfer data from master GBA to several slave GBAs in one-way 
direction).<BR>Multi-player mode may exchange data between up to four GBAs. UART 
mode works much like a RS232 interface. JOY Bus mode uses a standardized 
Nintendo protocol. And General Purpose mode allows to mis-use the 'serial' port 
as bi-directional 4bit parallel port.<BR>Note: The Nintendo DS does not include 
a Serial Port.<BR><BR><A href="#sionormalmode">SIO 
Normal Mode</A><BR><A href="#siomultiplayermode">SIO 
Multi-Player Mode</A><BR><A href="#siouartmode">SIO 
UART Mode</A><BR><A href="#siojoybusmode">SIO 
JOY BUS Mode</A><BR><A href="#siogeneralpurposemode">SIO 
General-Purpose Mode</A><BR><A href="#siocontrolregisterssummary">SIO 
Control Registers Summary</A><BR><BR><B>Infrared Communication Adapters</B><BR>
Even though early GBA prototypes have been intended to support IR communication, 
this feature has been removed.<BR>However, Nintendo is apparently considering to 
provide an external IR adapter (to be connected to the SIO connector, being 
accessed in General Purpose mode).<BR>Also, it'd be theoretically possible to 
include IR ports built-in in game cartridges (as done for some older 
8bit/monochrome Hudson games).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="sionormalmode"></A><FONT size="+2">&nbsp;SIO Normal 
      Mode</FONT></TD></TR></TBODY></TABLE><BR>This mode is used to communicate 
between two units.<BR>Transfer rates of 256KBit/s or 2MBit/s can be selected, 
however, the fast 2MBit/s is intended ONLY for special hardware expansions that 
are DIRECTLY connected to the GBA link port (ie. without a cable being located 
between the GBA and expansion hardware). In normal cases, always use 256KBit/s 
transfer rate which provides stable results.<BR>Transfer lengths of 8bit or 
32bit may be used, the 8bit mode is the same as for older DMG/CGB gameboys, 
however, the voltages for "GBA cartridges in GBAs" are different as for "DMG/CGB 
cartridges in DMG/CGB/GBAs", ie. it is not possible to communicate between 
DMG/CGB games and GBA games.<BR><BR><B>4000134h - RCNT (R) - Mode Selection, in 
Normal/Multiplayer/UART modes (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-3   Undocumented (current SC,SD,SI,SO state, as for General Purpose mode)
  4-8   Not used     (Should be 0, bits are read/write-able though)
  9-13  Not used     (Always 0, read only)
  14    Not used     (Should be 0, bit is read/write-able though)
  15    Must be zero (0) for Normal/Multiplayer/UART modes
</PRE></TD></TR></TBODY></TABLE><BR><B>4000128h 
- SIOCNT - SIO Control, usage in NORMAL Mode (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Shift Clock (SC)        (0=External, 1=Internal)
  1     Internal Shift Clock    (0=256KHz, 1=2MHz)
  2     SI State (opponents SO) (0=Low, 1=High/None) --- (Read Only)
  3     SO during inactivity    (0=Low, 1=High) (applied ONLY when Bit7=0)
  4-6   Not used                (Read only, always 0 ???)
  7     Start Bit               (0=Inactive/Ready, 1=Start/Active)
  8-11  Not used                (R/W, should be 0)
  12    Transfer Length         (0=8bit, 1=32bit)
  13    Must be "0" for Normal Mode
  14    IRQ Enable              (0=Disable, 1=Want IRQ upon completion)
  15    Not used                (Read only, always 0)
</PRE></TD></TR></TBODY></TABLE>The 
Start bit is automatically reset when the transfer completes, ie. when all 8 or 
32 bits are transferred, at that time an IRQ may be
 generated.<BR><BR><B>400012Ah - SIODATA8 - SIO Normal Communication 8bit Data 
(R/W)</B><BR>For 8bit normal mode. Contains 8bit data (only lower 8bit are 
used). Outgoing data should be written to this register before starting the
 transfer. During transfer, transmitted bits are shifted-out (MSB first), and 
received bits are shifted-in simultaneously. Upon transfer completion, the 
register contains the received 8bit value.<BR><BR><B>4000120h - SIODATA32_L - 
SIO Normal Communication lower 16bit data (R/W)</B><BR><B>4000122h - SIODATA32_H 
- SIO Normal Communication upper 16bit data (R/W)</B><BR>Same as above SIODATA8, 
for 32bit normal transfer mode respectively.<BR>SIOCNT/RCNT must be set to 32bit 
normal mode &lt;before&gt; writing to 
SIODATA32.<BR><BR><B>Initialization</B><BR>First, initialize RCNT register. 
Second, set mode/clock bits in SIOCNT with startbit cleared. For master: select 
internal clock, and (in most cases) specify 256KHz as transfer rate. For slave: 
select external clock, the local transfer rate selection is then ignored, as the
 transfer rate is supplied by the remote GBA (or other computer, which might 
supply custom transfer rates).<BR>Third, set the startbit in SIOCNT with 
mode/clock bits unchanged.<BR><BR><B>Recommended Communication Procedure for 
SLAVE unit (external clock)</B><BR>- Initialize data which is to be sent to 
master.<BR>- Set Start flag.<BR>- Set SO to LOW to indicate that master may 
start now.<BR>- Wait for IRQ (or for Start bit to become zero). (Check timeout 
here!)<BR>- Set SO to HIGH to indicate that we are not ready.<BR>- Process 
received data.<BR>- Repeat procedure if more data is to be transferred.<BR>(or 
is so=high done automatically ??? would be fine - more stable - otherwise master 
may still need delay)<BR><BR><B>Recommended Communication Procedure for SLAVE 
unit (external clock)</B><BR>- Initialize data which is to be sent to 
master.<BR>- Set Start=0 and SO=0 (SO=LOW indicates that slave is (almost) 
ready).<BR>- Set Start=1 and SO=1 (SO=HIGH indicates not ready, applied after 
transfer).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  (Expl. Old SO=LOW kept output until 1st clock bit received).
  (Expl. New SO=HIGH is automatically output at transfer completion).
</PRE></TD></TR></TBODY></TABLE>- 
Set SO to LOW to indicate that master may start now.<BR>- Wait for IRQ (or for 
Start bit to become zero). (Check timeout here!)<BR>- Process received data.<BR>
- Repeat procedure if more data is to be transferred.<BR><BR><B>Recommended 
Communication Procedure for MASTER unit (internal clock)</B><BR>- Initialize 
data which is to be sent to slave.<BR>- Wait for SI to become LOW (slave ready). 
(Check timeout here!)<BR>- Set Start flag.<BR>- Wait for IRQ (or for Start bit 
to become zero).<BR>- Process received data.<BR>- Repeat procedure if more data 
is to be transferred.<BR><BR><B>Cable Protocol</B><BR>During inactive transfer, 
the shift clock (SC) is high. The transmit (SO) and receive (SI) data lines may 
be manually controlled as described above.<BR>When master sends SC=LOW, each 
master and slave must output the next outgoing data bit to SO. When master sends 
SC=HIGH, each master and slave must read out the opponents data bit from SI. 
This is repeated for each of the 8 or 32 bits, and when completed SC will be 
kept high again.<BR><BR><B>Transfer Rates</B><BR>Either 256KHz or 2MHz rates can 
be selected for SC, so max 32KBytes (256KBit) or 128KBytes (2MBit) can be 
transferred per second. However, the software must process each 8bit or 32bit of 
transmitted data separately, so the actual transfer rate will be reduced by the 
time spent on handling each data unit.<BR>Only 256KHz provides stable results in 
most cases (such like when linking between two GBAs). The 2MHz rate is intended 
for special expansion hardware only.<BR><BR><B>Using Normal mode for One-Way 
Multiplayer communication</B><BR>When using normal mode with multiplay-cables, 
data isn't exchanged between first and second GBA as usually. Instead, data is 
shifted from first to last GBA (the first GBA receives zero, because master SI 
is shortcut to GND).<BR>This behaviour may be used for fast ONE-WAY data 
transfer from master to all other GBAs. For example (3 GBAs linked):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Step         Sender      1st Recipient   2nd Recipient
  Transfer 1:  DATA #0 --&gt; UNDEF      --&gt;  UNDEF     --&gt;
  Transfer 2:  DATA #1 --&gt; DATA #0    --&gt;  UNDEF     --&gt;
  Transfer 3:  DATA #2 --&gt; DATA #1    --&gt;  DATA #0   --&gt;
  Transfer 4:  DATA #3 --&gt; DATA #2    --&gt;  DATA #1   --&gt;
</PRE></TD></TR></TBODY></TABLE>The 
recipients should not output any own data, instead they should forward the 
previously received data to the next recipient during next transfer (just keep 
the incoming data unmodified in the data register).<BR>Due to the delayed 
forwarding, 2nd recipient should ignore the first incoming data. After the last 
transfer, the sender must send one (or more) dummy data unit(s), so that the 
last data is forwarded to the 2nd (or further) recipient(s).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="siomultiplayermode"></A><FONT size="+2">&nbsp;SIO 
      Multi-Player Mode</FONT></TD></TR></TBODY></TABLE><BR>Multi-Player mode can be 
used to communicate between up to 4 units.<BR><BR><B>4000134h - RCNT (R) - Mode 
Selection, in Normal/Multiplayer/UART modes (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-3   Undocumented (current SC,SD,SI,SO state, as for General Purpose mode)
  4-8   Not used     (Should be 0, bits are read/write-able though)
  9-13  Not used     (Always 0, read only)
  14    Not used     (Should be 0, bit is read/write-able though)
  15    Must be zero (0) for Normal/Multiplayer/UART modes
</PRE></TD></TR></TBODY></TABLE>Note: 
Even though undocumented, many Nintendo games are using Bit 0 to test current SC 
state in multiplay mode.<BR><BR><B>4000128h - SIOCNT - SIO Control, usage in 
MULTI-PLAYER Mode (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-1   Baud Rate     (0-3: 9600,38400,57600,115200 bps)
  2     SI-Terminal   (0=Parent, 1=Child)                  (Read Only)
  3     SD-Terminal   (0=Bad connection, 1=All GBAs Ready) (Read Only)
  4-5   Multi-Player ID     (0=Parent, 1-3=1st-3rd child)  (Read Only)
  6     Multi-Player Error  (0=Normal, 1=Error)            (Read Only)
  7     Start/Busy Bit      (0=Inactive, 1=Start/Busy) (Read Only for Slaves)
  8-11  Not used            (R/W, should be 0)
  12    Must be "0" for Multi-Player mode
  13    Must be "1" for Multi-Player mode
  14    IRQ Enable          (0=Disable, 1=Want IRQ upon completion)
  15    Not used            (Read only, always 0)
</PRE></TD></TR></TBODY></TABLE>The 
ID Bits are undefined until the first transfer has completed.<BR><BR><B>400012Ah 
- SIOMLT_SEND - Data Send Register (R/W)</B><BR>Outgoing data (16 bit) which is 
to be sent to the other GBAs.<BR><BR><B>4000120h - SIOMULTI0 - SIO Multi-Player 
Data 0 (Parent) (R/W)</B><BR><B>4000122h - SIOMULTI1 - SIO Multi-Player Data 1 
(1st child) (R/W)</B><BR><B>4000124h - SIOMULTI2 - SIO Multi-Player Data 2 (2nd 
child) (R/W)</B><BR><B>4000126h - SIOMULTI3 - SIO Multi-Player Data 3 (3rd 
child) (R/W)</B><BR>These registers are automatically reset to FFFFh upon 
transfer start.<BR>After transfer, these registers contain incoming data (16bit 
each) from all remote GBAs (if any / otherwise still FFFFh), as well as the 
local outgoing SIOMLT_SEND data.<BR>Ie. after the transfer, all connected GBAs 
will contain the same values in their SIOMULTI0-3 
registers.<BR><BR><B>Initialization</B><BR>- Initialize RCNT Bit 14-15 and 
SIOCNT Bit 12-13 to select Multi-Player mode.<BR>- Read SIOCNT Bit 3 to verify 
that all GBAs are in Multi-Player mode.<BR>- Read SIOCNT Bit 2 to detect whether 
this is the Parent/Master unit.<BR><BR><B>Recommended Transmission 
Procedure</B><BR>- Write outgoing data to SIODATA_SEND.<BR>- Master must set 
Start bit.<BR>- All units must process received data in SIOMULTI0-3 when 
transfer completed.<BR>- After the first successful transfer, ID Bits in SIOCNT 
are valid.<BR>- If more data is to be transferred, repeat procedure.<BR>The 
parent unit blindly sends data regardless of whether childs have already 
processed old data/supplied new data. So, parent unit might be required to 
insert delays between each transfer, and/or perform error checking.<BR>Also, 
slave units may signalize that they are not ready by temporarily switching into 
another communication mode (which does not output SD High, as Multi-Player mode 
does during inactivity).<BR><BR><B>Transfer Protocol</B><BR>Beginning<BR>- The 
masters SI pin is always LOW.<BR>- When all GBAs are in Multiplayer mode (ready) 
SD is HIGH.<BR>- When master starts the transfer, it sets SC=LOW, slaves receive 
Busy bit.<BR>Step A<BR>- ID Bits in master unit are set to 0.<BR>- Master 
outputs Startbit (LOW), 16bit Data, Stopbit (HIGH) through SD.<BR>- This data is 
written to SIOMULTI0 of all GBAs (including master).<BR>- Master forwards LOW 
from its SO to 1st childs SI.<BR>- Transfer ends if next child does not output 
data after certain time.<BR>Step B<BR>- ID Bits in 1st child unit are set to 
1.<BR>- 1st Child outputs Startbit (LOW), 16bit Data, Stopbit (HIGH) through 
SD.<BR>- This data is written to SIOMULTI1 of all GBAs (including 1st 
child).<BR>- 1st child forwards LOW from its SO to 2nd childs SI.<BR>- Transfer 
ends if next child does not output data after certain time.<BR>Step C<BR>- ID 
Bits in 2nd child unit are set to 2.<BR>- 2nd Child outputs Startbit (LOW), 
16bit Data, Stopbit (HIGH) through SD.<BR>- This data is written to SIOMULTI2 of 
all GBAs (including 2nd child).<BR>- 2nd child forwards LOW from its SO to 3rd 
childs SI.<BR>- Transfer ends if next child does not output data after certain 
time.<BR>Step D<BR>- ID Bits in 3rd child unit are set to 3.<BR>- 3rd Child 
outputs Startbit (LOW), 16bit Data, Stopbit (HIGH) through SD.<BR>- This data is 
written to SIOMULTI3 of all GBAs (including 3rd child).<BR>- Transfer ends (this 
was the last child).<BR>Transfer end<BR>- Master sets SC=HIGH, all GBAs set 
SO=HIGH.<BR>- The Start/Busy bits of all GBAs are automatically cleared.<BR>- 
Interrupts are requested in all GBAs (as far as enabled).<BR><BR><B>Error 
Bit</B><BR>This bit is set when a slave did not receive SI=LOW even though 
SC=LOW signalized a transfer (this might happen when connecting more than 4
 GBAs, or when the previous child is not connected). Also, the bit is set when a 
Stopbit wasn't HIGH.<BR>The error bit may be undefined during active transfer - 
read only after transfer completion (the transfer continues and completes as 
normal even if errors have occurred for some or all GBAs).<BR>Don't know: The 
bit is automatically reset/initialized with each transfer, or must be manually 
reset ???<BR><BR><B>Transmission Time</B><BR>The transmission time depends on 
the selected Baud rate. And on the amount of Bits (16 data bits plus start/stop 
bits for each GBA), delays between each GBA, plus final timeout (if less than 4 
GBAs). That is, depending on the number of connected GBAs:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  GBAs    Bits    Delays   Timeout
  1       18      None     Yes
  2       36      1        Yes
  3       54      2        Yes
  4       72      3        None
</PRE></TD></TR></TBODY></TABLE>(The 
average Delay and Timeout periods are unknown ???)<BR>Above is not counting the 
additional CPU time that must be spent on initiating and processing each 
transfer.<BR><BR><B>Fast One-Way Transmission</B><BR>Beside for the actual SIO 
Multiplayer mode, you could also use SIO Normal mode for fast one-way data 
transfer from Master unit to all Child unit(s). See chapter about SIO Normal 
mode for details.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="siouartmode"></A><FONT size="+2">&nbsp;SIO UART 
  Mode</FONT></TD></TR></TBODY></TABLE><BR>This mode works much like a RS232 port, 
however, the voltages are unknown, probably 0/3V rather than +/-12V ???. SI and 
SO are data lines (with crossed wires), SC and SD signalize Clear to Send (with 
crossed wires also, which requires special cable when linking between two GBAs
 ???)<BR><BR><B>4000134h - RCNT (R) - Mode Selection, in Normal/Multiplayer/UART 
modes (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-3   Undocumented (current SC,SD,SI,SO state, as for General Purpose mode)
  4-8   Not used     (Should be 0, bits are read/write-able though)
  9-13  Not used     (Always 0, read only)
  14    Not used     (Should be 0, bit is read/write-able though)
  15    Must be zero (0) for Normal/Multiplayer/UART modes
</PRE></TD></TR></TBODY></TABLE><BR><B>4000128h 
- SCCNT_L - SIO Control, usage in UART Mode (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-1   Baud Rate  (0-3: 9600,38400,57600,115200 bps)
  2     CTS Flag   (0=Send always/blindly, 1=Send only when SC=LOW)
  3     Parity Control (0=Even, 1=Odd)
  4     Send Data Flag      (0=Not Full,  1=Full)    (Read Only)
  5     Receive Data Flag   (0=Not Empty, 1=Empty)   (Read Only)
  6     Error Flag          (0=No Error,  1=Error)   (Read Only)
  7     Data Length         (0=7bits,   1=8bits)
  8     FIFO Enable Flag    (0=Disable, 1=Enable)
  9     Parity Enable Flag  (0=Disable, 1=Enable)
  10    Send Enable Flag    (0=Disable, 1=Enable)
  11    Receive Enable Flag (0=Disable, 1=Enable)
  12    Must be "1" for UART mode
  13    Must be "1" for UART mode
  14    IRQ Enable          (0=Disable, 1=IRQ when any Bit 4/5/6 become set)
  15    Not used            (Read only, always 0)
</PRE></TD></TR></TBODY></TABLE><BR><B>400012Ah 
- SIODATA8 - usage in UART Mode (R/W)</B><BR>Addresses the send/receive shift 
register, or (when FIFO is used) the send/receive FIFO. In either case only the 
lower 8bit of SIODATA8 are used, the upper 8bit are not used.<BR>The 
send/receive FIFO may store up to four 8bit data units each. For example, while 
1 unit is still transferred from the send shift register, it is possible to 
deposit another 4 units in the send FIFO, which are then automatically moved to 
the send shift register one after each other.<BR><BR><B>Send/Receive Enable, CTS 
Feedback</B><BR>The receiver outputs SD=LOW (which is input as SC=LOW at the 
remote side) when it is ready to receive data (that is, when Receive Enable is
 set, and the Receive shift register (or receive FIFO) isn't full.<BR>When CTS 
flag is set to always/blindly, then the sender transmits data immediately when 
Send Enable is set, otherwise data is transmitted only when Send Enable is set 
and SC is LOW.<BR><BR><B>Error Flag</B><BR>The error flag is set when a bad stop 
bit has been received (stop bit must be 0), when a parity error has occurred (if 
enabled), or when new data has been completely received while the receive data 
register (or receive FIFO) is already full.<BR>The error flag is automatically 
reset when reading from SIOCNT register.<BR><BR><B>Init &amp; Initback</B><BR>
The content of the FIFO is reset when FIFO is disabled in UART mode, thus, when 
entering UART mode initially set FIFO=disabled.<BR>The Send/Receive enable bits 
must be reset before switching from UART mode into another SIO mode!<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="siojoybusmode"></A><FONT size="+2">&nbsp;SIO JOY BUS 
      Mode</FONT></TD></TR></TBODY></TABLE><BR>This communication mode uses Nintendo's 
standardized JOY Bus protocol. When using this communication mode, the GBA is 
always operated as SLAVE!<BR><BR>In this mode, SI and SO pins are data lines 
(apparently synchronized by Start/Stop bits ???), SC and SD are set to low 
(including during active transfer ???), the transfer rate is unknown 
???<BR><BR><B>4000134h - RCNT (R) - Mode Selection, in JOY BUS mode 
(R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-3   Undocumented (current SC,SD,SI,SO state, as for General Purpose mode)
  4-8   Not used     (Should be 0, bits are read/write-able though)
  9-13  Not used     (Always 0, read only)
  14    Must be "1" for JOY BUS Mode
  15    Must be "1" for JOY BUS Mode
</PRE></TD></TR></TBODY></TABLE><BR><B>4000128h 
- SIOCNT - SIO Control, not used in JOY BUS Mode</B><BR>This register is not 
used in JOY BUS mode.<BR><BR><B>4000140h - JOYCNT - JOY BUS Control Register 
(R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Device Reset Flag     (Command FFh)          (Read/Acknowledge)
  1     Receive Complete Flag (Command 14h or 15h?)  (Read/Acknowledge)
  2     Send Complete Flag    (Command 15h or 14h?)  (Read/Acknowledge)
  3-5   Not used
  6     IRQ when receiving a Device Reset Command  (0=Disable, 1=Enable)
  7-15  Not used
</PRE></TD></TR></TBODY></TABLE>Bit 
0-2 are working much like the bits in the IF register: Write a "1" bit to reset 
(acknowledge) the respective bit.<BR>UNCLEAR: Interrupts can be requested for 
Send/Receive commands also ???<BR><BR><B>4000150h - JOY_RECV_L - Receive Data 
Register low (R/W)</B><BR><B>4000152h - JOY_RECV_H - Receive Data Register high 
(R/W)</B><BR><B>4000154h - JOY_TRANS_L - Send Data Register low 
(R/W)</B><BR><B>4000156h - JOY_TRANS_H - Send Data Register high (R/W)</B><BR>
Send/receive data registers.<BR><BR><B>4000158h - JOYSTAT - Receive Status 
Register (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Not used
  1     Receive Status Flag   (0=Remote GBA is/was receiving) (Read Only?)
  2     Not used
  3     Send Status Flag      (1=Remote GBA is/was sending)   (Read Only?)
  4-5   General Purpose Flag  (Not assigned, may be used for whatever purpose)
  6-15  Not used
</PRE></TD></TR></TBODY></TABLE>Bit 
1 is automatically set when writing to local JOY_TRANS.<BR>Bit 3 is 
automatically reset when reading from local JOY_RECV.<BR><BR>Below are the four 
possible commands which can be received by the GBA. Note that the GBA (slave) 
cannot send any commands itself, all it can do is to read incoming data, and to 
provide 'reply' data which may (or may not) be read out by the master 
unit.<BR><BR><B>Command FFh - Device Reset</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Receive FFh (Command)
  Send    00h (GBA Type number LSB (or MSB?))
  Send    04h (GBA Type number MSB (or LSB?))
  Send    XXh (lower 8bits of SIOSTAT register)
</PRE></TD></TR></TBODY></TABLE><BR><B>Command 
00h - Type/Status Data Request</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Receive 00h (Command)
  Send    00h (GBA Type number LSB (or MSB?))
  Send    04h (GBA Type number MSB (or LSB?))
  Send    XXh (lower 8bits of SIOSTAT register)
</PRE></TD></TR></TBODY></TABLE><BR><B>Command 
15h - GBA Data Write (to GBA)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Receive 15h (Command)
  Receive XXh (Lower 8bits of JOY_RECV_L)
  Receive XXh (Upper 8bits of JOY_RECV_L)
  Receive XXh (Lower 8bits of JOY_RECV_H)
  Receive XXh (Upper 8bits of JOY_RECV_H)
  Send    XXh (lower 8bits of SIOSTAT register)
</PRE></TD></TR></TBODY></TABLE><BR><B>Command 
14h - GBA Data Read (from GBA)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Receive 14h (Command)
  Send    XXh (Lower 8bits of JOY_TRANS_L)
  Send    XXh (Upper 8bits of JOY_TRANS_L)
  Send    XXh (Lower 8bits of JOY_TRANS_H)
  Send    XXh (Upper 8bits of JOY_TRANS_H)
  Send    XXh (lower 8bits of SIOSTAT register)
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="siogeneralpurposemode"></A><FONT size="+2">&nbsp;SIO 
      General-Purpose Mode</FONT></TD></TR></TBODY></TABLE><BR>In this mode, the SIO 
is 'misused' as a 4bit bi-directional parallel port, each of the SI,SO,SC,SD 
pins may be directly controlled, each can be separately declared as input (with 
internal pull-up) or as output signal.<BR><BR><B>4000134h - RCNT (R) - SIO Mode, 
usage in GENERAL-PURPOSE Mode (R/W)</B><BR>Interrupts can be requested when SI 
changes from HIGH to LOW, as General Purpose mode does not require a serial 
shift clock, this interrupt may be produced even when the GBA is in Stop (low 
power standby) state.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     SC Data Bit         (0=Low, 1=High)
  1     SD Data Bit         (0=Low, 1=High)
  2     SI Data Bit         (0=Low, 1=High)
  3     SO Data Bit         (0=Low, 1=High)
  4     SC Direction        (0=Input, 1=Output)
  5     SD Direction        (0=Input, 1=Output)
  6     SI Direction        (0=Input, 1=Output, but see below)
  7     SO Direction        (0=Input, 1=Output)
  8     SI Interrupt Enable (0=Disable, 1=Enable)
  9-13  Not used
  14    Must be "0" for General-Purpose Mode
  15    Must be "1" for General-Purpose or JOYBUS Mode
</PRE></TD></TR></TBODY></TABLE>SI 
should be always used as Input to avoid problems with other hardware which does 
not expect data to be output there.<BR><BR><B>4000128h - SIOCNT - SIO Control, 
not used in GENERAL-PURPOSE Mode</B><BR>This register is not used in general 
purpose mode. That is, the separate bits of SIOCNT still exist and are read- 
and/or write-able in the same manner as for Normal, Multiplay, or UART mode 
(depending on SIOCNT Bit 12,13), but are having no effect on data being output 
to the link port.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="siocontrolregisterssummary"></A><FONT size="+2">&nbsp;SIO 
      Control Registers Summary</FONT></TD></TR></TBODY></TABLE><BR><B>Mode Selection 
(by RCNT.15-14 and SIOCNT.13-12)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  R.15 R.14 S.13 S.12 Mode
  0    x    0    0    Normal 8bit
  0    x    0    1    Normal 32bit
  0    x    1    0    Multiplay 16bit
  0    x    1    1    UART (RS232)
  1    0    x    x    General Purpose
  1    1    x    x    JOY BUS
</PRE></TD></TR></TBODY></TABLE><BR><B>SIOCNT</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit Normal Multi
         0      1    2     3      4 5 6   7     8    9      10   11
  Normal Master Rate SI/In SO/Out - - -   Start -    -      -    -
  Multi  Baud   Baud SI/In SD/In  ID# Err Start -    -      -    -
  UART   Baud   Baud CTS   Parity S R Err Bits  FIFO Parity Send Recv
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="infraredcommunication"></A><FONT size="+2">&nbsp;Infrared 
      Communication</FONT></TD></TR></TBODY></TABLE><BR>Early GBA prototypes have been 
intended to include a built-in IR port for sending and receiving IR signals. 
Among others, this port could have been used to communicate with other GBAs, or 
older CGB models, or TV Remote Controls, etc.<BR><BR>[ THE INFRARED 
COMMUNICATION FEATURE IS -NOT- SUPPORTED ANYMORE ]<BR>Anyways, the prototype 
specifications have been as shown below...<BR><BR>Keep in mind that the IR 
signal may be interrupted by whatever objects moved between sender and receiver 
- the IR port isn't recommended for programs that require realtime data exchange 
(such like action games).<BR><BR><B>4000136h - IR - Infrared Register 
(R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Transmission Data  (0=LED Off, 1=LED On)
  1     READ Enable        (0=Disable, 1=Enable)
  2     Reception Data     (0=None, 1=Signal received) (Read only)
  3     AMP Operation      (0=Off, 1=On)
  4     IRQ Enable Flag    (0=Disable, 1=Enable)
  5-15  Not used
</PRE></TD></TR></TBODY></TABLE>When 
IRQ is enabled, an interrupt is requested if the incoming signal was 0.119us Off 
(2 cycles), followed by 0.536us On (9 cycles) - minimum timing periods 
each.<BR><BR><B>Transmission Notes</B><BR>When transmitting an IR signal, note 
that it'd be not a good idea to keep the LED turned On for a very long period 
(such like sending a 1 second synchronization pulse). The recipient's circuit 
would treat such a long signal as "normal IR pollution which is in the air" 
after a while, and thus ignore the signal.<BR><BR><B>Reception Notes</B><BR>
Received data is internally latched. Latched data may be read out by setting 
both READ and AMP bits.<BR>Note: Provided that you don't want to receive your 
own IR signal, be sure to set Bit 0 to zero before attempting to receive 
data.<BR><BR><B>Power-consumption</B><BR>After using the IR port, be sure to 
reset the register to zero in order to reduce battery power 
consumption.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="keypadinput"></A><FONT size="+2">&nbsp;Keypad 
  Input</FONT></TD></TR></TBODY></TABLE><BR>The built-in GBA gamepad has 4 
direction keys, and 6 buttons.<BR><BR><B>4000130h - KEYINPUT - Key Status 
(R)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Button A        (0=Pressed, 1=Released)
  1     Button B        (etc.)
  2     Select          (etc.)
  3     Start           (etc.)
  4     Right           (etc.)
  5     Left            (etc.)
  6     Up              (etc.)
  7     Down            (etc.)
  8     Button R        (etc.)
  9     Button L        (etc.)
  10-15 Not used
</PRE></TD></TR></TBODY></TABLE>It'd 
be usually recommended to read-out this register only once per frame, and to 
store the current state in memory. As a side effect, this method avoids problems 
caused by switch bounce when a key is newly released or 
pressed.<BR><BR><B>4000132h - KEYCNT - Key Interrupt Control (R/W)</B><BR>The 
keypad IRQ function is intended to terminate the very-low-power Stop mode, it is 
not suitable for processing normal user input, to do this, most programs are 
invoking their keypad handlers from within VBlank IRQ.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Button A        (0=Ignore, 1=Select)
  1     Button B        (etc.)
  2     Select          (etc.)
  3     Start           (etc.)
  4     Right           (etc.)
  5     Left            (etc.)
  6     Up              (etc.)
  7     Down            (etc.)
  8     Button R        (etc.)
  9     Button L        (etc.)
  10-13 Not used
  14    IRQ Enable Flag (0=Disable, 1=Enable)
  15    IRQ Condition   (0=Logical OR, 1=Logical AND)
</PRE></TD></TR></TBODY></TABLE>In 
logical OR mode, an interrupt is requested when at least one of the selected 
buttons is pressed.<BR>In logical AND mode, an interrupt is requested when ALL 
of the selected buttons are pressed.<BR><BR><B>Notes</B><BR>In 8bit gameboy 
compatibility mode, L and R Buttons are used to toggle the screen size between 
normal 160x144 pixels and stretched 240x144 pixels.<BR>The GBA SP is 
additionally having a * Button used to toggle the backlight on and off, as far 
as I know there's no way to detect the current button or backlight state by 
software.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="interruptcontrol"></A><FONT size="+2">&nbsp;Interrupt 
      Control</FONT></TD></TR></TBODY></TABLE><BR><B>4000208h - IME - Interrupt Master 
Enable Register (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Disable all interrupts         (0=Disable All, 1=See IE register)
  1-15  Not used
</PRE></TD></TR></TBODY></TABLE><BR><B>4000200h 
- IE - Interrupt Enable Register (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     LCD V-Blank                    (0=Disable)
  1     LCD H-Blank                    (etc.)
  2     LCD V-Counter Match            (etc.)
  3     Timer 0 Overflow               (etc.)
  4     Timer 1 Overflow               (etc.)
  5     Timer 2 Overflow               (etc.)
  6     Timer 3 Overflow               (etc.)
  7     Serial Communication           (etc.)
  8     DMA 0                          (etc.)
  9     DMA 1                          (etc.)
  10    DMA 2                          (etc.)
  11    DMA 3                          (etc.)
  12    Keypad                         (etc.)
  13    Game Pak (external IRQ source) (etc.)
  14-15 Not used
</PRE></TD></TR></TBODY></TABLE>Note 
that there is another 'master enable flag' directly in the CPUs Status Register 
(CPSR) accessible in privileged modes, see CPU reference for 
details.<BR><BR><B>4000202h - IF - Interrupt Request Flags / IRQ Acknowledge 
(R/W, see below)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     LCD V-Blank                    (1=Request Interrupt)
  1     LCD H-Blank                    (etc.)
  2     LCD V-Counter Match            (etc.)
  3     Timer 0 Overflow               (etc.)
  4     Timer 1 Overflow               (etc.)
  5     Timer 2 Overflow               (etc.)
  6     Timer 3 Overflow               (etc.)
  7     Serial Communication           (etc.)
  8     DMA 0                          (etc.)
  9     DMA 1                          (etc.)
  10    DMA 2                          (etc.)
  11    DMA 3                          (etc.)
  12    Keypad                         (etc.)
  13    Game Pak (external IRQ source) (etc.)
  14-15 Not used
</PRE></TD></TR></TBODY></TABLE>Interrupts 
must be manually acknowledged by writing a "1" to one of the IRQ bits, the IRQ 
bit will then be cleared.<BR><BR>"[Cautions regarding clearing IME and IE]<BR>A 
corresponding interrupt could occur even while a command to clear IME or each 
flag of the IE register is being executed. When clearing a flag of IE, you need 
to clear IME in advance so that mismatching of interrupt checks will not occur." 
???<BR><BR>"[When multiple interrupts are used]<BR>When the timing of clearing 
of IME and the timing of an interrupt agree, multiple interrupts will not occur 
during that interrupt. Therefore, set (enable) IME after saving IME during the 
interrupt routine." ???<BR><BR><B>BIOS Interrupt handling</B><BR>Upon interrupt 
execution, the CPU is switched into IRQ mode, and the physical interrupt vector 
is called - as this address is located in BIOS ROM, the BIOS will always always 
execute the following code before it forwards control to the user handler:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  00000018  b      128h                ;IRQ vector: jump to actual BIOS handler
  00000128  stmfd  r13!,r0-r3,r12,r14  ;save registers to SP_irq
  0000012C  mov    r0,4000000h         ;ptr+4 to 03FFFFFC (mirror of 03007FFC)
  00000130  add    r14,r15,0h          ;retadr for USER handler $+8=138h
  00000134  ldr    r15,[r0,-4h]        ;jump to [03FFFFFC] USER handler
  00000138  ldmfd  r13!,r0-r3,r12,r14  ;restore registers from SP_irq
  0000013C  subs   r15,r14,4h          ;return from IRQ (PC=LR-4, CPSR=SPSR)
</PRE></TD></TR></TBODY></TABLE>As 
shown above, a pointer to the 32bit/ARM-code user handler must be setup in 
[03007FFCh]. By default, 160 bytes of memory are reserved for interrupt stack at 
03007F00h-03007F9Fh.<BR><BR><B>Recommended User Interrupt handling</B><BR>- If 
necessary switch to THUMB state manually (handler is called in ARM state)<BR>- 
Determine reason(s) of interrupt by examining IF register<BR>- User program may 
freely assign priority to each reason by own logic<BR>- Process the most 
important reason of your choice<BR>- User MUST manually acknowledge by writing 
to IF register<BR>- If user wants to allow nested interrupts, save SPSR_irq, 
then enable IRQs.<BR>- If using other registers than BIOS-pushed R0-R3, manually 
save R4-R11 also.<BR>- Note that Interrupt Stack is used (which may have limited 
size)<BR>- So, for memory consuming stack operations use system mode (=user 
stack).<BR>- When calling subroutines in system mode, save LSR_usr also.<BR>- 
Restore SPSR_irq and/or R4-R11 if you've saved them above.<BR>- Finally, return 
to BIOS handler by BX LR (R14_irq) instruction.<BR><BR><B>Default memory usage 
at 03007FXX (and mirrored to 03FFFFXX)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Addr. Size Expl.
  7FFCh 4    Pointer to user IRQ handler (32bit ARM code)
  7FF8h 4    Interrupt Check Flag (for IntrWait/VBlankIntrWait functions)
  7FF4h 4    Allocated Area
  7FF0h 4    Pointer to Sound Buffer
  7FE0h 16   Allocated Area
  7FA0h 64   Default area for SP_svc Supervisor Stack (4 words/time)
  7F00h 160  Default area for SP_irq Interrupt Stack (6 words/time)
</PRE></TD></TR></TBODY></TABLE>Memory 
below 7F00h is free for User Stack and user data. The three stack pointers are 
initially initialized at the TOP of the respective areas:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  SP_svc=03007FE0h
  SP_irq=03007FA0h
  SP_usr=03007F00h
</PRE></TD></TR></TBODY></TABLE>The 
user may redefine these addresses and move stacks into other locations, however, 
the addresses for system data at 7FE0h-7FFFh are fixed.<BR><BR><B>Not sure, is 
following free for user ???</B><BR>Registers R8-R12_fiq, R13_fiq, R14_fiq, 
SPSR_fiq<BR>Registers R13-R14_abt, SPSR_abt<BR>Registers R13-R14_und, 
SPSR_und<BR><BR><B>Fast Interrupt (FIQ)</B><BR>The ARM CPU provides two 
interrupt sources, IRQ and FIQ. In the GBA only IRQ is used. In normal GBAs, the 
FIQ signal is shortcut to VDD35, ie. the signal is always high, and there is no 
way to generate a FIQ by hardware. The registers R8..12_fiq could be used by 
software (when switching into FIQ mode by writing to CPSR) - however, this might 
make the game incompatible with hardware debuggers (which are reportedly using 
FIQs for debugging purposes).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="systemcontrol"></A><FONT size="+2">&nbsp;System 
    Control</FONT></TD></TR></TBODY></TABLE><BR><B>4000204h - WAITCNT - Waitstate 
Control (R/W)</B><BR>This register is used to configure game pak access timings. 
The game pak ROM is mirrored to three address regions at 08000000h, 0A000000h, 
and 0C000000h, these areas are called Wait State 0-2. Different access timings 
may be assigned to each area (this might be useful in case that a game pak 
contains several ROM chips with different access times each).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-1   SRAM Wait Control          (0..3 = 4,3,2,8 cycles)
  2-3   Wait State 0 First Access  (0..3 = 4,3,2,8 cycles)
  4     Wait State 0 Second Access (0..1 = 2,1 cycles)
  5-6   Wait State 1 First Access  (0..3 = 4,3,2,8 cycles)
  7     Wait State 1 Second Access (0..1 = 4,1 cycles; unlike above WS0)
  8-9   Wait State 2 First Access  (0..3 = 4,3,2,8 cycles)
  10    Wait State 2 Second Access (0..1 = 8,1 cycles; unlike above WS0,WS1)
  11-12 PHI Terminal Output        (0..3 = Disable, 4.19MHz, 8.38MHz, 16.78MHz)
  13    Not used
  14    Game Pak Prefetch Buffer (Pipe) (0=Disable, 1=Enable)
  15    Game Pak Type Flag  (Read Only) (0=GBA, 1=CGB)
</PRE></TD></TR></TBODY></TABLE>At 
startup, the default setting is 0000h. Currently manufactured cartridges are 
using the following settings: WS0/ROM=3,1 clks; SRAM=8 clks; WS2/EEPROM: 8,8 
clks; prefetch enabled; that is, WAITCNT=4317h, for more info see "Cartridges" 
chapter.<BR><BR>First Access (Non-sequential) and Second Access (Sequential) 
define the waitstates for N and S cycles, the actual access time is 1 clock 
cycle PLUS the number of waitstates.<BR>GamePak uses 16bit data bus, so that a 
32bit access is split into TWO 16bit accesses (of which, the second fragment is 
always sequential, even if the first fragment was non-sequential).<BR><BR><A 
href="#gamepakprefetch">GamePak 
Prefetch</A><BR><BR>NOTES:<BR>The GBA forcefully uses non-sequential timing at 
the beginning of each 128K-block of gamepak ROM, eg. "LDMIA [801fff8h],r0-r7" 
will have non-sequential timing at 8020000h.<BR>The PHI Terminal output (PHI Pin 
of Gamepak Bus) should be disabled.<BR><BR><B>4000300h - POSTFLG - BYTE - 
Undocumented - Post Boot / Debug Control (R/W)</B><BR>After initial reset, the 
GBA BIOS initializes the register to 01h, and any further execution of the Reset 
vector (00000000h) will pass control to the Debug vector (0000001Ch) when 
sensing the register to be still set to 01h.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Undocumented. First Boot Flag  (0=First, 1=Further)
  1-7   Undocumented. Not used.
</PRE></TD></TR></TBODY></TABLE>Normally 
the debug handler rejects control unless it detects Debug flags in cartridge 
header, in that case it may redirect to a cut-down boot procedure (bypassing 
Nintendo logo and boot delays, much like nocash burst boot for multiboot 
software). I am not sure if it is possible to reset the GBA externally without 
automatically resetting register 300h though.<BR><BR><B>4000301h - HALTCNT - 
BYTE - Undocumented - Low Power Mode Control (W)</B><BR>Writing to this register 
switches the GBA into battery saving mode.<BR>In Halt mode, the CPU is paused as 
long as (IE AND IF)=0, this should be used to reduce power-consumption during 
periods when the CPU is waiting for interrupt events.<BR>In Stop mode, most of 
the hardware including sound and video are paused, this very-low-power mode 
could be used much like a screensaver.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-6   Undocumented. Not used.
  7     Undocumented. Power Down Mode  (0=Halt, 1=Stop)
</PRE></TD></TR></TBODY></TABLE>The 
current GBA BIOS addresses only the upper eight bits of this register (by 
writing 00h or 80h to address 04000301h), however, as the register isn't 
officially documented, some or all of the bits might have different meanings in 
future GBA models.<BR>For best forwards compatibility, it'd generally be more 
recommended to use the BIOS Functions SWI 2 (Halt) or SWI 3 (Stop) rather than 
writing to this register directly.<BR><BR><B>4000410h - Undocumented - Purpose 
Unknown ??? 8bit (W)</B><BR>The BIOS writes the 8bit value 0FFh to this address. 
Purpose Unknown.<BR>Probably just another bug in the BIOS.<BR><BR><B>4000800h - 
32bit - Undocumented - Internal Memory Control (R/W)</B><BR>Supported by GBA and 
GBA SP only - NOT supported by DS (even in GBA mode).<BR>Initialized to 
0D000020h (by hardware). Unlike all other I/O registers, this register is 
mirrored across the whole 4XXXXXXh I/O area (in increments of 64K, ie. at 800h, 
10800h, 20800h, etc.)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Purpose Unknown  (Seems to lock up the GBA when set to 1)
  1-3   Purpose Unknown  (Read/Write able)
  4     Purpose Unknown  (Always zero - not used or write only)
  5     Purpose Unknown  (Seems to lock up the GBA when set to 0)
  6-23  Purpose Unknown  (Always zero - not used or write only)
  24-27 Wait Control WRAM 256K (0-14 = 15..1 Waitstates, 15=Lockup)
  28-31 Purpose Unknown  (Read/Write able)
</PRE></TD></TR></TBODY></TABLE>The 
value 0Dh in Bits 24-27 selects 2 waitstates for 256K WRAM (ie. 3/3/6 cycles 
8/16/32bit accesses). The fastest possible setting would be 0Eh (1 waitstate, 
2/2/4 cycles for 8/16/32bit).<BR><BR>Note: One cycle equals approx. 59.59ns (ie. 
16.78MHz clock).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="gamepakprefetch"></A><FONT size="+2">&nbsp;GamePak 
      Prefetch</FONT></TD></TR></TBODY></TABLE><BR>GamePak Prefetch can be enabled in 
WAITCNT register. When prefetch buffer is enabled, the GBA attempts to read 
opcodes from Game Pak ROM during periods when the CPU is not using the bus (if 
any). Memory access is then performed with 0 Waits if the CPU requests data 
which is already stored in the buffer. The prefetch buffer stores up to eight 
16bit values.<BR><BR><B>GamePak ROM Opcodes</B><BR>The prefetch feature works 
only with &lt;opcodes&gt; fetched from GamePak ROM. Opcodes executed in RAM or 
BIOS are not affected by the prefetch feature (even if that opcodes read 
&lt;data&gt; from GamePak ROM).<BR><BR><B>Prefetch Enable</B><BR>For GamePak ROM 
opcodes, prefetch may occur in two situations:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  1) opcodes with internal cycles (I) which do not change R15, shift/rotate
     register-by-register, load opcodes (ldr,ldm,pop,swp), multiply opcodes
  2) opcodes that load/store memory (ldr,str,ldm,stm,etc.)
</PRE></TD></TR></TBODY></TABLE><BR><B>Prefetch 
Disable Bug</B><BR>When Prefetch is disabled, the Prefetch Disable Bug will 
occur for<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  &lt;GamePak ROM opcodes with internal cycles which do not change R15&gt;.
</PRE></TD></TR></TBODY></TABLE>That 
are, Shift/rotate register-by-register opcodes, multiply opcodes, and load 
opcodes (ldr,ldm,pop,swp). The bug adds 2I cycles to any such opcodes, ie. a 
multiply opcode with 4I cycles will be delayed to 6I cycles.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cartridges"></A><FONT 
  size="+2">&nbsp;Cartridges</FONT></TD></TR></TBODY></TABLE><BR><B>ROM</B><BR><A 
href="#cartridgeheader">Cartridge 
Header</A><BR><A href="#cartridgerom">Cartridge 
ROM</A><BR><BR><B>Backup Media</B><BR>Aside from ROM, cartridges may also 
include one of the following backup medias, used to store game positions, 
highscore tables, options, or other data.<BR><A href="#backupsram">Backup 
SRAM</A><BR><A 
href="#backupeeprom">Backup 
EEPROM</A><BR><A href="#backupflashrom">Backup 
Flash ROM</A><BR><A href="#backupdacs">Backup 
DACS</A><BR><BR><B>Other Accessoires</B><BR><A href="#flashcards">Flashcards</A><BR><A 
href="#cheatdevices">Cheat 
Devices</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cartridgeheader"></A><FONT size="+2">&nbsp;Cartridge 
      Header</FONT></TD></TR></TBODY></TABLE><BR>The first 192 bytes at 
8000000h-80000BFh in ROM are used as cartridge header. The same header is also 
used for Multiboot images at 2000000h-20000BFh (plus some additional multiboot 
entries at 20000C0h and up).<BR><BR><B>Header Overview</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Address Bytes Expl.
  000h    4     ROM Entry Point  (32bit ARM branch opcode, eg. "B rom_start")
  004h    156   Nintendo Logo    (compressed bitmap, required!)
  0A0h    12    Game Title       (uppercase ascii, max 12 characters)
  0ACh    4     Game Code        (uppercase ascii, 4 characters)
  0B0h    2     Maker Code       (uppercase ascii, 2 characters)
  0B2h    1     Fixed value      (must be 96h, required!)
  0B3h    1     Main unit code   (00h for current GBA models)
  0B4h    1     Device type      (huh ???)
  0B5h    7     Reserved Area    (should be zero filled)
  0BCh    1     Software version (usually 00h)
  0BDh    1     Complement check (header checksum, required!)
  0BEh    2     Reserved Area    (should be zero filled)
  --- Additional Multiboot Header Entries ---
  0C0h    4     RAM Entry Point  (32bit ARM branch opcode, eg. "B ram_start")
  0C4h    1     Boot mode        (init as 00h - BIOS overwrites this value!)
  0C5h    1     Slave ID Number  (init as 00h - BIOS overwrites this value!)
  0C6h    26    Not used         (seems to be unused)
  0E4h    4     JOYBUS Entry Pt. (32bit ARM branch opcode, eg. "B joy_start")
</PRE></TD></TR></TBODY></TABLE>Note: 
With all entry points, the CPU is initially set into system mode.<BR><BR><B>000h 
- Entry Point, 4 Bytes</B><BR>Space for a single 32bit ARM opcode that redirects 
to the actual startaddress of the cartridge, this should be usually a "B 
&lt;start&gt;" instruction.<BR>Note: This entry is ignored by Multiboot slave 
GBAs (in fact, the entry is then overwritten and redirected to a separate 
Multiboot Entry Point, as described below).<BR><BR><B>004h..09Fh - Nintendo 
Logo, 156 Bytes</B><BR>Contains the Nintendo logo which is displayed during the 
boot procedure. Cartridge won't work if this data is missing or modified.<BR>In 
detail: This area contains Huffman compression data (but excluding the 
compression header which is hardcoded in the BIOS, so that it'd be probably not 
possible to hack the GBA by producing de-compression buffer overflows).<BR>A 
copy of the compression data is stored in the BIOS, the GBA will compare this 
data and lock-up itself if the BIOS data isn't exactly the same as in the 
cartridge (or multiboot header). The only exception are the two entries below 
which are allowed to have variable settings in some bits.<BR><BR><B>09Ch Bit 2,7 
- Debugging Enable</B><BR>This is part of the above Nintendo Logo area, and must 
be commonly set to 21h, however, Bit 2 and Bit 7 may be set to other values.<BR>
When both bits are set (ie. A5h), the FIQ/Undefined Instruction handler in the 
BIOS becomes unlocked, the handler then forwards these exceptions to the user 
handler in cartridge ROM (entry point defined in 80000B4h, see below).<BR>Other 
bit combinations currently do not seem to have special functions.<BR><BR><B>09Eh 
Bit 0,1 - Cartridge Key Number MSBs</B><BR>This is part of the above Nintendo 
Logo area, and must be commonly set to F8h, however, Bit 0-1 may be set to other 
values.<BR>During startup, the BIOS performs some dummy-reads from a stream of
 pre-defined addresses, even though these reads seem to be meaningless, they 
might be intended to unlock a read-protection inside of commercial cartridge. 
There are 16 pre-defined address streams - selected by a 4bit key number - of 
which the upper two bits are gained from 800009Eh Bit 0-1, and the lower two 
bits from a checksum across header bytes 09Dh..0B7h (bytewise XORed, divided by 
40h).<BR><BR><B>0A0h - Game Title, Uppercase Ascii, max 12 characters</B><BR>
Space for the game title. If less than 12 chars, SPACE or ZERO padded
 ???<BR><BR><B>0ACh - Game Code, Uppercase Ascii, 4 characters</B><BR>This is 
the same code as the AGB-UTTD code which is printed on the package and sticker 
on (commercial) cartridges (excluding the leading "AGB-" part).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  U  Unique Code          ("A", "B", "C", "D", etc.)
  TT Short Title          (eg. "PM" for Pac Man)
  D  Destination/Language ("J"=Japan, "E"=USA/English, "P"=Europe/Elsewhere)
</PRE></TD></TR></TBODY></TABLE>The 
first character (U) is usually "A", unless if the same Short Title was already 
used by other game(s).<BR><BR><B>0B0h - Maker code, Uppercase Ascii, 2 
characters</B><BR>Identifies the (commercial) developer. For example, 
"01"=Nintendo.<BR><BR><B>0B2h - Fixed value, 1 Byte</B><BR>Must be 
96h.<BR><BR><B>0B3h - Main unit code, 1 Byte</B><BR>Identifies the required 
hardware. Should be 00h for current GBA models.<BR><BR><B>0B4h - Device type, 1 
Byte</B><BR>Normally, this entry should be zero. With Nintendos hardware 
debugger Bit 7 identifies the debugging handlers entry point and size of DACS
 (Debugging And Communication System) memory: Bit7=0: 9FFC000h/8MBIT DACS, 
Bit7=1: 9FE2000h/1MBIT DACS. The debugging handler can be enabled in 800009Ch 
(see above), normal cartridges do not have any memory (nor any mirrors) at these 
addresses though.<BR><BR><B>0B5h - Reserved Area, 7 Bytes</B><BR>Reserved, zero 
filled.<BR><BR><B>0BCh - Software version number</B><BR>Version number of the 
game. Usually zero.<BR><BR><B>0BDh - Complement check, 1 Byte</B><BR>Header 
checksum, cartridge won't work if incorrect. Calculate as such:<BR>chk=0:for 
i=0A0h to 0BCh:chk=chk-[i]:next:chk=(chk-19h) and 0FFh<BR><BR><B>0BEh - Reserved 
Area, 2 Bytes</B><BR>Reserved, zero filled.<BR><BR>Below required for 
Multiboot/slave programs only. For Multiboot, the above 192 bytes are required 
to be transferred as header-block (loaded to 2000000h-20000BFh), and some 
additional header-information must be located at the beginning of the actual 
program/data-block (loaded to 20000C0h and up). This extended header consists of 
Multiboot Entry point(s) which must be set up correctly, and of two reserved 
bytes which are overwritten by the boot procedure:<BR><BR><B>0C0h - 
Normal/Multiplay mode Entry Point</B><BR>This entry is used only if the GBA has 
been booted by using Normal or Multiplay transfer mode (but not by Joybus 
mode).<BR>Typically deposit a ARM-32bit "B &lt;start&gt;" branch opcode at this
 location, which is pointing to your actual initialization 
procedure.<BR><BR><B>0C4h (BYTE) - Boot mode</B><BR>The slave GBA download 
procedure overwrites this byte by a value which is indicating the used multiboot 
transfer mode.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Value  Expl.
  01h    Joybus mode
  02h    Normal mode
  03h    Multiplay mode
</PRE></TD></TR></TBODY></TABLE>Typically 
set this byte to zero by inserting DCB 00h in your source.<BR>Be sure that your 
uploaded program does not contain important program code or data at this 
location, or at the ID-byte location below.<BR><BR><B>0C5h (BYTE) - Slave ID 
Number</B><BR>If the GBA has been booted in Normal or Multiplay mode, this byte
 becomes overwritten by the slave ID number of the local GBA (that'd be always 
01h for normal mode).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Value  Expl.
  01h    Slave #1
  02h    Slave #2
  03h    Slave #3
</PRE></TD></TR></TBODY></TABLE>Typically 
set this byte to zero by inserting DCB 00h in your source.<BR>When booted in 
Joybus mode, the value is NOT changed and remains the same as uploaded from the 
master GBA.<BR><BR><B>0C6h..0DFh - Not used</B><BR>Appears to be 
unused.<BR><BR><B>0E0h - Joybus mode Entry Point</B><BR>If the GBA has been 
booted by using Joybus transfer mode, then the entry point is located at this 
address rather than at 20000C0h. Either put your initialization procedure 
directly at this address, or redirect to the actual boot procedure by depositing 
a "B &lt;start&gt;" opcode here (either one using 32bit ARM code). Or, if you 
are not intending to support joybus mode (which is probably rarely used), ignore 
this entry.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cartridgerom"></A><FONT size="+2">&nbsp;Cartridge 
    ROM</FONT></TD></TR></TBODY></TABLE><BR><B>ROM Size</B><BR>The games F-ZERO and 
Super Mario Advance use ROMs of 4 MBytes each. Zelda uses 8 MBytes. Not sure if 
other sizes are manufactured.<BR><BR><B>ROM Waitstates</B><BR>The GBA starts the 
cartridge with 4,2 waitstates (N,S) and prefetch disabled. The program may 
change these settings by writing to WAITCNT, the games F-ZERO and Super Mario 
Advance use 3,1 waitstates (N,S) each, with prefetch enabled.<BR>Third-party 
flashcards are reportedly running unstable with these settings. Also, prefetch 
and shorter waitstates are allowing to read more data and opcodes from ROM is 
less time, the downside is that it increases the power 
consumption.<BR><BR><B>ROM Chip</B><BR>Because of how 24bit addresses are 
squeezed through the Gampak bus, the cartridge must include a circuit that 
latches the lower 16 address bits on non-sequential access, and that increments 
these bits on sequential access. Nintendo includes this circuit directly in the 
ROM chip.<BR>Also, the ROM must have 16bit data bus, or otherwise another 
circuit is required which converts two 8bit data units into one 16bit unit - by 
not exceeding the waitstate timings.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="backupsram"></A><FONT size="+2">&nbsp;Backup 
  SRAM</FONT></TD></TR></TBODY></TABLE><BR>32 KBytes - 256Kbit Battery buffered 
SRAM - Lifetime: Depends on battery<BR>64 KBytes - reportedly used by newer 
games ???<BR><BR><B>Addressing and Waitstates</B><BR>SRAM is mapped to 
E000000h-E007FFFh, it should be accessed with 8 waitstates (write a value of 3 
into Bit0-1 of WAITCNT).<BR><BR><B>Databus Width</B><BR>The SRAM databus is 
restricted to 8 bits, it should be accessed by LDRB, LDRSB, and STRB opcodes 
only.<BR><BR><B>Reading and Writing</B><BR>Reading from SRAM should be performed 
by code executed in WRAM only (but not by code executed in ROM). There is no 
such restriction for writing.<BR><BR><B>Preventing Data Loss</B><BR>The GBA SRAM 
carts do not include a write-protect function (unlike older 8bit gameboy carts). 
This seems to be a problem and may cause data loss when a cartridge is removed 
or inserted while the GBA is still turned on. As far as I understand, this is 
not so much a hardware problem, but rather a software problem, ie. theoretically 
you could remove/insert the cartridge as many times as you want, but you should 
take care that your program does not crash (and write blindly into 
memory).<BR><BR><B>Recommended Workaround</B><BR>Enable the Gamepak Interrupt 
(it'll most likely get triggered when removing the cartridge), and hang-up the 
GBA in an endless loop when your interrupt handler senses a Gamepak IRQ. For 
obvious reason, your interrupt handler should be located in WRAM, ie. not in the 
(removed) ROM cartridge. The handler should process Gamepak IRQs at highest
 priority. Periods during which interrupts are disabled should be kept as short 
as possible, if necessary allow nested interrupts.<BR><BR><B>When to use the 
above Workaround</B><BR>A program that relies wholly on code and data in WRAM, 
and that does not crash even when ROM is removed, may keep operating without 
having to use the above mechanism.<BR>Do NOT use the workaround for programs 
that run without a cartridge inserted (ie. single gamepak/multiboot slaves), or 
for programs that use Gamepak IRQ/DMA for other purposes.<BR>All other programs 
should use it. It'd be eventually a good idea to include it even in programs 
that do not use SRAM themselves (eg. otherwise removing a SRAM-less cartridge 
may lock up the GBA, and may cause it to destroy backup data when inserting a 
SRAM cartridge).<BR><BR><B>Note</B><BR>SRAM is used by the game F-ZERO, and 
possibly others.<BR><BR>In SRAM cartridges, the /REQ pin (Pin 31 of Gamepak bus) 
should be a little bit shorter as than the other pins; when removing the 
cartridge, this causes the gamepak IRQ signal to get triggered before the other 
pins are disconnected.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="backupeeprom"></A><FONT size="+2">&nbsp;Backup 
    EEPROM</FONT></TD></TR></TBODY></TABLE><BR>512 Bytes (0200h) - 4Kbit EEPROM - 
Lifetime: 100,000 writes per address<BR>8 KBytes (2000h) - 64Kbit EEPROM - 
Lifetime: No info.<BR><BR><B>Addressing and Waitstates</B><BR>The eeprom is 
connected to Bit0 of the data bus, and to the upper 1 bit (or upper 17 bits in 
case of large 32MB ROM) of the cartridge ROM address bus, communication with the 
chip takes place serially.<BR>The eeprom must be used with 8 waitstates (set 
WAITCNT=X3XXh; 8,8 clks in WS2 area), the eeprom can be then addressed at 
DFFFF00h..DFFFFFFh.<BR>Respectively, with eeprom, ROM is restricted to 
8000000h-9FFFeFFh (max. 1FFFF00h bytes = 32MB minus 256 bytes). On carts with 
16MB or smaller ROM, eeprom can be alternately accessed anywhere at 
D000000h-DFFFFFFh.<BR><BR><B>Data and Address Width</B><BR>Data can be read from 
(or written to) the EEPROM in units of 64bits (8 bytes). Writing automatically 
erases the old 64bits of data. Addressing works in units of 64bits respectively, 
that is, for 512 Bytes EEPROMS: an address range of 0-3Fh, 6bit bus width; and 
for 8KByte EEPROMs: a range of 0-3FFh, 14bit bus width (only the lower 10 
address bits are used, upper 4 bits should be zero).<BR><BR><B>Set Address (For 
Reading)</B><BR>Prepare the following bitstream in memory:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  2 bits "11" (Read Request)
  n bits eeprom address (MSB first, 6 or 14 bits, depending on EEPROM)
  1 bit "0"
</PRE></TD></TR></TBODY></TABLE>Then 
transfer the stream to eeprom by using DMA.<BR><BR><B>Read Data</B><BR>Read a 
stream of 68 bits from EEPROM by using DMA,<BR>then decipher the received data 
as follows:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4 bits - ignore these
 64 bits - data (conventionally MSB first)
</PRE></TD></TR></TBODY></TABLE><BR><B>Write 
Data to Address</B><BR>Prepare the following bitstream in memory, then transfer 
the stream to eeprom by using DMA, it'll take ca. 108368 clock cycles (ca. 
6.5ms) until the old data is erased and new data is programmed.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  2 bits "10" (Write Request)
  n bits eeprom address (MSB first, 6 or 14 bits, depending on EEPROM)
 64 bits data (conventionally MSB first)
  1 bit "0"
</PRE></TD></TR></TBODY></TABLE>After 
the DMA, keep reading from the chip, by normal LDRH [DFFFF00h], until Bit 0 of 
the returned data becomes "1" (Ready). To prevent your program from locking up 
in case of malfunction, generate a timeout if the chip does not reply after 10ms 
or longer.<BR><BR><B>Using DMA</B><BR>Transferring a bitstream to/from the 
EEPROM by LDRH/STRH opcodes does not work, this might be because of timing 
problems, or because how the GBA squeezes non-sequential memory addresses 
through the external address/data bus.<BR>For this reason, a buffer in memory 
must be used (that buffer would be typically allocated temporarily on stack, one 
halfword for each bit, bit1-15 of the halfwords are don't care, only bit0 is of 
interest).<BR>The buffer must be transfered as a whole to/from EEPROM by using 
DMA3 (only DMA 3 is valid to read &amp; write external memory), use 16bit 
transfer mode, both source and destination address incrementing (ie.
 DMA3CNT=80000000h+length).<BR>DMA channels of higher priority should be 
disabled during the transfer (ie. H/V-Blank or Sound FIFO DMAs). And, of course 
any interrupts that might mess with DMA registers should be 
disabled.<BR><BR><B>Pin-Outs</B><BR>The EEPROM chips are having only 8 pins, 
these are connected, Pin 1..8, to ROMCS, RD, WR, AD0, GND, GND, A23, VDD of the 
GamePak bus. Carts with 32MB ROM must have A7..A22 logically ANDed with 
A23.<BR><BR><B>Notes</B><BR>There seems to be no autodection mechanism, so that 
a hardcoded bus width must be used. The game Super Mario Advance uses a 512 Byte 
EEPROM, no idea which games use 8KBytes (if any) ???<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="backupflashrom"></A><FONT size="+2">&nbsp;Backup Flash 
      ROM</FONT></TD></TR></TBODY></TABLE><BR>64 KBytes - 512Kbits Flash ROM - 
Lifetime: 10,000 writes per sector<BR>128 KBytes - 1Mbit Flash ROM - Lifetime: 
??? writes per sector<BR><BR><B>Chip Identification (all device types)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=90h  (enter ID mode)
  dev=[E000001h], man=[E000000h]                  (get device &amp; manufacturer)
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=F0h  (terminate ID mode)
</PRE></TD></TR></TBODY></TABLE>Used 
to detect the type (and presence) of FLASH chips. See Device Types 
below.<BR><BR><B>Reading Data Bytes (all device types)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  dat=[E00xxxxh]                                  (read byte from address xxxx)
</PRE></TD></TR></TBODY></TABLE><BR><B>Erase 
Entire Chip (all device types)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=80h  (erase command)
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=10h  (erase entire chip)
  wait until [E000000h]=FFh (or timeout)
</PRE></TD></TR></TBODY></TABLE>Erases 
all memory in chip, erased memory is FFh-filled.<BR><BR><B>Erase 4Kbyte Sector 
(all device types, except Atmel)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=80h  (erase command)
  [E005555h]=AAh, [E002AAAh]=55h, [E00n000h]=30h  (erase sector n)
  wait until [E00n000h]=FFh (or timeout)
</PRE></TD></TR></TBODY></TABLE>Erases 
memory at E00n000h..E00nFFFh, erased memory is 
FFh-filled.<BR><BR><B>Erase-and-Write 128 Bytes Sector (only Atmel 
devices)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  old=IME, IME=0                                  (disable interrupts)
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=A0h  (erase/write sector command)
  [E00xxxxh+00h..7Fh]=dat[00h..7Fh]               (write 128 bytes)
  IME=old                                         (restore old IME state)
  wait until [E00xxxxh+7Fh]=dat[7Fh] (or timeout)
</PRE></TD></TR></TBODY></TABLE>Interrupts 
(and DMAs) should be disabled during command/write phase. Target address must be 
a multiple of 80h.<BR><BR><B>Write Single Data Byte (all device types, except 
Atmel)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=A0h  (write byte command)
  [E00xxxxh]=dat                                  (write byte to address xxxx)
  wait until [E00xxxxh]=dat (or timeout)
</PRE></TD></TR></TBODY></TABLE>The 
target memory location must have been previously erased.<BR><BR><B>Terminate 
Command after Timeout (only Macronix devices, ID=1CC2h)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  [E005555h]=F0h                            (force end of write/erase command)
</PRE></TD></TR></TBODY></TABLE>Use 
if timeout occurred during "wait until" periods, for Macronix devices 
only.<BR><BR><B>Bank Switching (devices bigger than 64K only)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=B0h  (select bank command)
  [E000000h]=bnk                                  (write bank number 0..1)
</PRE></TD></TR></TBODY></TABLE>Specifies 
64K bank number for read/write/erase operations.<BR>Required because gamepak 
flash/sram addressbus is limited to 16bit width.<BR><BR><B>Device Types</B><BR>
Nintendo puts different FLASH chips in commercial game cartridges. Developers 
should thus detect &amp; support all chip types. For Atmel chips it'd be 
recommended to simulate 4K sectors by software, though reportedly Nintendo 
doesn't use Atmel chips in newer games anymore. Also mind that different timings 
should not disturb compatibility and performance.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  ID     Name       Size  Sectors  AverageTimings  Timeouts/ms   Waits
  D4BFh  SST        64K   16x4K    20us?,?,?       10,  40, 200  3,2
  1CC2h  Macronix   64K   16x4K    ?,?,?           10,2000,2000  8,3
  1B32h  Panasonic  64K   16x4K    ?,?,?           10, 500, 500  4,2
  3D1Fh  Atmel      64K   512x128  ?,?,?           ...40..,  40  8,8
  ???    ?          128K  ?        ?,?,?           ?    ?    ?    ?
  09C2h  Macronix ? 128K  ?        ?,?,?           ?    ?    ?    ?
</PRE></TD></TR></TBODY></TABLE>Identification 
Codes MSB=Device Type, LSB=Manufacturer.<BR>Size in bytes, and numbers of 
sectors * sector size in bytes.<BR>Average medium Write, Erase Sector, Erase 
Chips timings are unknown ???<BR>Timeouts im milliseconds for Write, Erase 
Sector, Erase Chips.<BR>Waitstates for Writes, and Reads in clock 
cycles.<BR><BR><B>Accessing FLASH Memory</B><BR>FLASH memory is located in the 
"SRAM" area at E000000h..E00FFFFh, which is restricted to 16bit address and 8bit 
data buswidths. Respectively, the memory can be accessed &lt;only&gt; by 8bit 
read/write LDRB/STRB opcodes.<BR>Also, reading anything (data or status/busy 
information) can be done&lt; only&gt; by opcodes executed in WRAM (not from 
opcodes in ROM) (there's no such restriction for writing).<BR><BR><B>FLASH 
Waitstates</B><BR>Use 8 clk waitstates for initial detection (WAITCNT Bits 0,1 
both set). After detection of certain device types smaller wait values may be 
used for write/erase, and even smaller wait values for raw reading, see Device
 Types table.<BR>In practice, games seem to use smaller values only for 
write/erase (even though those operations are slow anyways), whilst raw reads 
are always done at 8 clk waits (even though reads could actually benefit 
slightly from smaller wait values).<BR><BR><B>Verify Write/Erase and 
Retry</B><BR>Even though device signalizes the completion of write/erase 
operations, it'd be recommended to read/confirm the content of the changed 
memory area by software. In practice, Nintendos "erase-write-verify-retry" 
function typically repeats the operation up to three times in case of 
errors.<BR>Also, for SST devices only, the "erase-write" and
 "erase-write-verify-retry" functions repeat the erase command up to 80 times, 
additionally followed by one further erase command if no retries were needed, 
otherwise followed by six further erase commands.<BR><BR><B>Note</B><BR>FLASH 
(64Kbytes) is used by the game Sonic Advance, and possibly others.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="backupdacs"></A><FONT size="+2">&nbsp;Backup 
  DACS</FONT></TD></TR></TBODY></TABLE><BR>128 KBytes - 1Mbit DACS - Lifetime: 
100,000 writes.<BR>1024 KBytes - 8Mbit DACS - Lifetime: 100,000 writes.<BR><BR>
DACS (Debugging And Communication System) is used in Nintendos hardware debugger 
only, DACS is NOT used in normal game cartridges.<BR><BR>Parts of DACS memory is 
used to store the debugging exception handlers (entry point/size defined in 
cartridge header), the remaining memory could be used to store game positions or 
other data. The address space is the upper end of the 32MB ROM area, the memory 
can be read directly by the CPU, including for ability to execute program code 
in this area.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="flashcards"></A><FONT 
  size="+2">&nbsp;Flashcards</FONT></TD></TR></TBODY></TABLE><BR>Flashcards are 
re-writable cartridges using FLASH memory, allowing to test even 
multiboot-incompatible GBA software on real hardware, providing a good 
development environment when used in combination with a reasonable software 
debugger.<BR><BR>The carts can be written to from external tools, or directly 
from GBA programs.<BR>Below are pseudo code flowcharts for detect, erase, and 
write operations.<BR>All flash reads/writes are meant to be 16bit (ldrh/strh) 
memory accesses.<BR><BR><B>detect_flashcard:</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> configure_flashcard(9E2468Ah,9413h)    ;unlock flash advance cards
 turbo=1, send_command(8000000h,90h)    ;enter ID mode (both chips, if any)
 maker=[8000000h], device=[8000000h+2]
 IF maker=device THEN device=[8000000h+4] ELSE turbo=0
 flashcard_read_mode                    ;exit ID mode
 search (maker+device*10000h) in device_list
 total/erase/write_block_size = list_entry SHL turbo
</PRE></TD></TR></TBODY></TABLE><BR><B>flashcard_erase(dest,len):</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> FOR x=1 to len/erase_block_size
  send_command(dest,20h)        ;erase sector command
  send_command(dest,D0h)        ;confirm erase sector
  dest=dest+erase_block_size
 IF wait_busy=okay THEN NEXT x
 enter_read_mode                ;exit erase/status mode
</PRE></TD></TR></TBODY></TABLE><BR><B>flashcard_write(src,dest,len):</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> siz=write_block_size
 FOR x=1 to len/siz
  IF siz=2 THEN send_command(dest,10h)  ;write halfword command
  IF siz&gt;2 THEN send_command(dest,E8h)  ;write to buffer command
  IF siz&gt;2 THEN send_command(dest,16-1) ;buffer size 16 halfwords (per chip)
  FOR y=1 TO siz/2
   [dest]=[src], dest=dest+2, src=src+2 ;write data to buffer
  NEXT y
  IF siz&gt;2 THEN send_command(dest,D0h)  ;confirm write to buffer
 IF wait_busy=okay THEN NEXT x
 enter_read_mode                        ;exit write/status mode
</PRE></TD></TR></TBODY></TABLE><BR><B>send_command(adr,val):</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> [adr]=val
 IF turbo THEN [adr+2]=val
</PRE></TD></TR></TBODY></TABLE><BR><B>enter_read_mode:</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> send_command(8000000h,FFh)     ;exit status mode
 send_command(8000000h,FFh)     ;again maybe more stable (as in jeff's source)
</PRE></TD></TR></TBODY></TABLE><BR><B>flashcard_wait_busy:</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> start=time
 REPEAT
  stat=[8000000h] XOR 80h
  IF turbo THEN stat=stat OR ([8000000h+2] XOR 80h)
  IF (stat AND 7Fh)&gt;0 THEN error
  IF (stat AND 80h)=0 THEN ready
  IF time-start&gt;5secs THEN timeout
 UNTIL ready OR error OR timeout
 IF error OR timeout THEN send_command(8000000h,50h)    ;clear status
</PRE></TD></TR></TBODY></TABLE><BR><B>configure_flashcard(adr,val): 
  ;required for Flash Advance cards only</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> [930ECA8h]=5354h
 [802468Ah]=1234h, repeated 500 times
 [800ECA8h]=5354h
 [802468Ah]=5354h
 [802468Ah]=5678h, repeated 500 times
 [930ECA8h]=5354h
 [802468Ah]=5354h
 [8ECA800h]=5678h
 [80268A0h]=1234h
 [802468Ah]=ABCDh, repeated 500 times
 [930ECA8h]=5354h
 [adr]=val
</PRE></TD></TR></TBODY></TABLE><BR><B>init_backup: 
 ;no info how to use that exactly</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> configure_flashcard(942468Ah,???)
</PRE></TD></TR></TBODY></TABLE><BR><B>device_list: 
 (id code, total/erase/write sizes in bytes)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  ID Code    Total   Erase  Write  Name
  -??-00DCh      ?       ?      ?  Hudson Cart (???)
  00160089h     4M    128K     32  Intel i28F320J3A (Flash Advance)
  00170089h     8M    128K     32  Intel i28F640J3A (Flash Advance)
  00180089h    16M    128K     32  Intel i28F128J3A (Flash Advance)
  00E200B0h      ?     64K      2  Sharp LH28F320BJE ? (Nintendo)
</PRE></TD></TR></TBODY></TABLE><BR><B>Notes</B><BR>
All flashcards should work at 4,2 waitstates (power on default), most commercial 
games change waits to 3,1 which may work unstable with some/older FA flashcards. 
Intel FLASH specified to have a lifetime of 100,000 erases, and average block 
erase time 1 second (up to 5 second in worst cases).<BR>Aside from the main 
FLASH memory, Flash Advance (FA) (aka Visoly) cards additionally contain battery 
buffered SRAM backup, and FLASH backup, and in some cases also EEPROM 
backup.<BR>Turbo FA cards are containing two chips interlaced (at odd/even 
halfword addresses), allowing to write/erase both chips simultaneously, 
resulting in twice as fast programming time.<BR>Standard Nintendo flash carts 
have to be modified before you can actually write to them. This is done by 
removing resistor R7 and putting it at empty location R8.<BR>Mind that 
write/erase/detect modes output status information in ROM area, so that in that 
modes all GBA program code (and any interrupt handlers) must be executed in 
WRAM, not in ROM.<BR><BR>Thanks to Jeff Frohwein for his FAQ and CARTLIB sample 
in FLGBA at devrs.com<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cheatdevices"></A><FONT size="+2">&nbsp;Cheat 
    Devices</FONT></TD></TR></TBODY></TABLE><BR>Codebreaker (US) aka Xploder 
(EUR).<BR>Gameshark (US) aka Action Replay (EUR).<BR><BR><A href="#cheatcodesgeneralinfo">Cheat 
Codes - General Info</A><BR><A href="#cheatcodescodebreakerxploder">Cheat 
Codes - Codebreaker/Xploder</A><BR><A href="#cheatcodesgamesharkactionreplayv1v2">Cheat 
Codes - Gameshark/Action Replay V1/V2</A><BR><A href="#cheatcodesproactionreplayv3">Cheat 
Codes - Pro Action Replay V3</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cheatcodesgeneralinfo"></A><FONT size="+2">&nbsp;Cheat Codes 
      - General Info</FONT></TD></TR></TBODY></TABLE><BR>Cheat devices are external 
adapters, connected between the GBA and the game cartridge. The devices include 
a BIOS ROM which is, among others, used to prompt the user to enter cheat 
codes.<BR>These codes are used to patch specified memory locations for a certain 
GBA game, allowing the user to gain goodies such like Infinite sex, 255
 Cigarettes, etc.<BR><BR><B>ROM and RAM Patches</B><BR>For ROM Patches, the 
device watches the address bus, if it matches a specified address then it 
outputs a patched value to the data bus, that mechanism is implemented by 
hardware, aside from the Hook Enable Code some devices also allow a limited 
number of cheats to use ROM patches.<BR>Most cheat codes are RAM patches, each 
time when the hook procedure is executed it will process all codes and overwrite 
the specified addresses in RAM (or VRAM or I/O area) by the desired 
values.<BR><BR><B>Enable Codes (Must Be On)</B><BR>Enable codes usually consist 
of the Game ID, Hook Address, and eventually a third code used to encrypt all 
following codes. The Game ID is used to confirm that the correct cartridge is 
inserted, just a verification, though the device may insist on the ID code.<BR>
The Hook Address specifies an address in cartridge ROM, and should point to an 
opcode which is executed several times per second (eg. once per frame, many 
codes place the hook in the joypad handler). At the hook address, the device 
redirects to its own BIOS, processes the RAM patches, and does then return 
control to the game cartridge.<BR>Note: The hook address should not point to 
opcodes with relative addressing (eg. B, BL, LDR Rd,=Imm, ADD Rd,=Imm opcodes - 
which are all relative to PC program counter 
register).<BR><BR><B>Alignment</B><BR>Addresses for 16bit or 32bit values should 
be properly aligned.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cheatcodescodebreakerxploder"></A><FONT size="+2">&nbsp;Cheat 
      Codes - Codebreaker/Xploder</FONT></TD></TR></TBODY></TABLE><BR><B>Codebreaker 
Codes</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0000xxxx 000y  Enable Code 1 - Game ID
  1aaaaaaa 000z  Enable Code 2 - Hook Address
  2aaaaaaa yyyy  [aaaaaaa]=[aaaaaaa] OR yyyy
  3aaaaaaa 00yy  [aaaaaaa]=yy
  4aaaaaaa yyyy  [aaaaaaa...]=yyyy repeated by parameters in next code
  cccccccc ssss  repeat count and address step parameters for above code
  5aaaaaaa xxxx  Write block (SUPER CODE)
  ........ ....  parameters for above code
  6aaaaaaa yyyy  [aaaaaaa]=[aaaaaaa] AND yyyy
  7aaaaaaa yyyy  IF [aaaaaaa]=yyyy THEN (next code)
  8aaaaaaa yyyy  [aaaaaaa]=yyyy
  9xyyxxxx xxxx  Enable Code 0 - Encrypt all following codes (optional)
  Aaaaaaaa yyyy  IF [aaaaaaa]&lt;&gt;yyyy THEN (next code)
  Baaaaaaa yyyy  IF [aaaaaaa]&gt;yyyy THEN (next code) (signed comparison)
  Caaaaaaa yyyy  IF [aaaaaaa]&lt;yyyy THEN (next code) (signed comparison)
  D0000020 yyyy  IF [joypad] AND yyyy = 0 THEN (next code)
  Eaaaaaaa yyyy  [aaaaaaa]=[aaaaaaa]+yyyy
  Faaaaaaa yyyy  IF [aaaaaaa] AND yyyy THEN (next code)
</PRE></TD></TR></TBODY></TABLE><BR><B>Codebreaker 
Enable Codes</B><BR>Hook Address 'aaaaaaa' is a 25bit offset in ROM-image 
(0-1FFFFFFh).<BR>Flag byte 'y' (usually 0Ah), Bit1=Disable IRQs, Bit3=CRC 
Exists.<BR>Code Handler Store Address 'z' (0-7, usually 7) 
(8000100h+z*400000h).<BR>Checksum 'xxxx' for first 64Kbytes of cartridge (no$gba 
pads by FFh if ROM is smaller than 64K). Calculated, by using unsigned 16bit 
values, as such:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  CRC=0FFFFh
  FOR Y=0 to 0FFFFh
   X=BYTE[Y] xor (CRC/100h)
   X=X xor (X/10h)
   CRC=(CRC*100h) xor (X*1001h) xor (X*20h)
  NEXT Y
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cheatcodesgamesharkactionreplayv1v2"></A><FONT 
      size="+2">&nbsp;Cheat Codes - Gameshark/Action Replay 
  V1/V2</FONT></TD></TR></TBODY></TABLE><BR><B>Gameshark RAW Codes (These codes 
must be encrypted before using them)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0aaaaaaa 000000xx  [aaaaaaa]=xx
  1aaaaaaa 0000xxxx  [aaaaaaa]=xxxx
  2aaaaaaa xxxxxxxx  [aaaaaaa]=xxxxxxxx
  3000cccc xxxxxxxx  write xxxxxxxx to (cccc-1) addresses (list in next codes)
  aaaaaaaa aaaaaaaa  parameter for above code, containing two addresses each
  aaaaaaaa 00000000  last parameter for above, zero-padded if only one address
  60aaaaaa y000xxxx  [8000000h+aaaaaa*2]=xxxx (ROM Patch)
  8a1aaaaa 000000xx  IF GS_Button_Down THEN [a0aaaaa]=xx
  8a2aaaaa 0000xxxx  IF GS_Button_Down THEN [a0aaaaa]=xxxx
  80F00000 0000xxxx  IF GS_Button_Down THEN slowdown xxxx * ??? cycles per hook
  Daaaaaaa 0000xxxx  IF [aaaaaaa]=xxxx THEN (next code)
  E0zzxxxx 0aaaaaaa  IF [aaaaaaa]=xxxx THEN (next 'zz' codes)
  Faaaaaaa 00000x0y  Enable Code - Hook Routine
  xxxxxxxx 001DC0DE  Enable Code - Game Code ID (value at [0ACh] in cartridge)
  DEADFACE 0000xxxx  Change Encryption Seeds
</PRE></TD></TR></TBODY></TABLE><BR><B>Enable 
Code - Hook Routine</B><BR>Hook Address 'aaaaaaa' is a 28bit ROM address 
(8FFFFFFh-9FFFFFFh).<BR>Used to insert the GS code handler routine where it will 
be executed at<BR>least 20 times per second. Without this code, GSA can not 
write to RAM.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> y=1 - Executes code handler without backing up the LR register.
 y=2 - Executes code handler and backs up the LR register.
 y=3 - Replaces a 32-bit pointer used for long-branches.
 x=0 - Must turn GSA off before loading game.
 x=1 - Must not do that.
</PRE></TD></TR></TBODY></TABLE><BR><B>ROM 
Patch</B><BR>This type allows GSA to intercept ROM reads and returns the value 
xxxx. 
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> y=0 wait for the code handler to enable the patch
 y=1 patch is enabled before the game starts
 y=2 unknown ???
</PRE></TD></TR></TBODY></TABLE>Note: 
V1/V2 hardware can only have up to 1 user-defined rom patch max. V3 can have up 
to 4. Some enable code types can shorten the amount of user-defined rom patches 
available.<BR><BR><B>Gameshark Encryption</B><BR>A=Left half, and V=Right half 
of code.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  IF V1V2 THEN S0=09F4FBBDh S1=9681884Ah S2=352027E9h S3=F3DEE5A7h
  IF V3   THEN S0=7AA9648Fh S1=7FAE6994h S2=C0EFAAD5h S3=42712C57h
  FOR I=1 TO 32
    A=A + (V*16+S0) XOR (V+I*9E3779B9h) XOR (V/32+S1)
    V=V + (A*16+S2) XOR (A+I*9E3779B9h) XOR (A/32+S3)
  NEXT I
</PRE></TD></TR></TBODY></TABLE>All 
calculations truncated to unsigned 32bit integer values.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cheatcodesproactionreplayv3"></A><FONT size="+2">&nbsp;Cheat 
      Codes - Pro Action Replay V3</FONT></TD></TR></TBODY></TABLE><BR><B>Pro Action 
Replay V3 - RAW Codes</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  C4aaaaaa 0000yyyy  Enable Code - Hook Routine at [8aaaaaa]
  xxxxxxxx 001DC0DE  Enable Code - ID Code [080000AC]
  DEADFACE 0000xxxx  Enable Code - Change Encryption Seeds
  00aaaaaa xxxxxxyy  [a0aaaaa..a0aaaaa+xxxxxx]=yy
  02aaaaaa xxxxyyyy  [a0aaaaa..a0aaaaa+xxxx*2]=yyyy
  04aaaaaa yyyyyyyy  [a0aaaaa]=yyyyyyyy
  40aaaaaa xxxxxxyy  [ [a0aaaaa] + xxxxxx ]=yy   (Indirect)
  42aaaaaa xxxxyyyy  [ [a0aaaaa] + xxxx*2 ]=yyyy (Indirect)
  44aaaaaa yyyyyyyy  [ [a0aaaaa] ]=yyyyyyyy      (Indirect)
  80aaaaaa 000000yy  [a0aaaaa]=[a0aaaaa]+yy
  82aaaaaa 0000yyyy  [a0aaaaa]=[a0aaaaa]+yyyy
  84aaaaaa yyyyyyyy  [a0aaaaa]=[a0aaaaa]+yyyyyyyy
  C6aaaaaa 0000yyyy  [4aaaaaa]=yyyy              (I/O Area)
  C7aaaaaa yyyyyyyy  [4aaaaaa]=yyyyyyyy          (I/O Area)
  iiaaaaaa yyyyyyyy  IF [a0aaaaa] &lt;cond&gt; &lt;value&gt; THEN &lt;action&gt;
  00000000 60000000  ELSE (?)
  00000000 40000000  ENDIF (?)
  00000000 0800xx00  AR Slowdown : loops the AR xx times
  00000000 00000000  End of the code list
  00000000 10aaaaaa 000000zz 00000000  IF AR_BUTTON THEN [a0aaaaa]=zz
  00000000 12aaaaaa 0000zzzz 00000000  IF AR_BUTTON THEN [a0aaaaa]=zzzz
  00000000 14aaaaaa zzzzzzzz 00000000  IF AR_BUTTON THEN [a0aaaaa]=zzzzzzzz
  00000000 18aaaaaa 0000zzzz 00000000  [8000000+aaaaaa*2]=zzzz  (ROM Patch 1)
  00000000 1Aaaaaaa 0000zzzz 00000000  [8000000+aaaaaa*2]=zzzz  (ROM Patch 2)
  00000000 1Caaaaaa 0000zzzz 00000000  [8000000+aaaaaa*2]=zzzz  (ROM Patch 3)
  00000000 1Eaaaaaa 0000zzzz 00000000  [8000000+aaaaaa*2]=zzzz  (ROM Patch 4)
</PRE></TD></TR></TBODY></TABLE><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  00000000 80aaaaaa 000000yy ssccssss  repeat cc times [a0aaaaa]=yy
   (with yy=yy+ss, a0aaaaa=a0aaaaa+ssss after each step)
</PRE></TD></TR></TBODY></TABLE><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  00000000 82aaaaaa 0000yyyy ssccssss  repeat cc times [a0aaaaa]=yyyy
   (with yyyy=yyyy+ss, a0aaaaa=a0aaaaa+ssss*2 after each step)
</PRE></TD></TR></TBODY></TABLE><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  00000000 84aaaaaa yyyyyyyy ssccssss  repeat cc times [a0aaaaa]=yyyyyyyy
   (with yyyy=yyyy+ss, a0aaaaa=a0aaaaa+ssss*4 after each step)
</PRE></TD></TR></TBODY></TABLE><BR>
Warning: There is a bug on the real AR (v2 upgraded to v3, and maybe on real v3) 
with the 32bit Increment Slide code. You HAVE to add a code (best choice is 
80000000 00000000 : add 0 to value at address 0) right after it, else the AR 
will erase the 2 last 8 digits lines of the 32 Bits Inc. Slide code when you 
enter it !!!<BR><BR>Final Notes<BR>The 'turn off all codes' makes an infinite 
loop (that can't be broken, unless the condition becomes True). - How? By 
Interrupt? Huh?<BR>ROM Patch1 works on real V3 and, on V1/V2 upgraded to V3.<BR>
ROM Patch2,3,4 work on real V3 hardware only.<BR><BR><B>Pro Action Replay V3 
Conditional Codes - iiaaaaaa yyyyyyyy</B><BR>The 'ii' is composed of 
&lt;cond&gt; + &lt;value&gt; + &lt;action&gt;.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  &lt;cond&gt;           &lt;value&gt;            &lt;action&gt;
  08 Equal =       00 8bit zz         00 execute next code
  10 Not equal &lt;&gt;  02 16bit zzzz      40 execute next two codes
  18 Signed &lt;      04 32bit zzzzzzzz  80 execute all following
  20 Signed &gt;      06 (always false)     codes until ELSE or ENDIF
  28 Unsigned &lt;                       C0 normal ELSE turn off all codes
  30 Unsigned &gt;
  38 Logical AND
</PRE></TD></TR></TBODY></TABLE>For 
example, ii=18h+02h+40h=5Ah, produces IF [a0aaaaa]&lt;zzzz THEN next 2 
codes.<BR><BR>Always... Codes<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  For the "Always..." codes:
  - XXXXXXXX can be any authorised address except 00000000 (eg. use 02000000).
  - ZZZZZZZZ can be anything.
  - The "y" in the code data must be in the [1-7] range (which means not 0).
  typ=y,sub=0,siz=3   Always skip next line.
  typ=y,sub=1,siz=3   Always skip next 2 lines.
  typ=y,sub=2,siz=3   Always Stops executing all the codes below.
  typ=y,sub=3,siz=3   Always turn off all codes.
</PRE></TD></TR></TBODY></TABLE><BR><B>Code 
Format (ttaaaaaa xxxxyyzz)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> adr mask = 003FFFFF
 n/a mask = 00C00000 ;not used
 xtr mask = 01000000 ;used only by I/O write, and MSB of Hook
 siz mask = 06000000
 typ mask = 38000000 ;0=normal, other=conditional
 sub mask = C0000000
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="biosfunctions"></A><FONT size="+2">&nbsp;BIOS 
    Functions</FONT></TD></TR></TBODY></TABLE><BR>The GBA BIOS includes several 
System Call Functions which can be accessed by SWI instructions. Incoming 
parameters are usually passed through registers R0,R1,R2,R3. Outgoing registers 
R0,R1,R3 are typically containing either garbage, or return value(s). All other 
registers (R2,R4-R14) are kept unchanged.<BR><BR><B>Caution</B><BR>When invoking 
SWIs from inside of ARM state specify SWI NN*10000h, instead of SWI NN as in 
THUMB state.<BR><BR><B>Overview</B><BR><A href="#biosfunctionsummary">BIOS 
Function Summary</A><BR><A href="#biosdifferencesbetweengbaandndsfunctions">BIOS 
Differences between GBA and NDS functions</A><BR><BR><B>All Functions 
Described</B><BR><A href="#biosarithmeticfunctions">BIOS 
Arithmetic Functions</A><BR><A href="#biosrotationscalingfunctions">BIOS 
Rotation/Scaling Functions</A><BR><A href="#biosdecompressionfunctions">BIOS 
Decompression Functions</A><BR><A href="#biosmemorycopy">BIOS 
Memory Copy</A><BR><A href="#bioshaltfunctions">BIOS 
Halt Functions</A><BR><A href="#biosresetfunctions">BIOS 
Reset Functions</A><BR><A href="#biosmiscfunctions">BIOS 
Misc Functions</A><BR><A href="#biosmultibootsinglegamepak">BIOS 
Multi Boot (Single Game Pak)</A><BR><A href="#biossoundfunctions">BIOS 
Sound Functions</A><BR><BR><B>How BIOS Processes SWIs</B><BR>SWIs can be called 
from both within THUMB and ARM mode. In ARM mode, only the upper 8bit of the 
24bit comment field are interpreted.<BR>Each time when calling a BIOS function 4 
words (SPSR, R11, R12, R14) are saved on Supervisor stack (_svc). Once it has 
saved that data, the SWI handler switches into System mode, so that all further 
stack operations are using user stack.<BR>In some cases the BIOS may allow 
interrupts to be executed from inside of the SWI procedure. If so, and if the 
interrupt handler calls further SWIs, then care should be taken that the 
Supervisor Stack does not overflow.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="biosfunctionsummary"></A><FONT size="+2">&nbsp;BIOS Function 
      Summary</FONT></TD></TR></TBODY></TABLE><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE><B>  GBA  NDS7 NDS9 Function</B>
  00h  00h  00h  SoftReset
  01h  -    -    RegisterRamReset
  02h  06h  06h  Halt
  03h  07h  -    Stop/Sleep
  04h  04h  04h  IntrWait
  05h  05h  05h  VBlankIntrWait
  06h  09h  09h  Div
  07h  -    -    DivArm
  08h  0Dh  0Dh  Sqrt
  09h  -    -    ArcTan
  0Ah  -    -    ArcTan2
  0Bh  0Bh  0Bh  CpuSet
  0Ch  0Ch  0Ch  CpuFastSet
  0Dh  -    -    GetBiosChecksum
  0Eh  -    -    BgAffineSet
  0Fh  -    -    ObjAffineSet
  10h  10h  10h  BitUnPack
  11h  11h  11h  LZ77UnCompWram
  12h  12h  12h  LZ77UnCompVram
  13h  13h  13h  HuffUnComp
  14h  14h  14h  RLUnCompWram
  15h  15h  15h  RLUnCompVram
  16h  -    16h  Diff8bitUnFilterWram
  17h  -    -    Diff8bitUnFilterVram
  18h  -    18h  Diff16bitUnFilter
  19h  08h  -    SoundBias
  1Ah  -    -    SoundDriverInit
  1Bh  -    -    SoundDriverMode
  1Ch  -    -    SoundDriverMain
  1Dh  -    -    SoundDriverVSync
  1Eh  -    -    SoundChannelClear
  1Fh  -    -    MidiKey2Freq
  20h  -    -    SoundWhatever0
  21h  -    -    SoundWhatever1
  22h  -    -    SoundWhatever2
  23h  -    -    SoundWhatever3
  24h  -    -    SoundWhatever4
  25h  -    -    MultiBoot
  26h  -    -    HardReset
  27h  1Fh  -    CustomHalt
  28h  -    -    SoundDriverVSyncOff
  29h  -    -    SoundDriverVSyncOn
  2Ah  -    -    SoundGetJumpList
  -    03h  03h  WaitByLoop
  -    0Eh  0Eh  GetCRC16
  -    0Fh  0Fh  IsDebugger
  -    1Ah  -    GetSineTable
  -    1Bh  -    GetPitchTable
  -    1Ch  -    GetVolumeTable
  -    1Dh  -    GetBootProcs
  -    -    1Fh  CustomPost
</PRE></TD></TR></TBODY></TABLE>The 
BIOS SWI handler does not perform any range checks, so calling GBA SWI 2Bh-FFh 
or NDS SWI 20h-FFh will blindly jump to garbage addresses.<BR>Also, NDS7 SWI 
01h, 02h, 0Ah, 16h-19h, 1Eh, and NDS9 SWI 01h, 02h, 07h, 08h, 0Ah, 17h, 19h-1Eh 
will jump to zero (ie. the NDS7 reset vector, or NDS9 unused memory, which will 
be both redirected to the debug handler, if any).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="biosdifferencesbetweengbaandndsfunctions"></A><FONT 
      size="+2">&nbsp;BIOS Differences between GBA and NDS 
  functions</FONT></TD></TR></TBODY></TABLE><BR><B>Differences between GBA and NDS 
BIOS functions</B><BR>- SoftReset uses different addresses<BR>- SWI numbers for 
Halt, Stop/Sleep, Div, Sqrt have changed<BR>- Halt destroys r0 on NDS9, IntrWait 
bugged on NDS9<BR>- CpuFastSet allows 4-byte blocks (nice), but...<BR>- 
CpuFastSet works very SLOW because of a programming bug (uncool)<BR>- 
LZ77UnCompVram, HuffUnComp, RLUnCompVram use callbacks<BR>- SoundBias uses new 
delay parameter<BR>And, a number of GBA functions have been removed, and some 
new NDS functions have been added, see:<BR><A href="#biosfunctionsummary">BIOS 
Function Summary</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="biosarithmeticfunctions"></A><FONT size="+2">&nbsp;BIOS 
      Arithmetic Functions</FONT></TD></TR></TBODY></TABLE><BR>Div<BR>DivArm<BR>
Sqrt<BR>ArcTan<BR>ArcTan2<BR><BR><B>SWI 06h (GBA) or SWI 09h (NDS7/NDS9) - 
Div</B><BR>Signed Division, r0/r1.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  signed 32bit Number
  r1  signed 32bit Denom
</PRE></TD></TR></TBODY></TABLE>Return:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Number DIV Denom ;signed
  r1  Number MOD Denom ;signed
  r3  ABS (Number DIV Denom) ;unsigned
</PRE></TD></TR></TBODY></TABLE>For 
example, incoming -1234, 10 should return -123, -4, +123.<BR>The function 
usually gets caught in an endless loop upon division by zero.<BR>Note: The NDS9 
additionally supports hardware division, by math coprocessor, accessed via I/O 
Ports, however, the SWI function is a raw software division.<BR><BR><B>SWI 07h 
(GBA) - DivArm</B><BR>Same as above (SWI 06h Div), but incoming parameters are 
exchanged, r1/r0 (r0=Denom, r1=number). For compatibility with ARM's library. 
Slightly slower (3 clock cycles) than SWI 06h.<BR><BR><B>SWI 08h (GBA) or SWI 
0Dh (NDS7/NDS9) - Sqrt</B><BR>Calculate square root.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0   unsigned 32bit number
</PRE></TD></TR></TBODY></TABLE>Return:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0   unsigned 16bit number
</PRE></TD></TR></TBODY></TABLE>The result is 
an integer value, so Sqrt(2) would return 1, to avoid this inaccuracy, shift 
left incoming number by 2*N as much as possible (the result is then shifted left 
by 1*N). Ie. Sqrt(2 shl 30) would return 1.41421 shl 15.<BR>Note: The NDS9 
additionally supports hardware square root calculation, by math coprocessor, 
accessed via I/O Ports, however, the SWI function is a raw software 
calculation.<BR><BR><B>SWI 09h (GBA) - ArcTan</B><BR>Calculates the arc 
tangent.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0   Tan, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
</PRE></TD></TR></TBODY></TABLE>Return:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0   "-PI/2&lt;THETA/&lt;PI/2" in a range of C000h-4000h.
</PRE></TD></TR></TBODY></TABLE>Note: 
there is a problem in accuracy with "THETA&lt;-PI/4, 
PI/4&lt;THETA".<BR><BR><B>SWI 0Ah (GBA) - ArcTan2</B><BR>Calculates the arc 
tangent after correction processing.<BR>Use this in normal situations.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0   X, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
  r1   Y, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
</PRE></TD></TR></TBODY></TABLE>Return:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0   0000h-FFFFh for 0&lt;=THETA&lt;2PI.
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="biosrotationscalingfunctions"></A><FONT size="+2">&nbsp;BIOS 
      Rotation/Scaling Functions</FONT></TD></TR></TBODY></TABLE><BR>BgAffineSet<BR>
ObjAffineSet<BR><BR><B>SWI 0Eh (GBA) - BgAffineSet</B><BR>Used to calculate BG 
Rotation/Scaling parameters.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0   Pointer to Source Data Field with entries as follows:
        s32  Original data's center X coordinate (8bit fractional portion)
        s32  Original data's center Y coordinate (8bit fractional portion)
        s16  Display's center X coordinate
        s16  Display's center Y coordinate
        s16  Scaling ratio in X direction (8bit fractional portion)
        s16  Scaling ratio in Y direction (8bit fractional portion)
        u16  Angle of rotation (8bit fractional portion) Effective Range 0-FFFF
  r1   Pointer to Destination Data Field with entries as follows:
        s16  Difference in X coordinate along same line
        s16  Difference in X coordinate along next line
        s16  Difference in Y coordinate along same line
        s16  Difference in Y coordinate along next line
        s32  Start X coordinate
        s32  Start Y coordinate
  r2   Number of Calculations
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value, Data written to destination address.<BR><BR><B>SWI 0Fh (GBA) - 
ObjAffineSet</B><BR>Calculates and sets the OBJ's affine parameters from the 
scaling ratio and angle of rotation.<BR>The affine parameters are calculated 
from the parameters set in Srcp.<BR>The four affine parameters are set every 
Offset bytes, starting from the Destp address.<BR>If the Offset value is 2, the 
parameters are stored contiguously. If the value is 8, they match the structure 
of OAM.<BR>When Srcp is arrayed, the calculation can be performed continuously 
by specifying Num.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0   Source Address, pointing to data structure as such:
        s16  Scaling ratio in X direction (8bit fractional portion)
        s16  Scaling ratio in Y direction (8bit fractional portion)
        u16  Angle of rotation (8bit fractional portion) Effective Range 0-FFFF
  r1   Destination Address, pointing to data structure as such:
        s16  Difference in X coordinate along same line
        s16  Difference in X coordinate along next line
        s16  Difference in Y coordinate along same line
        s16  Difference in Y coordinate along next line
  r2   Number of calculations
  r3   Offset in bytes for parameter addresses (2=continuous, 8=OAM)
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value, Data written to destination address.<BR><BR>For both Bg- and 
ObjAffineSet, Rotation angles are specified as 0-FFFFh (covering a range of 360 
degrees), however, the GBA BIOS recurses only the upper 8bit; the lower 8bit may 
contain a fractional portion, but it is ignored by the BIOS.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="biosdecompressionfunctions"></A><FONT size="+2">&nbsp;BIOS 
      Decompression Functions</FONT></TD></TR></TBODY></TABLE><BR>BitUnPack<BR>
Diff8bitUnFilterWram<BR>Diff8bitUnFilterVram<BR>Diff16bitUnFilter<BR>
HuffUnComp<BR>LZ77UnCompWram<BR>LZ77UnCompVram<BR>RLUnCompVram<BR>
RLUnCompWram<BR><BR><B>SWI 10h (GBA/NDS7/NDS9) - BitUnPack</B><BR>Used to 
increase the color depth of bitmaps or tile data. For example, to convert a 1bit 
monochrome font into 4bit or 8bit GBA tiles. The Unpack Info is specified 
separately, allowing to convert the same source data into different formats.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Source Address      (no alignment required)
  r1  Destination Address (must be 32bit-word aligned)
  r2  Pointer to UnPack information:
       16bit  Length of Source Data in bytes     (0-FFFFh)
       8bit   Width of Source Units in bits      (only 1,2,4,8 supported)
       8bit   Width of Destination Units in bits (only 1,2,4,8,16,32 supported)
       32bit  Data Offset (Bit 0-30), and Zero Data Flag (Bit 31)
      The Data Offset is always added to all non-zero source units.
      If the Zero Data Flag was set, it is also added to zero units.
</PRE></TD></TR></TBODY></TABLE>Data 
is written in 32bit units, Destination can be Wram or Vram. The size of unpacked 
data must be a multiple of 4 bytes. The width of source units (plus the offset) 
should not exceed the destination width.<BR>Return: No return value, Data 
written to destination address.<BR><BR><B>SWI 16h (GBA/NDS9) - 
Diff8bitUnFilterWram</B><BR><B>SWI 17h (GBA) - 
Diff8bitUnFilterVram</B><BR><B>SWI 18h (GBA/NDS9) - Diff16bitUnFilter</B><BR>
These aren't actually real decompression functions, destination data will have 
exactly the same size as source data. However, assume a bitmap or wave form to 
contain a stream of increasing numbers such like 10..19, the filtered/unfiltered 
data would be:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  unfiltered:   10  11  12  13  14  15  16  17  18  19
  filtered:     10  +1  +1  +1  +1  +1  +1  +1  +1  +1
</PRE></TD></TR></TBODY></TABLE>In 
this case using filtered data (combined with actual compression algorithms) will 
obviously produce better compression results.<BR>Data units may be either 8bit 
or 16bit used with Diff8bit or Diff16bit functions respectively. The 8bitVram 
function allows to write to VRAM directly (which uses 16bit data bus) by writing 
two 8bit values at once, the downside is that it is eventually slower as the 
8bitWram function.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Source address (must be aligned by 4) pointing to data as follows:
       Data Header (32bit)
         Bit 0-3   Data size (must be 1 for Diff8bit, 2 for Diff16bit)
         Bit 4-7   Type (must be 8 for DiffFiltered)
         Bit 8-31  24bit size after decompression
       Data Units (each 8bit or 16bit depending on used SWI function)
         Data0          ;original data
         Data1-Data0    ;difference data
         Data2-Data1    ;...
         Data3-Data2
         ...
  r1  Destination address
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value, Data written to destination address.<BR><BR><B>SWI 13h 
(GBA/NDS7/NDS9) - HuffUnComp (NDS: with Callback)</B><BR>Expands 
Huffman-compressed data and writes in units of 32bits.<BR>If the size of the 
compressed data is not a multiple of 4, please adjust it as much as possible by 
padding with 0.<BR>Align the source address to a 4Byte boundary.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Source Address, aligned by 4, pointing to:
       Data Header (32bit)
         Bit 0-3   Data size in bit units (normally 4 or 8)
         Bit 4-7   Compressed type (must be 2 for Huffman)
         Bit 8-31  24bit size of decompressed data in bytes
       Tree Table
        u8      tree table size/2-1
        Each of the nodes below defined as:
         u8
          6bit  offset to next node -1 (2 byte units)
          1bit  right node end flag (if set, data is in next node)
          1bit  left node end flag
        1 node  Root node
        2 nodes Left, and Right node
        4 nodes LeftLeft, LeftRight, RightLeft, and RightRight node
        ...
       Compressed data
        ...
  r1  Destination Address
  r2  Callback parameter (NDS SWI 13h only, see Callback notes below)
  r3  Callback structure (NDS SWI 13h only, see Callback notes below)
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value, Data written to destination address.<BR><BR><B>SWI 11h 
(GBA/NDS7/NDS9) - LZ77UnCompWram</B><BR><B>SWI 12h (GBA/NDS7/NDS9) - 
LZ77UnCompVram (NDS: with Callback)</B><BR>Expands LZ77-compressed data. The 
Wram function is faster, and writes in units of 8bits. For the Vram function the 
destination must be halfword aligned, data is written in units of 16bits.<BR>If 
the size of the compressed data is not a multiple of 4, please adjust it as much 
as possible by padding with 0. Align the source address to a 4-Byte 
boundary.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0   Source address, pointing to data as such:
        Data header (32bit)
          Bit 0-3   Reserved
          Bit 4-7   Compressed type (must be 1 for LZ77)
          Bit 8-31  Size of decompressed data
        Repeat below. Each Flag Byte followed by eight Blocks.
        Flag data (8bit)
          Bit 0-7   Type Flags for next 8 Blocks, MSB first
        Block Type 0 - Uncompressed - Copy 1 Byte from Source to Dest
          Bit 0-7   One data byte to be copied to dest
        Block Type 1 - Compressed - Copy N+3 Bytes from Dest-Disp-1 to Dest
          Bit 0-3   Disp MSBs
          Bit 4-7   Number of bytes to copy (minus 3)
          Bit 8-15  Disp LSBs
  r1   Destination address
  r2  Callback parameter (NDS SWI 12h only, see Callback notes below)
  r3  Callback structure (NDS SWI 12h only, see Callback notes below)
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value.<BR><BR><B>SWI 14h (GBA/NDS7/NDS9) - RLUnCompWram</B><BR><B>SWI 
15h (GBA/NDS7/NDS9) - RLUnCompVram (NDS: with Callback)</B><BR>Expands 
run-length compressed data. The Wram function is faster, and writes in units of 
8bits. For the Vram function the destination must be halfword aligned, data is 
written in units of 16bits.<BR>If the size of the compressed data is not a 
multiple of 4, please adjust it as much as possible by padding with 0. Align the 
source address to a 4Byte boundary.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Source Address, pointing to data as such:
       Data header (32bit)
         Bit 0-3   Reserved
         Bit 4-7   Compressed type (must be 3 for run-length)
         Bit 8-31  Size of decompressed data
       Repeat below. Each Flag Byte followed by one or more Data Bytes.
       Flag data (8bit)
         Bit 0-6   Expanded Data Length (uncompressed N-1, compressed N-3)
         Bit 7     Flag (0=uncompressed, 1=compressed)
       Data Byte(s) - N uncompressed bytes, or 1 byte repeated N times
  r1  Destination Address
  r2  Callback parameter (NDS SWI 15h only, see Callback notes below)
  r3  Callback structure (NDS SWI 15h only, see Callback notes below)
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value, Data written to destination address.<BR><BR><B>NDS 
Decompression Callbacks</B><BR>On NDS7/NDS9, the SWI 12h, 13h, 15h functions are 
reading source data from callback functions (rather than directly from memory). 
The callback functions may read normal data from memory, or from other devices, 
such like directly from the gamepak bus, without storing the source data in 
memory. The downside is that the callback mechanism makes the function very 
slow, furthermore, NDS7/NDS9 SWI 12h, 13h, 15h are using THUMB code, and 
variables on stack, alltogether that makes the whole shit very-very-very 
slow.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r2 = user defined callback parameter (passed on to Open function)
  r3 = pointer to callback structure
</PRE></TD></TR></TBODY></TABLE>Callback 
structure (five 32bit pointers to callback functions)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Open_and_get_32bit (eg. LDR r0,[r0], get header)
  Close              (optional, 0=none)
  Get_8bit           (eg. LDRB r0,[r0])
  Get_16bit          (not used)
  Get_32bit          (used by Huffman only)
</PRE></TD></TR></TBODY></TABLE>All 
functions may use ARM or THUMB code (indicated by address bit0). The current 
source address (r0) is passed to all callback functions. Additionally, the 
initial destination address (r1), and a user defined parameter (r2) are passed 
to the Open function. All functions have return values in r0. The Open function 
normally returns the first word (containing positive length and type), 
alternatively it may return a negative error code to abort/reject decompression. 
The Close function, if it is defined, should return zero (or any positive 
value), or a negative errorcode. The other functions return raw data, without 
errorcodes. The SWI returns the length of decompressed data, or the signed 
errorcode from the Open/Close functions.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="biosmemorycopy"></A><FONT size="+2">&nbsp;BIOS Memory 
      Copy</FONT></TD></TR></TBODY></TABLE><BR>CpuFastSet<BR>CpuSet<BR><BR><B>SWI 0Ch 
(GBA/NDS7/NDS9) - CpuFastSet</B><BR>Memory copy/fill in units of 32 bytes. 
Memcopy is implemented as repeated LDMIA/STMIA [Rb]!,r2-r9 instructions. Memfill 
as single LDR followed by repeated STMIA [Rb]!,r2-r9. After processing all 
32-byte-blocks, the NDS additonally processes the remaining words as 4-byte 
blocks. BUG: The NDS uses the fast 32-byte-block processing only for the first N 
bytes (not for the first N words), so only the first quarter of the memory block 
is FAST, the remaining three quarters are SLOWLY copied word-by-word.<BR>The 
length is specifed as wordcount, ie. the number of bytes divided by 4.<BR>On the 
GBA, the length must be a multiple of 8 words (32 bytes). On NDS, the length may 
be any number of words (4 bytes).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0    Source address        (must be aligned by 4)
  r1    Destination address   (must be aligned by 4)
  r2    Length/Mode
          Bit 0-20  Wordcount (GBA: must be a multiple of 8 words)
          Bit 24    Fixed Source Address (0=Copy, 1=Fill by WORD[r0])
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value, Data written to destination address.<BR><BR><B>SWI 0Bh 
(GBA/NDS7/NDS9) - CpuSet</B><BR>Memory copy/fill in units of 4 bytes or 2 bytes. 
Memcopy is implemented as repeated LDMIA/STMIA [Rb]!,r3 or LDRH/STRH r3,[r0,r5] 
instructions. Memfill as single LDMIA or LDRH followed by repeated STMIA 
[Rb]!,r3 or STRH r3,[r0,r5].<BR>The length must be a multiple of 4 bytes (32bit 
mode) or 2 bytes (16bit mode). The (half)wordcount in r2 must be length/4 (32bit 
mode) or length/2 (16bit mode), ie. length in word/halfword units rather than
 byte units.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0    Source address        (must be aligned by 4 for 32bit, by 2 for 16bit)
  r1    Destination address   (must be aligned by 4 for 32bit, by 2 for 16bit)
  r2    Length/Mode
          Bit 0-20  Wordcount (for 32bit), or Halfwordcount (for 16bit)
          Bit 24    Fixed Source Address (0=Copy, 1=Fill by {HALF}WORD[r0])
          Bit 26    Datasize (0=16bit, 1=32bit)
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value, Data written to destination address.<BR><BR>Note: On GBA and 
NDS7, these two functions will silently reject to do anything if the source 
start or end addresses are reaching into the BIOS area. The NDS9 doesn't have 
such read-proctection.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="bioshaltfunctions"></A><FONT size="+2">&nbsp;BIOS Halt 
      Functions</FONT></TD></TR></TBODY></TABLE><BR>Halt<BR>IntrWait<BR>
VBlankIntrWait<BR>Stop/Sleep<BR>CustomHalt<BR><BR><B>SWI 02h (GBA) or SWI 06h 
(NDS7/NDS9) - Halt</B><BR>Halts the CPU until an interrupt request occurs. The 
CPU is switched into low-power mode, all other circuits (video, sound, timers, 
serial, keypad, system clock) are kept operating.<BR>Halt mode is terminated 
when any enabled interrupts are requested, that is when (IE AND IF) is not zero, 
the GBA locks up if that condition doesn't get true. However, the state of CPUs 
IRQ disable bit in CPSR register, and the IME register are don't care, Halt 
passes through even if either one has disabled interrupts.<BR>On GBA and NDS7, 
Halt is implemented by writing to HALTCNT, Port 4000301h. On NDS9, Halt is 
implemted by writing to System Control Coprocessor (mov p15,0,c7,c0,4,r0 
opcode), this opcode hangs if IME=0.<BR>No parameters, no return value.<BR>
(GBA/NDS7: all registers unchanged, NDS9: R0 destroyed)<BR><BR><B>SWI 04h 
(GBA/NDS7/NDS9) - IntrWait</B><BR>Continues to wait in Halt state until one (or 
more) of the specified interrupt(s) do occur. When using multiple interrupts at 
the same time, this function is having less overhead than repeatedly calling the 
Halt function.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0    0=Return immediately if an old flag was already set (NDS9: bugged!)
        1=Discard old flags, wait until a NEW flag becomes set
  r1    Interrupt flag(s) to wait for (same format as IE/IF registers)
</PRE></TD></TR></TBODY></TABLE>Caution: 
When using IntrWait or VBlankIntrWait, the user interrupt handler MUST update 
the BIOS Interrupt Flags value in RAM; when acknowleding processed interrupt(s) 
by writing a value to the IF register, the same value should be also ORed to the 
BIOS Interrupt Flags value, at following memory location:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Host     GBA (16bit)  NDS7 (32bit)  NDS9 (32bit)
  Address  [3007FF8h]   [380FFF8h]    [DTCM+3FF8h]
</PRE></TD></TR></TBODY></TABLE>NDS9: 
BUG: No Discard (r0=0) doesn't work. The function always waits for at least one 
IRQ to occur (no matter which, including IRQs that are not selected in r1), even 
if the desired flag was already set. NB. the same bug is also found in the 
GBA/NDS7 functions, but it's compensated by a second bug, ie. the GBA/NDS7 
functions are working okay because their "bug doesn't work".<BR>Return: No 
return value, the selected flag(s) are automatically reset in BIOS Interrupt 
Flags value in RAM upon return.<BR><BR><B>SWI 05h (GBA/NDS7/NDS9) - 
VBlankIntrWait</B><BR>Continues to wait in Halt status until a new V-Blank 
interrupt occurs.<BR>The function sets r0=1 and r1=1 and then executes IntrWait 
(SWI 04h), see IntrWait for details.<BR>No parameters, no return 
value.<BR><BR><B>SWI 03h (GBA) - Stop</B><BR>Switches the GBA into very low 
power mode (to be used similar as a screen-saver). The CPU, System Clock, Sound, 
Video, SIO-Shift Clock, DMAs, and Timers are stopped.<BR>Stop state can be 
terminated by the following interrupts only (as far as enabled in IE register): 
Joypad, Game Pak, or General-Purpose-SIO.<BR>"The system clock is stopped so the 
IF flag is not set."<BR>Preparation for Stop:<BR>Disable Video before 
implementing Stop (otherwise Video just freezes, but still keeps consuming 
battery power). Possibly required to disable Sound also ??? Obviously, it'd be 
also recommended to disable any external hardware (such like Rumble or 
Infra-Red) as far as possible.<BR>No parameters, no return value.<BR><BR><B>SWI 
07h (NDS7) - Sleep</B><BR>No info, probably similar as GBA SWI 03h (Stop). Sleep 
is implemented for NDS7 only, not for NDS9, not sure if the functions stops BOTH 
NDS7 and NDS9?<BR><BR><B>SWI 27h (GBA) or SWI 1Fh (NDS7) - CustomHalt 
(Undocumented)</B><BR>Writes the 8bit parameter value to HALTCNT, below values 
are equivalent to Halt and Stop/Sleep functions, other values reserved, purpose 
unknown.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r2  8bit parameter (GBA: 00h=Halt, 80h=Stop) (NDS7: 80h=Halt, C0h=Sleep)
</PRE></TD></TR></TBODY></TABLE>No 
return value.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="biosresetfunctions"></A><FONT size="+2">&nbsp;BIOS Reset 
      Functions</FONT></TD></TR></TBODY></TABLE><BR>SoftReset<BR>RegisterRamReset<BR>
HardReset<BR><BR><B>SWI 00h - SoftReset</B><BR>Clears 200h bytes of RAM 
(containing stacks, and BIOS IRQ vector/flags), initializes system, supervisor, 
and irq stack pointers, sets R0-R12, LR_svc, SPSR_svc, LR_irq, and SPSR_irq to 
zero, and enters system mode.<BR>Note that the NDS9 stack registers are 
hardcoded (the DTCM base should be set to the default setting of 0800000h). The 
NDS9 function additionally flushes caches and write buffer, and sets the CP15 
control register to 12078h.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Host  sp_svc    sp_irq    sp_sys    zerofilled area       return address
  GBA   3007FE0h  3007FA0h  3007F00h  [3007E00h..3007FFFh]  Flag[3007FFAh]
  NDS7  380FFDCh  380FFB0h  380FF00h  [380FE00h..380FFFFh]  Addr[27FFE34h]
  NDS9  0803FC0h  0803FA0h  0803EC0h  [DTCM+3E00h..3FFFh]   Addr[27FFE24h]
</PRE></TD></TR></TBODY></TABLE>The 
NDS7/NDS9 return addresses at [27FFE34h/27FFE24h] are usually containing copies 
of Cartridge Header [034h/024h] entry points, which may select ARM/THUMB state 
via bit0. The GBA return address 8bit flag is interpreted as 00h=8000000h (ROM), 
or 01h-FFh=2000000h (RAM), entered in ARM state.<BR>Note: The reset is applied 
only to the CPU that has executed the SWI (ie. on the NDS, the other CPU will 
remain unaffected).<BR>Return: Does not return to calling procedure, instead, 
loads the above return address into R14, and then jumps to that address by a "BX 
R14" opcode.<BR><BR><B>SWI 01h (GBA) - RegisterRamReset</B><BR>Resets the I/O 
registers and RAM specified in ResetFlags. However, it does not clear the CPU 
internal RAM area from 3007E00h-3007FFFh.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  ResetFlags
       Bit   Expl.
       0     Clear 256K on-board WRAM  ;-don't use when returning to WRAM
       1     Clear 32K in-chip WRAM    ;-excluding last 200h bytes
       2     Clear Palette
       3     Clear VRAM
       4     Clear OAM              ;-zerofilled! does NOT disable OBJs!
       5     Reset SIO registers    ;-switches to general purpose mode!
       6     Reset Sound registers
       7     Reset all other registers (except SIO, Sound)
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value.<BR>Bug: LSBs of SIODATA32 are always destroyed, even if Bit5 of 
R0 was cleared.<BR>The function always switches the screen into forced blank by 
setting DISPCNT=0080h (regardless of incoming R0, screen becomes 
white).<BR><BR><B>SWI 26h (GBA) - HardReset (Undocumented)</B><BR>This function 
reboots the GBA (including for getting through the time-consuming nintendo 
intro, which is making the function particularly useless and annoying).<BR>
Parameters: None. Return: Never/Reboot.<BR>Execution Time: About 2 seconds 
(!)<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="biosmiscfunctions"></A><FONT size="+2">&nbsp;BIOS Misc 
      Functions</FONT></TD></TR></TBODY></TABLE><BR>GetBiosChecksum<BR>WaitByLoop<BR>
GetCRC16<BR>IsDebugger<BR>GetSineTable<BR>GetPitchTable<BR>GetVolumeTable<BR>
CustomPost<BR>GetBootProcs<BR><BR><B>SWI 0Dh (GBA) - GetBiosChecksum 
(Undocumented)</B><BR>Calculates the checksum of the BIOS ROM (by reading in 
32bit units, and adding up these values). IRQ and FIQ are disabled during 
execution.<BR>The checksum is BAAE187Fh (GBA and GBA SP), or BAAE1880h (DS in 
GBA mode, whereas the only difference is that the byte at [3F0Ch] is changed 
from 00h to 01h, otherwise the BIOS is 1:1 same as GBA BIOS, it does even 
include multiboot code).<BR>Parameters: None. Return: r0=Checksum.<BR><BR><B>SWI 
03h (NDS7/NDS9) - WaitByLoop</B><BR>Performs a "LOP: SUB R0,1 / BGT LOP" wait 
loop, the loop is executed in BIOS memory, which provides reliable timings 
(regardless of the memory waitstates&amp; cache state of the calling procedure). 
Intended only for short delays (eg. flash memory programming cycles).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Delay value (should be in range 1..7FFFFFFFh)
</PRE></TD></TR></TBODY></TABLE>Execution 
Time: ARM7: R0*4 cycles, plus some overload on SWI handling.<BR>Execution Time: 
ARM9: Unknown, clock cycles for ARMv5 are unspecified?<BR>Return: No return 
value.<BR><BR><B>SWI 0Eh (NDS7/NDS9) - GetCRC16</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Initial CRC value (16bit, usually FFFFh)
  r1  Start Address   (must be aligned by 2)
  r2  Length in bytes (must be aligned by 2)
</PRE></TD></TR></TBODY></TABLE>CRC16 
checksums can be calculated as such:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  val[0..7] = C0C1h,C181h,C301h,C601h,CC01h,D801h,F001h,A001h
  for i=start to end
    crc=crc xor byte[i]
    for j=0 to 7
      crc=crc shr 1:if carry then crc=crc xor (val[j] shl (7-j))
    next j
  next i
</PRE></TD></TR></TBODY></TABLE>Return:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Calculated 16bit CRC Value
</PRE></TD></TR></TBODY></TABLE>Additionally, 
if the length is nonzero, r3 contains the last processed halfword at 
[addr+len-2]. Unlike most other NDS7 SWI functions which reject to read from 
BIOS memory, this allows to dump the NDS7 BIOS (except for the memory region 
that is locked via BIOSPROT Port 4000308h).<BR><BR><B>SWI 0Fh (NDS7/NDS9) - 
IsDebugger</B><BR>Detects if 4MB (normal) or 8MB (debug version) Main RAM 
installed.<BR>Return: r0 = result (0=normal console 4MB, 1=debug version 
8MB)<BR>Destroys halfword at [27FFFFAh] (NDS7) or [27FFFF8h] (NDS9)!<BR>The SWI 
0Fh function doesn't work stable if it gets interrupted by an interrupt which is 
calling SWI 0Fh, which would destroy the above halfword scratch value (unless 
the IRQ handler has saved/restored the halfword).<BR><BR><B>SWI 1Ah (NDS7) - 
GetSineTable</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Index (0..3Fh) (must be in that range, otherwise returns garbage)
</PRE></TD></TR></TBODY></TABLE>Return: 
r0 = Desired Entry (0000h..7FF5h) ;SIN(0 .. 88.6 degrees)*8000h<BR><BR><B>SWI 
1Bh (NDS7) - GetPitchTable</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Index (0..2FFh) (must be in that range, otherwise returns garbage)
</PRE></TD></TR></TBODY></TABLE>Return: 
r0 = Desired Entry (0000h..FF8Ah) (unsigned)<BR><BR><B>SWI 1Ch (NDS7) - 
GetVolumeTable</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Index (0..2D3h) (must be in that range, otherwise returns garbage)
</PRE></TD></TR></TBODY></TABLE>Return: 
r0 = Desired Entry (00h..7Fh) (unsigned)<BR><BR><B>SWI 1Fh (NDS9) - 
CustomPost</B><BR>Writes to the POSTFLG register, probably for use by Firmware 
boot procedure.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  32bit value, to be written to POSTFLG, Port 4000300h
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value.<BR><BR><B>SWI 1Dh (NDS7) - GetBootProcs</B><BR>Returns 
addresses of Gamecart boot procedure/interrupt handler, probably for use by 
Firmware boot procedure. The return values are somewhat XORed by each other. 
Most of the returned functions won't work if the POSTFLG register is
 set.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="biosmultibootsinglegamepak"></A><FONT size="+2">&nbsp;BIOS 
      Multi Boot (Single Game Pak)</FONT></TD></TR></TBODY></TABLE><BR>
MultiBoot<BR><BR><B>SWI 25h (GBA) - MultiBoot</B><BR>This function uploads &amp; 
starts program code to slave GBAs, allowing to launch programs on slave units 
even if no cartridge is inserted into the slaves (this works because all GBA 
BIOSes contain built-in download procedures in ROM).<BR>However, the SWI 25h 
BIOS upload function covers only 45% of the required Transmission Protocol, the 
other 55% must be coded in the master cartridge (see Transmission Protocol 
below).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Pointer to MultiBootParam structure
  r1  Transfer Mode (undocumented)
       0=256KHz, 32bit, Normal mode    (fast and stable)
       1=115KHz, 16bit, MultiPlay mode (default, slow, up to three slaves)
       2=2MHz,   32bit, Normal mode    (fastest but maybe unstable)
  Note: HLL-programmers that are using the MultiBoot(param_ptr) macro cannot
  specify the transfer mode and will be forcefully using MultiPlay mode.
</PRE></TD></TR></TBODY></TABLE>Return:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  0=okay, 1=failed
</PRE></TD></TR></TBODY></TABLE>See below for more 
details.<BR><BR><B>Multiboot Parameter Structure</B><BR>Size of parameter 
structure should be 4Ch bytes (the current GBA BIOS uses only first 44h bytes 
though). The following entries must be set before calling SWI 25h:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Addr Size Name/Expl.
  14h  1    handshake_data (entry used for normal mode only)
  19h  3    client_data[1,2,3]
  1Ch  1    palette_data
  1Eh  1    client_bit (Bit 1-3 set if child 1-3 detected)
  20h  4    boot_srcp  (typically 8000000h+0C0h)
  24h  4    boot_endp  (typically 8000000h+0C0h+length)
</PRE></TD></TR></TBODY></TABLE>The 
transfer length (excluding header data) should be a multiple of 10h, minimum 
length 100h, max 3FF40h (ca. 256KBytes). Set palette_data as
 "81h+color*10h+direction*8+speed*2", or as "0f1h+color*2" for fixed palette, 
whereas color=0..6, speed=0..3, direction=0..1. The other entries 
(handshake_data, client_data[1-3], and client_bit) must be same as specified in 
Transmission Protocol (see below hh,cc,y).<BR><BR><B>Multiboot Transfer 
Protocol</B><BR>Below describes the complete transfer protocol, normally only 
the Initiation part must be programmed in the master cartridge, the main data 
transfer can be then performed by calling SWI 25h, the slave program is started 
after SWI 25h completion.<BR>The ending handshake is normally not required, when 
using it, note that you will need custom code in BOTH master and slave 
programs.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Times  Send   Receive  Expl.
  -----------------------Required Transfer Initiation in master program
  ...    6200   FFFF     Slave not in multiplay/normal mode yet
  1      6200   0000     Slave entered correct mode now
  15     6200   720x     Repeat 15 times, if failed: delay 1/16s and restart
  1      610y   720x     Recognition okay, exchange master/slave info
  60h    xxxx   NN0x     Transfer C0h bytes header data in units of 16bits
  1      6200   000x     Transfer of header data completed
  1      620y   720x     Exchange master/slave info again
  ...    63pp   720x     Wait until all slaves reply 73cc instead 720x
  1      63pp   73cc     Send palette_data and receive client_data[1-3]
  1      64hh   73uu     Send handshake_data for final transfer completion
  -----------------------Below is SWI 25h MultiBoot handler in BIOS
  DELAY  -      -        Wait 1/16 seconds at master side
  1      llll   73rr     Send length information and receive random data[1-3]
  LEN    yyyy   nnnn     Transfer main data block in units of 16 or 32 bits
  1      0065   nnnn     Transfer of main data block completed, request CRC
  ...    0065   0074     Wait until all slaves reply 0075 instead 0074
  1      0065   0075     All slaves ready for CRC transfer
  1      0066   0075     Signalize that transfer of CRC follows
  1      zzzz   zzzz     Exchange CRC must be same for master and slaves
  -----------------------Optional Handshake (NOT part of master/slave BIOS)
  ...    ....   ....     Exchange whatever custom data
</PRE></TD></TR></TBODY></TABLE>Legend 
for above Protocol<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  y     client_bit, bit(s) 1-3 set if slave(s) 1-3 detected
  x     bit 1,2,or 3 set if slave 1,2,or 3
  xxxx  header data, transferred in 16bit (!) units (even in 32bit normal mode)
  nn    response value for header transfer, decreasing 60h..01h
  pp    palette_data
  cc    random client_data[1..3] from slave 1-3, FFh if slave not exists
  hh    handshake_data, 11h+client_data[1]+client_data[2]+client_data[3]
  uu    random data, not used, ignore this value
</PRE></TD></TR></TBODY></TABLE>Below 
automatically calculated by SWI 25h BIOS function (don't care about)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  llll  download length/4-34h
  rr    random data from each slave for encryption, FFh if slave not exists
  yyyy  encoded data in 16bit (multiplay) or 32bit (normal mode) units
  nnnn  response value, lower 16bit of destadr in GBA memory (00C0h and up)
  zzzz  16bit download CRC value, must be same for master and slaves
</PRE></TD></TR></TBODY></TABLE>Pseudo 
Code for SWI 25h Transfer with Checksum and Encryption calculations<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  if normal_mode    then c=C387h:x=C37Bh:k=43202F2Fh
  if multiplay_mode then c=FFF8h:x=A517h:k=6465646Fh
  m=dword(pp,cc,cc,cc):f=dword(hh,rr,rr,rr)
  for ptr=000000C0h to (file_size-4) step 4
    c=c xor data[ptr]:for i=1 to 32:c=c shr 1:if carry then c=c xor x:next
    m=(6F646573h*m)+1
    send_32_or_2x16 (data[ptr] xor (-2000000h-ptr) xor m xor k)
  next
  c=c xor f:for i=1 to 32:c=c shr 1:if carry then c=c xor x:next
  wait_all_units_ready_for_checksum:send_32_or_1x16 (c)
</PRE></TD></TR></TBODY></TABLE>Whereas, 
explained: c=chksum,x=chkxor,f=chkfin,k=keyxor,m=keymul<BR><BR><B>Multiboot 
Communication</B><BR>In Multiplay mode, master sends 16bit data, and receives 
16bit data from each slave (or FFFFh if none). In Normal mode, master sends 
32bit data (upper 16bit zero, lower 16bit as for multipay mode), and receives 
32bit data (upper 16bit as for multiplay mode, and lower 16bit same as lower
 16bit previously sent by master). Because SIODATA32 occupies same addresses as 
SIOMULTI0-1, the same transfer code can be used for both multiplay and normal 
mode (in normal mode SIOMULTI2-3 should be forced to FFFFh though). After each 
transfer, master should wait for Start bit cleared in SIOCNT register, followed 
by a 36us delay.<BR>Note: The multiboot slave would also recognize data being 
sent in Joybus mode, however, master GBAs cannot use joybus mode (because GBA 
hardware cannot act as master in joybus mode).<BR><BR><B>Multiboot Slave 
Header</B><BR>The transferred Header block is written to 2000000-20000BFh in 
slave RAM, the header must contain valid data (identically as for normal
 ROM-cartridge headers, including a copy of the Nintendo logo, correct header 
CRC, etc.), in most cases it'd be recommended just to transfer a copy of the 
master cartridges header from 8000000h-80000BFh.<BR><BR><B>Multiboot Slave 
Program/Data</B><BR>The transferred main program/data block is written to 
20000C0h and up (max 203FFFFh) in slave RAM, note that absolute addresses in the 
program must be then originated at 2000000h rather than 8000000h. In case that
 the master cartridge is 256K or less, it could just transfer a copy of the 
whole cartridge at 80000C0h and up, the master should then copy &amp; execute 
its own ROM data into RAM as well.<BR><BR><B>Multiboot Slave Extended 
Header</B><BR>For Multiboot slaves, separate Entry Point(s) must be defined at 
the beginning of the Program/Data block (the Entry Point in the normal header is 
ignored), also some reserved bytes in this section are overwritten by the 
Multiboot procedure. For more information see chapter about Cartridge 
Header.<BR><BR><B>Multiboot Slave with Cartridge</B><BR>Beside for slaves 
without cartridge, multiboot can be also used for slaves which do have a 
cartridge inserted, if so, SELECT and START must be kept held down during 
power-on in order to switch the slave GBA into Multiboot mode (ie. to prevent it 
from starting the cartridge as normally).<BR>The general idea is to enable newer 
programs to link to any existing older GBA programs, even if these older 
programs originally didn't have been intended to support linking.<BR>The 
uploaded program may access the slaves SRAM, Flash ROM, or EEPROM (if any, 
allowing to read out or modify slave game positions), as well as cartridge ROM 
at 80000A0h-8000FFFh (the first 4KBytes, excluding the nintendo logo, allowing 
to read out the cartridge name from the header, for example).<BR>The main part 
of the cartridge ROM is meant to be locked out in order to prevent software 
pirates from uploading "intruder" programs which would send back a copy of the 
whole cartridge to the master, however, for good or evil, at present time, 
current GBA models and GBA carts do not seem to contain any such 
protection.<BR><BR><B>Uploading Programs from PC</B><BR>Beside for the ability 
to upload a program from one GBA to another, this feature can be also used to 
upload small programs from a PC to a GBA. For more information see chapter about 
External Connectors.<BR><BR><B>Nintendo DS</B><BR>The GBA multiboot function 
requires a link port, and so, works on GBA and GBA SP only. The Nintendo DS in 
GBA mode does include the multiboot BIOS function, but it won't be of any use as 
the DS doesn't have a link port.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="biossoundfunctions"></A><FONT size="+2">&nbsp;BIOS Sound 
      Functions</FONT></TD></TR></TBODY></TABLE><BR>MidiKey2Freq<BR>SoundBias<BR>
SoundChannelClear<BR>SoundDriverInit<BR>SoundDriverMain<BR>SoundDriverMode<BR>
SoundDriverVSync<BR>SoundDriverVSyncOff<BR>SoundDriverVSyncOn<BR>
SoundWhatever0..4<BR>SoundGetJumpList<BR><BR><B>SWI 1Fh (GBA) - 
MidiKey2Freq</B><BR>Calculates the value of the assignment to 
((SoundArea)sa).vchn[x].fr when playing the wave data, wa, with the interval 
(MIDI KEY) mk and the fine adjustment value (halftones=256) fp.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  WaveData* wa
  r1  u8 mk
  r2  u8 fp
</PRE></TD></TR></TBODY></TABLE>Return:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  u32
</PRE></TD></TR></TBODY></TABLE>This function is particularly 
popular because it allows to read from BIOS memory without copy protection range 
checks. The formula to read one byte (a) from address (i, 0..3FFF) is:<BR>a = 
(MidiKey2Freq(i-(((i AND 3)+1)OR 3), 168, 0) * 2) SHR 24<BR><BR><B>SWI 19h (GBA) 
or SWI 08h (NDS7) - SoundBias</B><BR>Increments or decrements the current level 
of the SOUNDBIAS register (with short delays) until reaching the desired new 
level. The upper bits of the register are kept unchanged.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0   BIAS level (0=Level 000h, any other value=Level 200h)
  r1   Delay Count (NDS only) (GBA uses a fixed delay count of 8)
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value.<BR><BR><B>SWI 1Eh (GBA) - SoundChannelClear</B><BR>Clears all 
direct sound channels and stops the sound.<BR>This function may not operate 
properly when the library which expands the sound driver feature is combined 
afterwards. In this case, do not use it.<BR>No parameters, no return 
value.<BR><BR><B>SWI 1Ah (GBA) - SoundDriverInit</B><BR>Initializes the sound 
driver. Call this only once when the game starts up.<BR>It is essential that the 
work area already be secured at the time this function is called.<BR>You cannot 
execute this driver multiple times, even if separate work areas have been 
prepared.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Pointer to work area for sound driver, SoundArea structure as follows:
       SoundArea (sa) Structure
        u32    ident      Flag the system checks to see whether the
                          work area has been initialized and whether it
                          is currently being accessed.
        vu8    DmaCount   User access prohibited
        u8     reverb     Variable for applying reverb effects to direct sound
        u16    d1         User access prohibited
        void   (*func)()  User access prohibited
        int    intp       User access prohibited
        void*  NoUse      User access prohibited
        SndCh  vchn[MAX]  The structure array for controlling the direct
                          sound channels (currently 8 channels are
                          available). The term "channel" here does
                          not refer to hardware channels, but rather to
                          virtual constructs inside the sound driver.
        s8     pcmbuf[PCM_BF*2]
       SoundChannel Structure
        u8         sf     The flag indicating the status of this channel.
                          When 0 sound is stopped.
                          To start sound, set other parameters and
                          then write 80h to here.
                          To stop sound, logical OR 40h for a
                          release-attached off (key-off), or write zero
                          for a pause. The use of other bits is
                          prohibited.
        u8         r1     User access prohibited
        u8         rv     Sound volume output to right side
        u8         lv     Sound volume output to left side
        u8         at     The attack value of the envelope. When the
                          sound starts, the volume begins at zero and
                          increases every 1/60 second. When it
                          reaches 255, the process moves on to the
                          next decay value.
        u8         de     The decay value of the envelope. It is
                          multiplied by "this value/256" every 1/60
                          sec. and when sustain value is reached, the
                          process moves to the sustain condition.
        u8         su     The sustain value of the envelope. The
                          sound is sustained by this amount.
                          (Actually, multiplied by rv/256, lv/256 and
                          output left and right.)
        u8         re     The release value of the envelope. Key-off
                          (logical OR 40h in sf) to enter this state.
                          The value is multiplied by "this value/256"
                          every 1/60 sec. and when it reaches zero,
                          this channel is completely stopped.
        u8         r2[4]  User access prohibited
        u32        fr     The frequency of the produced sound.
                          Write the value obtained with the
                          MidiKey2Freq function here.
        WaveData*  wp     Pointer to the sound's waveform data. The waveform
                          data can be generated automatically from the AIFF
                          file using the tool (aif2agb.exe), so users normally
                          do not need to create this themselves.
        u32        r3[6]  User access prohibited
        u8         r4[4]  User access prohibited
       WaveData Structure
        u16   type    Indicates the data type. This is currently not used.
        u16   stat    At the present time, non-looped (1 shot) waveform
                      is 0000h and forward loop is 4000h.
        u32   freq    This value is used to calculate the frequency.
                      It is obtained using the following formula:
                      sampling rate x 2^((180-original MIDI key)/12)
        u32   loop    Loop pointer (start of loop)
        u32   size    Number of samples (end position)
        s8    data[]  The actual waveform data. Takes (number of samples+1)
                      bytes of 8bit signed linear uncompressed data. The last
                      byte is zero for a non-looped waveform, and the same
                      value as the loop pointer data for a looped waveform.
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value.<BR><BR><B>SWI 1Ch (GBA) - SoundDriverMain</B><BR>Main of the 
sound driver.<BR>Call every 1/60 of a second. The flow of the process is to call
 SoundDriverVSync, which is explained later, immediately after the V-Blank 
interrupt.<BR>After that, this routine is called after BG and OBJ processing is
 executed.<BR>No parameters, no return value.<BR><BR><B>SWI 1Bh (GBA) - 
SoundDriverMode</B><BR>Sets the sound driver operation mode.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Sound driver operation mode
       Bit    Expl.
       0-6    Direct Sound Reverb value (0-127, default=0) (ignored if Bit7=0)
       7      Direct Sound Reverb set (0=ignore, 1=apply reverb value)
       8-11   Direct Sound Simultaneously-produced (1-12 channels, default 8)
       12-15  Direct Sound Master volume (1-15, default 15)
       16-19  Direct Sound Playback Frequency (1-12 = 5734,7884,10512,13379,
              15768,18157,21024,26758,31536,36314,40137,42048, def 4=13379 Hz)
       20-23  Final number of D/A converter bits (8-11 = 9-6bits, def. 9=8bits)
       24-31  Not used.
</PRE></TD></TR></TBODY></TABLE>Return: 
No return value.<BR><BR><B>SWI 1Dh (GBA) - SoundDriverVSync</B><BR>An extremely 
short system call that resets the sound DMA. The timing is extremely critical, 
so call this function immediately after the V-Blank interrupt every 1/60 
second.<BR>No parameters, no return value.<BR><BR><B>SWI 28h (GBA) - 
SoundDriverVSyncOff</B><BR>Due to problems with the main program if the V-Blank 
interrupts are stopped, and SoundDriverVSync cannot be called every 1/60 a 
second, this function must be used to stop sound DMA.<BR>Otherwise, even if you 
exceed the limit of the buffer the DMA will not stop and noise will result.<BR>
No parameters, no return value.<BR><BR><B>SWI 29h (GBA) - 
SoundDriverVSyncOn</B><BR>This function restarts the sound DMA stopped with the 
previously described SoundDriverVSyncOff.<BR>After calling this function, have a 
V-Blank occur within 2/60 of a second and call SoundDriverVSync.<BR>No 
parameters, no return value.<BR><BR><B>SWI 20h..24h (GBA) - SoundWhatever0..4 
(Undocumented)</B><BR>Whatever undocumented sound-related BIOS 
functions.<BR><BR><B>SWI 2Ah (GBA) - SoundGetJumpList (Undocumented)</B><BR>
Receives pointers to 36 additional sound-related BIOS functions.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  r0  Destination address (must be aligned by 4) (120h bytes buffer)
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="unpredictablethings"></A><FONT size="+2">&nbsp;Unpredictable 
      Things</FONT></TD></TR></TBODY></TABLE><BR><B>Forward</B><BR>Most of the below 
is caused by 'traces' from previous operations which have used the databus. No 
promises that the results are stable on all current or future GBA models, and/or 
under all temperature and interference circumstances.<BR>Also, below specifies 
32bit data accesses only. When reading units less than 32bit, data is rotated 
depending on the alignment of the originally specified address, and 8bit or 
16bit are then isolated from the 32bit value as usually.<BR><BR><B>Reading from 
BIOS Memory (00000000-00003FFF)</B><BR>The BIOS memory is protected against 
reading, the GBA allows to read opcodes or data only if the program counter is 
located inside of the BIOS area. If the program counter is not in the BIOS area, 
reading will return the most recent successfully fetched BIOS opcode (eg. the 
opcode at [00DCh+8] after startup and SoftReset, the opcode at [0134h+8] during 
IRQ execution, and opcode at [013Ch+8] after IRQ execution, and opcode at
 [0188h+8] after SWI execution).<BR><BR><B>Reading from Unused Memory 
(00004000-1FFFFFF0,10000000-FFFFFFFF)</B><BR>Accessing unused memory returns the 
recently pre-fetched opcode, ie. the 32bit opcode at $+8 in ARM state, or the 
16bit-opcode at $+4 in THUMB state, in the later case the 16bit opcode is 
mirrored across both upper/lower 16bits of the returned 32bit data.<BR>Note: 
This is caused by the prefetch pipeline in the CPU itself, not by the external 
gamepak prefetch, ie. it works for code in RAM as well.<BR><BR><B>Reading from 
Unused or Write-Only I/O Ports</B><BR>Works like above unused memory when the 
entire 32bit memory fragment is Unused (eg. 0E0h) and/or Write-Only (eg. 
DMA0SAD). And otherwise, returns zero if the lower 16bit fragment is readable 
(eg. 04C=MOSAIC, 04E=NOTUSED/ZERO).<BR><BR><B>Reading from GamePak ROM when no 
Cartridge is inserted</B><BR>Because Gamepak uses the same signal-lines for both 
16bit data and for lower 16bit halfword address, the entire gamepak ROM area is 
effectively filled by incrementing 16bit values (Address/2 AND 
FFFFh).<BR><BR><B>Memory Mirrors</B><BR>Most internal memory is mirrored across 
the whole 24bit/16MB address space in which it is located: On-board RAM at 
2XXXXXX, In-Chip RAM at 3XXXXXXh, Palette RAM at 5XXXXXXh, VRAM at 6XXXXXXh, and 
OAM at 7XXXXXXh. Even though VRAM is sized 96K (64K+32K), it is repeated in
 steps of 128K (64K+32K+32K, the two 32K blocks itself being mirrors of each 
other).<BR>BIOS ROM, Normal ROM Cartridges, and I/O area are NOT mirrored, the 
only exception is the undocumented I/O port at 4000800h (repeated each 64K).<BR>
The 64K SRAM area is mirrored across the whole 32MB area at E000000h-FFFFFFFh, 
also, inside of the 64K SRAM field, 32K SRAM chips are repeated 
twice.<BR><BR><B>Writing 8bit Data to Video Memory</B><BR>Video Memory (BG, OBJ, 
OAM, Palette) can be written to in 16bit and 32bit units only. Attempts to write 
8bit data (by STRB opcode) won't work:<BR>Writes to OBJ (6010000h-6017FFFh) and 
OAM (7000000h-70003FFh) are ignored, the memory content remains unchanged. 
Writes to BG (6000000h-600FFFFh) and Palette (5000000h-50003FFh) are writing the 
new 8bit value to BOTH upper and lower 8bits of the addressed halfword, ie. 
"[addr AND NOT 1]=data*101h".<BR><BR><B>Accessing SRAM Area by 
16bit/32bit</B><BR>Reading retrieves 8bit value from specified address, 
multiplied by 0101h (LDRH) or by 01010101h (LDR). Writing changes the 8bit value 
at the specified address only, being set to LSB of (source_data ROR 
(address*8)).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="externalconnectors"></A><FONT size="+2">&nbsp;External 
      Connectors</FONT></TD></TR></TBODY></TABLE><BR><B>External Connectors</B><BR><A 
href="#auxgamepakbus">AUX Game Pak 
Bus</A><BR><A href="#auxdsgamecardslot">AUX 
DS Game Card Slot</A><BR><A href="#auxlinkport">AUX 
Link Port</A><BR><A href="#auxsoundheadphonesocketandbatterypowersupply">AUX 
Sound/Headphone Socket and Battery/Power Supply</A><BR><BR><B>Getting access to 
Internal Pins</B><BR><A href="#auxopeningthegba">AUX 
Opening the GBA</A><BR><A href="#auxmainboard">AUX 
Mainboard</A><BR><BR><B>Xboo Multiboot Cable</B><BR><A href="#auxxboopctogbamultibootcable">AUX 
Xboo PC-to-GBA Multiboot Cable</A><BR><A href="#auxxbooflashcardupload">AUX 
Xboo Flashcard Upload</A><BR><A href="#auxxbooburstbootbackdoor">AUX 
Xboo Burst Boot Backdoor</A><BR><A href="#dsxboo">DS 
Xboo</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="auxgamepakbus"></A><FONT size="+2">&nbsp;AUX Game Pak 
      Bus</FONT></TD></TR></TBODY></TABLE><BR><B>Game Pak Bus - 32pin cartridge 
slot</B><BR>The cartridge bus may be used for both CGB and GBA game paks. In GBA 
mode, it is used as follows:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> Pin    Name    Dir  Expl.
 1      VDD     O    Power Supply 3.3V DC
 2      PHI     O    System Clock (selectable none, 4.19MHz, 8.38MHz, 16.78MHz)
 3      /WR     O    Write Select
 4      /RD     O    Read Select
 5      /CS     O    ROM Chip Select
 6-21   AD0-15  I/O  lower 16bit Address    and/or  16bit ROM-data (see below)
 22-29  A16-23  I/O  upper 8bit ROM-Address   or    8bit SRAM-data (see below)
 30     /CS2    O    SRAM Chip Select
 31     /REQ    I    Interrupt request (/IREQ) or DMA request (/DREQ)
 32     GND     O    Ground 0V
</PRE></TD></TR></TBODY></TABLE>When 
accessing game pak SRAM, a 16bit address is output through AD0-AD15, then 8bit 
of data are transferred through A16-A23.<BR>When accessing game pak ROM, a 24bit 
address is output through AD0-AD15 and A16-A23, then 16bit of data are 
transferred through AD0-AD15. The 24bit address is formed from the actual 25bit 
memory address (byte-steps), divided by two 
(halfword-steps).<BR><BR><B>8bit-Gamepak-Switch (GBA, GBA SP only) (not 
DS)</B><BR>A small switch is located inside of the cartridge slot, the switch is
 pushed down when an 8bit cartridge is inserted, it is released when a GBA 
cartridge is inserted (or if no cartridge is inserted).<BR>The switch 
mechanically controls whether VDD3 or VDD5 are output at VDD35; ie. in GBA mode 
3V power supply/signals are used for the cartridge slot and link port, while in 
8bit mode 5V are used.<BR>The current state of the switch can be determined GBA 
mode via Port 204h (WAITCNT), if (and only if) the switch is pushed, then CGB 
mode can be activated via Port 000h (DISPCNT.3). The GBA boot procedure in BIOS 
uses this to detect 8bit carts and to set the GBA into 8bit mode.<BR>In 8bit 
mode, the cartridge bus works much like for GBA SRAM, however, the 8bit /CS 
signal is expected at Pin 5, while GBA SRAM /CS2 at Pin 30 is interpreted as 
/RESET signal by the 8bit MBC chip (if any). In practice, this appears to result 
in 00h being received as data when attempting to read-out 8bit cartridges from 
inside of GBA mode.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="auxdsgamecardslot"></A><FONT size="+2">&nbsp;AUX DS Game Card 
      Slot</FONT></TD></TR></TBODY></TABLE><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Pin    Dir  Name  Connection in cartridge
  1   &gt;  -    GND   (ROM all unused Pins, EPROM Pin 4)
  2      Out  CLK   (4MB/s, ROM Pin 5, EPROM Pin 6)
  3   N  ?    ?     (ROM Pin 17) (Seems to be not connected in console)
  4   i  Out  /CS1  (ROM Pin 44) ROM Chipselect
  5   n  Out  /RES  (ROM Pin 42) Reset, switches ROM to unencrypted mode
  6   t  Out  /CS2  (EPROM Pin 1) EEPROM Chipselect
  7   e  In   IRQ   (GND)
  8   n  -    3.3V  (ROM Pins 2, 23, EPROM Pins 3, 7, 8)
  9   d  I/O  D0    (ROM Pin 18)
  10  o  I/O  D1    (ROM Pin 19)
  11     I/O  D2    (ROM Pin 20)
  12  C  I/O  D3    (ROM Pin 21)
  13  0  I/O  D4    (ROM Pin 24)
  14  1  I/O  D5    (ROM Pin 25)
  15  -  I/O  D6    (ROM Pin 26, EPROM Pin 2)
  16  0  I/O  D7    (ROM Pin 27, EPROM Pin 5)
  17  1  -    GND   (ROM all unused Pins, EPROM Pin 4)
</PRE></TD></TR></TBODY></TABLE><BR>
Chipselect High-to-Low transitions are invoking commands, which are transmitted 
through data lines during next following eight CLK pulses, after the command 
transmission, further CLK pulses are used to transfer data, the data transfer 
ends at chipselect Low-to-High transition.<BR>Data should be stable during 
CLK=LOW period throughout CLK rising edge.<BR>Note: Supply Pins (1,8,17) are 
slightly longer than other pins.<BR><BR>The DS does also have a 32pin cartridge 
slot, that slot is used to run GBA carts in GBA mode, it can be also used as 
expansion port in DS mode.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="auxlinkport"></A><FONT size="+2">&nbsp;AUX Link 
  Port</FONT></TD></TR></TBODY></TABLE><BR><B>Serial Link Port Pin-Out (GBA:"EXT" 
- GBA SP:"EXT.1")</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Pin  Name  Cable
  1    VDD35 N/A       GBA Socket     GBA Plug   Old "8bit" Plug
  2    SO    Red       ___________    _________    ___________
  3    SI    Orange   |  2  4  6  |  / 2  4  6 \  |  2  4  6  |
  4    SD    Brown     \_1_ 3 _5_/   \_1_ 3 _5_/   \_1__3__5_/
  5    SC    Green         '-'           '-'
  6    GND   Blue      Socket Outside View / Plug Inside View
  Shield     Shield
</PRE></TD></TR></TBODY></TABLE>Note: 
The pin numbers and names are printed on the GBA mainboard, colors as used in 
Nintendos AGB-005 and older 8bit cables.<BR><BR><B>Cable Diagrams (Left: GBA 
Cable, Right: 8bit Gameboy Cable)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Big Plug  Middle Socket  Small Plug    Plug 1         Plug 2
   SI _________________     ____ SI       SI ______  ______SI
   SO ____________SO   |__ | ___ SO       SO ______&gt;&lt;______SO
   GND____________GND______|____GND       GND_____________GND
   SD ____________SD____________ SD       SD               SD
   SC ____________SC____________ SC       SC _____________ SC
   Shield_______Shield_______Shield       Shield_______Shield
</PRE></TD></TR></TBODY></TABLE><BR><B>Normal 
Connection</B><BR>Just connect the plugs to the two GBAs and leave the Middle 
Socket disconnected, in this mode both GBAs may behave as master or slave,
 regardless of whether using big or small plugs.<BR>The GBA is (NOT ???) able to 
communicate in Normal mode with MultiPlay cables which do not have crossed SI/SO 
lines.<BR><BR><B>Multi-Play Connection</B><BR>Connect two GBAs as normal, for 
each further GBAs connect an additional cable to the Middle socket of the first 
(or further) cable(s), up to four GBAs may be connected by using up to three 
cables.<BR>The GBA which is connected to a Small Plug is master, the slaves are 
all connected to Large Plugs. (Only small plugs fit into the Middle Socket, so 
it's not possible to mess up something here).<BR><BR><B>Multi-Boot 
Connection</B><BR>MultiBoot (SingleGamepak) is typically using Multi-Play 
communication, in this case it is important that the Small plug is connected to 
the master/sender (ie. to the GBA that contains the 
cartridge).<BR><BR><B>Non-GBA Mode Connection</B><BR>First of all, it is not 
possible to link between 32bit GBA games and 8bit games, parts because of 
different cable protocol, and parts because of different signal voltages.<BR>
However, when a 8bit cartridge is inserted (the GBA is switched into 8bit 
compatibility mode) it may be connected to other 8bit games (monochrome 
gameboys, CGBs, or to other GBAs which are in 8bit mode also, but not to GBAs in 
32bit mode).<BR>When using 8bit link mode, an 8bit link cable must be used. The 
GBA link cables won't work, see below modification though.<BR><BR><B>Using a GBA 
32bit cable for 8bit communication</B><BR>Open the middle socket, and disconnect 
Small Plugs SI from GND, and connect SI to Large Plugs SO instead. You may also 
want to install a switch that allows to switch between SO and GND, the GND 
signal should be required for MultiPlay communication only though.<BR>Also, cut 
off the plastic ledge from the plugs so that they fit into 8bit gameboy 
sockets.<BR><BR><B>Using a GBA 8bit cable for 32bit communication</B><BR>The 
cable should theoretically work as is, as the grounded SI would be required for 
MultiPlay communication only. However, software that uses SD for Slave-Ready 
detection won't work unless when adding a SD-to-SD connection (the 8bit plugs 
probably do not even contain SD pins though).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="auxsoundheadphonesocketandbatterypowersupply"></A><FONT size="+2">&nbsp;AUX 
      Sound/Headphone Socket and Battery/Power 
Supply</FONT></TD></TR></TBODY></TABLE><BR><B>GBA and DS: Stereo Sound Connector 
(3.5mm, female)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Pin     Expl.
  Tip     Sound Left
  Middle  Sound Right
  Base    Ground
</PRE></TD></TR></TBODY></TABLE><BR><B>GBA: 
Power Supply Input</B><BR>The GBA does not have a separate power supply input, 
however external power supplies can be connected to the battery socket. The 
recommended external voltage is 3.3V DC.<BR><BR><B>GBA SP and DS: EXT.2 Socket 
(Power Supply and Headphones)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Pin     Expl.                   ___________
  A       PWR(-) GND             | X  ___  Y |
  D       PWR(+) 5.2V DC         | ---   --- |
  Y       Sound Left             |_A_B   C_D_|
  C       Sound Right                 \_/
  X,B     Unknown ???
</PRE></TD></TR></TBODY></TABLE><BR>
External power input is used to charge the built-in battery, it cannot be used 
to run the SP without that battery. The switch in the middle between X and Y 
pins is probably used to disable the internal speaker when headphones are 
connected... or to sense the external power supply ???<BR><BR><B>Using PC +5V DC 
as Power Supply</B><BR>Developers whom are using a PC for GBA programming will 
probably want to use the PC power supply (gained from disk drive power supply 
cable) for the GBA as well rather than dealing with batteries or external power
 supplies.<BR>GBA: To lower the voltage to approximately 3 Volts use two diodes, 
type 1N 4004 or similar, the ring printed onto the diodes points towards the GBA
 side, connected as such:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  PC +5V (red)   --------|&gt;|---|&gt;|--------  GBA BT+
  PC GND (black) -------------------------  GBA BT-
</PRE></TD></TR></TBODY></TABLE>GBA 
SP and DS: Works directly at +5V connected to EXT.2 socket (not to the internal 
battery pins), without any diodes.<BR><BR><B>Using Parallel Port Data Lines as 
Power Supply</B><BR>When using a Multiboot cable connected to PC parallel port 
it'd be comfortable to use the existing cable for power supply as well. This
 method definitely exceeds all official ratings, in fact almost, it is ethically 
wrong, absolutely no warranty that it will work and that it won't destroy 
hardware and/or burn down the house, USE AT OWN RISK, among others the following 
may cause problems:<BR>The parallel port data signals aren't intended to be 
mis-used as power supply, many BIOSes and operating systems will initialize some 
data lines as LOW and some as HIGH, when directly shortcutting data lines any
 low signals will most likely forcefully pull-down high signals, different 
parallel ports output between 3.66V and 5.00V data HIGH, and not all parallel 
ports will provide enough Watts even when all data lines are high.<BR>The most 
violent method is to shortcut all Data Lines (Pin 2-9) and connect these to the 
GBA BT+ input, also connect Ground (Pin 19 or else) to GBA BT- input (unless 
already connected to GBA link port GND). If necessary insert 1 or 2 diodes 
(depending on the parallel port type) between Data Lines and BT+ (as describe 
for 5V input above). The above Data/Ground pin numbers are the same for 25-pin 
PC sockets and 36-pin printer plugs.<BR>I've tried above with 4 different 
parallel ports with different results: One didn't worked at all (not enough 
power), one worked even though power LED signalized low power, another worked 
just fine, and the fourth worked only after inserting two diodes. Note that the 
GBA would consume even more power when inserting cartridges into it.<BR>Finally, 
to turn the power on, output FFh to parallel port base address, and if necessary 
output 0Bh to base address+2. (Or launch the no$gba multiboot function which 
automatically initializes these ports).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="auxopeningthegba"></A><FONT size="+2">&nbsp;AUX Opening the 
      GBA</FONT></TD></TR></TBODY></TABLE><BR>Since Nintendo uses special screws with 
Y-shaped heads to seal the GBA (as well as older 8bit gameboys), it's always a 
bit difficult to loosen these screws.<BR><BR><B>Using Screwdrivers</B><BR>One 
possible method is to use a small flat screwdriver, which might work, even 
though it'll most likely damage the screwdriver.<BR>Reportedly, special Y-shaped 
screwdrivers for gameboys are available for sale somewhere (probably not at your 
local dealer, but you might find some in the internet or 
elsewhere).<BR><BR><B>Destroying the Screws</B><BR>A more violent method is to 
take an electric drill, and drill-off the screw heads, this might also slightly 
damage the GBA plastic chase, also take care that the metal spoons from the 
destroyed screws don't produce shortcuts on the GBA mainboard.<BR><BR><B>Using a 
selfmade Screwdriver</B><BR>A possible method is to take a larger screw (with a 
normal I-shaped, or X-shaped head), and to cut the screw-tip into Y-shape, 
you'll then end up with an "adapter" which can be placed in the middle between a 
normal screwdriver and gameboy screws.<BR>Preferably, first cut the screw-tip 
into a shape like a "sharp three sided pyramid", next cut notches into each 
side. Access to a grinding-machine will be a great benefit, but you might get it 
working by using a normal metal-file as well.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="auxmainboard"></A><FONT size="+2">&nbsp;AUX 
    Mainboard</FONT></TD></TR></TBODY></TABLE><BR>Other possibly useful signals on 
the mainboard...<BR><BR><B>FIQ Signal</B><BR>The FIQ (Fast Interrupt) signal 
(labeled FIQ on the mainboard) could be used as external interrupt (or debugging 
break) signal.<BR>Caution: By default, the FIQ input is directly shortcut to 
VDD35 (+3V or +5V power supply voltage), this can be healed by scratching off 
the CL1 connection located close to the FIQ pin (FIQ still appears to have an
 internal pull-up, so that an external resistor is not required).<BR>The GBA 
BIOS rejects FIQs if using normal ROM cartridge headers (or when no cartridge is 
inserted). When using a FIQ-compatible ROM header, Fast Interrupts can be then 
requested by pulling FIQ to ground, either by a push button, or by remote 
controlled signals.<BR><BR><B>RESET Signal</B><BR>The RESET signal (found on the 
mainboard) could be used to reset the GBA by pulling the signal to ground for a 
few microseconds (or longer). The signal can be directly used (it is not 
shortcut to VDD35, unlike FIQ).<BR>Note: A reset always launches nintendos 
time-consuming and annoying boot/logo procedure, so that it'd be recommend to 
avoid this "feature" when possible.<BR><BR><B>Joypad Signals</B><BR>The 10 
direction/button signals are each directly shortcut to ground when pressed, and 
pulled up high otherwise (unlike 8bit gameboys which used a 2x4 keyboard 
matrix), it'd be thus easy to connect a remote keyboard, keypad, joypad, or 
read-only 12bit parallel port.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="auxxboopctogbamultibootcable"></A><FONT size="+2">&nbsp;AUX 
      Xboo PC-to-GBA Multiboot Cable</FONT></TD></TR></TBODY></TABLE><BR>Below 
describes how to connect a PC parallel port to the GBA link port, allowing to 
upload small programs (max 256 KBytes) from no$gba's Utility menu into real 
GBAs.<BR><BR>This is possible because the GBA BIOS includes a built-in function 
for downloading &amp; executing program code even when no cartridge is inserted.
 The program is loaded to 2000000h and up in GBA memory, and must contain
 cartridge header information just as for normal ROM cartridges (nintendo logo, 
checksum, etc., plus some additional multiboot info).<BR><BR><B>Basic Cable 
Connection</B><BR>The general connection is very simple (only needs four wires), 
the only problem is that you need a special GBA plug or otherwise need to solder
 wires directly to the GBA mainboard (see Examples below).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  GBA  Name  Color                 SUBD CNTR Name
  2    SO    Red     ------------- 10   10   /ACK
  3    SI    Orange  ------------- 14   14   /AUTOLF
  5    SC    Green   ------------- 1    1    /STROBE
  6    GND   Blue    ------------- 19   19   GND
</PRE></TD></TR></TBODY></TABLE>Optionally, 
also connect the following signals (see notes below):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4    SD    Brown   ------------- 17   36   /SELECT  (double speed burst)
  3    SI    Orange  ----[===]---- 2..9 2..9 D0..7    (pull-up, 560 Ohm)
  5    SC    Green   ----[===]---- 2..9 2..9 D0..7    (pull-up, 560 Ohm)
  4    SD    Brown   ----[===]---- 2..9 2..9 D0..7    (pull-up, 560 Ohm)
  START  (mainboard) -----|&gt;|----- 16   31   /INIT    (auto-reset, 1N4148)
  SELECT (mainboard) -----|&gt;|----- 16   31   /INIT    (auto-reset, 1N4148)
  RESET  (mainboard) -----||------ 16   31   /INIT    (auto-reset, 300nF)
</PRE></TD></TR></TBODY></TABLE>Notes: 
The GBA Pins are arranged from left to right as 2,4,6 in upper row, and 1,3,5 in 
lower row; outside view of GBA socket; flat side of socket upside. The above 
"Colors" are as used in most or all standard Nintendo link cables, note that 
Red/Orange will be exchanged at one end in cables with crossed SO/SI lines. At 
the PC side, use the SUBD pin numbers when connecting to a 25-pin SUBD plug, or 
CNTR pin numbers for 36-pin Centronics plug.<BR><BR><B>Optional SD Connection 
(Double Speed Burst)</B><BR>The SD line is used for Double Speed Burst transfers 
only, in case that you are using a gameboy link plug for the connection, and if 
that plug does not have a SD-pin (such like from older 8bit gameboy cables), 
then you may leave out this connection. Burst Boot will then only work half as 
fast though.<BR><BR><B>Optional Pull-Ups (Improves Low-to-High Transition 
Speed)</B><BR>If your parallel port works only with medium or slow delay 
settings, try to connect 560 Ohm resistors to SI/SC/SD inputs each, and the 
other resistor pin to any or all of the parallel port data lines (no$gba outputs
 high to pins 2..9).<BR><BR><B>Optional Reset Connection (CAUTION: Connection 
changed September 2004)</B><BR>The Reset connection allows to automatically 
reset &amp; upload data even if a program in the GBA has locked up (or if you've 
loaded a program that does not support nocash burst boot), without having to 
reset the GBA manually by switching it off and on (and without having to press 
Start+Select if a cartridge is inserted).<BR>The two diodes should be 1N4148 or 
similar, the capacitor should be 300nF (eg. three 100nF capacitors in parallel). 
The signals are labeled on the mainboard, and can be found at following names / 
CPU pin numbers: RESET/CPU.125, SELECT/TP2/CPU.126, 
START/TP3/CPU.127.<BR><BR><B>Optional Power Supply Connection</B><BR>Also, you 
may want to connect the power supply to parallel port data lines, see chapter 
Power Supply for details.<BR><BR><B>Transmission Speed</B><BR>The first transfer 
will be very slow, and the GBA BIOS will display the boot logo for at least 4 
seconds, even if the transfer has completed in less time. Once when you have 
uploaded a program with burst boot backdoor, further transfers will be ways 
faster. The table below shows transfer times for 0KByte - 256KByte files:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Boot Mode_____Delay 0_______Delay 1_______Delay 2_____
  Double Burst  0.1s - 1.8s   0.1s - 3.7s   0.1s - 5.3s
  Single Burst  0.1s - 3.6s   0.1s - 7.1s   0.1s - 10.6s
  Normal Bios   4.0s - 9.0s   4.0s - 12.7s  4.0s - 16.3s
</PRE></TD></TR></TBODY></TABLE>All 
timings measured on a 66MHz computer, best possible transmission speed should be 
150KBytes/second. Timings might slightly vary depending on the CPU speed and/or 
operating system. Synchronization is done by I/O waitstates, that should work 
even on faster computers. Non-zero delays are eventually required for cables 
without pull-ups.<BR><BR><B>Requirements</B><BR>Beside for the cable and plugs, 
no special requirements.<BR>The cable should work with all parallel ports, 
including old-fashioned one-directional printer ports, as well as modern 
bi-directional EPP ports. Transfer timings should work stable regardless of the 
PCs CPU speed (see above though), and regardless of multitasking 
interruptions.<BR>Both no$gba and the actual transmission procedure are using 
some 32bit code, so that either one currently requires 80386SX CPUs or 
above.<BR><BR><B>Connection Examples</B><BR>As far as I can imagine, there are 
four possible methods how to connect the cable to the GBA. The first two methods 
don't require to open the GBA, and the other methods also allow to connect 
optional power supply and reset signal.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  1) Connect it to the GBA link port. Advantage: No need to
     open/modify the GBA. Disadvantage: You need a special plug,
     (typically gained by removing it from a gameboy link cable).
  2) Solder the cable directly to the GBA link port pins. Advantages:
     No plug required &amp; no need to open the GBA. Disadvantages:
     You can't remove the cable, and the link port becomes unusable.
  3) Solder the cable directly to the GBA mainboard. Advantage: No
     plug required at the GBA side. Disadvantage: You'll always
     have a cable leaping out of the GBA even when not using it,
     unless you put a small standard plug between GBA and cable.
  4) Install a Centronics socket in the GBA (between power switch
     and headphone socket). Advantage: You can use a standard
     printer cable. Disadvantages: You need to cut a big hole into
     the GBAs battery box (which cannot be used anymore), the big
     cable might be a bit uncomfortable when holding the GBA.
</PRE></TD></TR></TBODY></TABLE>Personally, I've decided to use the lastmost method as I don't like ending up with 
hundreds of special cables for different purposes, and asides, it's been fun to 
damage the GAB as much as possible.<BR><BR><B>Note</B><BR>The above used PC 
parallel port signals are typically using 5V=HIGH while GBA link ports deal with 
3V=HIGH. From my experiences, the different voltages do not cause communication 
problems (and do not damage the GBA and/or PC hardware), and after all real men 
don't care about a handful of volts, however, use at own risk.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="auxxbooflashcardupload"></A><FONT size="+2">&nbsp;AUX Xboo 
      Flashcard Upload</FONT></TD></TR></TBODY></TABLE><BR><B>Flashcard Upload</B><BR>
Allows to write data to flashcards which are plugged into GBA cartridge slot, 
cartridge is automatically started after writing. On initial power-up, hold down 
START+SELECT to prevent the GBA from booting the old program in the 
flashcard.<BR>The Upload function in Utility menu uses flashcard mode for files 
bigger than 256KB (otherwise uses multiboot mode automatically). Also, there's a
 separate Upload to Flashcard function in Remote Access submenu, allowing to 
write files of 256KB or less to flashcard if that should be 
desired.<BR><BR><B>Supported Flashcards</B><BR>Function currently tested with 
Visoly Flash Advance (FA) 256Mbit (32MB) Turbo cartridge. Should also work with 
older FA versions. Please let me know if you are using other flashcards which 
aren't yet supported.<BR><BR><B>Flashcard Performance</B><BR>Writing to 
flashcards may become potentially slow because of chip erase/write times, cable 
transmission time, and the sheer size of larger ROM-images. However, developers 
whom are testing different builts of their project usually won't need to rewrite 
the complete flashcard, Xboo uses a highspeed checksum mechanism (16MB/sec) to 
determine which flashcard sector(s) have changed, and does then re-write only 
these sector(s).<BR>To eliminate transmission time, data transfer takes place in 
the erase phases. Erase/write time depends on the flashcard type, should be 
circa 1-2 seconds per 256KB sector. Because the cartridge is programmed directly
 in the GBA there's no need to remove it from the GBA when writing to 
it.<BR><BR><B>Developers Advice</B><BR>Locate your program fragments at fixed 
addresses, for example, code and data blocks each aligned to 64K memory 
boundaries, so that data remains at the same location even when the size of code 
changes. Fill any blank spaces by value FFh for faster write time. Reduce the 
size of your ROM-image by efficient memory use (except for above alignment 
trick). Include the burst boot backdoor in your program, allowing to re-write 
the flashcard directly without resetting the GBA.<BR><BR><B>Lamers 
Advice</B><BR>Xboo Flashcard support does not mean to get lame &amp; to drop 
normal multiboot support, if your program fits into 256KB then make it 
&lt;both&gt; flashcard &lt;and&gt; multiboot compatible - multiboot reduces 
upload time, increases your flashcard lifetime, and will also work for people 
whom don't own flashcards.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="auxxbooburstbootbackdoor"></A><FONT size="+2">&nbsp;AUX Xboo 
      Burst Boot Backdoor</FONT></TD></TR></TBODY></TABLE><BR>When writing Xboo 
compatible programs, always include a burst boot "backdoor", this will allow 
yourself (and other people) to upload programs much faster as when using the 
normal GBA BIOS multiboot function. Aside from the improved transmission speed, 
there's no need to reset the GBA each time (eventually manually if you do not 
have reset connect), without having to press Start+Select (if cartridge 
inserted), and, most important, the time-consuming nintendo-logo intro is 
bypassed.<BR><BR><B>The Burst Boot Protocol</B><BR>In your programs IRQ handler, 
add some code that watches out for burst boot IRQ requests. When sensing a burst 
boot request, download the actual boot procedure, and pass control to that 
procedure.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Send (PC)    Reply (GBA)
  "BRST"       "BOOT"        ;request burst, and reply &lt;prepared&gt; for boot
  &lt;wait 1/16s&gt; &lt;process IRQ&gt; ;long delay, allow slave to enter IRQ handler
  llllllll     "OKAY"        ;send length in bytes, reply &lt;ready&gt; to boot
  dddddddd     --------      ;send data in 32bit units, reply don't care
  cccccccc     cccccccc      ;exchange crc (all data units added together)
</PRE></TD></TR></TBODY></TABLE>Use 
normal mode, 32bit, external clock for all transfers. The received highspeed 
loader (currently approx. 180h bytes) is to be loaded to and started at 
3000000h, which will then handle the actual download operation.<BR><BR>Below is 
an example program which works with multiboot, burstboot, and as normal 
rom/flashcard. The source can be assembled with a22i (the no$gba built-in 
assembler, see no$gba utility menu). When using other/mainstream assemblers, 
you'll eventually have to change some directives, convert numbers from NNNh into 
0xNNN format, and define the origin somewhere in linker/makefile instead of in 
source code.<BR><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> .arm            ;select 32bit ARM instruction set
 .gba            ;indicate that it's a gameboy advance program
 .fix            ;automatically fix the cartridge header checksum
 org 2000000h    ;origin in RAM for multiboot-cable/no$gba-cutdown programs
 ;------------------
 ;cartridge header/multiboot header
  b     rom_start                ;-rom entry point
  dcb   ...insert logo here...   ;-nintento logo (156 bytes)
  dcb   'XBOO SAMPLE '           ;-title (12 bytes)
  dcb   0,0,0,0,  0,0            ;-game code (4 bytes), maker code (2 bytes)
  dcb   96h,0,0                  ;-fixed value 96h, main unit code, device type
  dcb   0,0,0,0,0,0,0            ;-reserved (7 bytes)
  dcb   0                        ;-software version number
  dcb   0                        ;-header checksum (set by .fix)
  dcb   0,0                      ;-reserved (2 bytes)
  b     ram_start                ;-multiboot ram entry point
  dcb   0,0                      ;-multiboot reserved bytes (destroyed by BIOS)
  dcb   0,0                      ;-blank padded (32bit alignment)
 ;------------------
 irq_handler:  ;interrupt handler (note: r0-r3 are pushed by BIOS)
  mov    r1,4000000h             ;\get I/O base address,
  ldr    r0,[r1,200h] ;IE/IF     ; read IE and IF,
  and    r0,r0,r0,lsr 16         ; isolate occurred AND enabled irqs,
  add    r3,r1,200h   ;IF        ; and acknowledge these in IF
  strh   r0,[r3,2]               ;/
  ldrh   r3,[r1,-8]              ;\mix up with BIOS irq flags at 3007FF8h,
  orr    r3,r3,r0                ; aka mirrored at 3FFFFF8h, this is required
  strh   r3,[r1,-8]              ;/when using the (VBlank-)IntrWait functions
  and    r3,r0,80h ;IE/IF.7 SIO  ;\
  cmp    r3,80h                  ; check if it's a burst boot interrupt
  ldreq  r2,[r1,120h] ;SIODATA32 ; (if interrupt caused by serial transfer,
  ldreq  r3,[msg_brst]           ; and if received data is "BRST",
  cmpeq  r2,r3                   ; then jump to burst boot)
  beq    burst_boot              ;/
  ;... insert your own interrupt handler code here ...
  bx     lr                      ;-return to the BIOS interrupt handler
 ;------------------
 burst_boot:     ;requires incoming r1=4000000h
  ;... if your program uses DMA, disable any active DMA transfers here ...
  ldr   r4,[msg_okay]            ;\
  bl    sio_transfer             ; receive transfer length/bytes &amp; reply "OKAY"
  mov   r2,r0 ;len               ;/
  mov   r3,3000000h   ;dst       ;\
  mov   r4,0  ;crc               ;
 @@lop:                          ;
  bl    sio_transfer             ; download burst loader to 3000000h and up
  stmia [r3]!,r0      ;dst       ;
  add   r4,r4,r0      ;crc       ;
  subs  r2,r2,4       ;len       ;
  bhi   @@lop                    ;/
  bl    sio_transfer             ;-send crc value to master
  b     3000000h  ;ARM state!    ;-launch actual transfer / start the loader
 ;------------------
 sio_transfer:  ;serial transfer subroutine, 32bit normal mode, external clock
  str   r4,[r1,120h]  ;siodata32 ;-set reply/send data
  ldr   r0,[r1,128h]  ;siocnt    ;\
  orr   r0,r0,80h                ; activate slave transfer
  str   r0,[r1,128h]  ;siocnt    ;/
 @@wait:                         ;\
  ldr   r0,[r1,128h]  ;siocnt    ; wait until transfer completed
  tst   r0,80h                   ;
  bne   @@wait                   ;/
  ldr   r0,[r1,120h]  ;siodata32 ;-get received data
  bx    lr
 ;---
 msg_boot dcb 'BOOT'     ;\
 msg_okay dcb "OKAY"     ; ID codes for the burstboot protocol
 msg_brst dcb "BRST"     ;/
 ;------------------
 download_rom_to_ram:
  mov  r0,8000000h  ;src/rom     ;\
  mov  r1,2000000h  ;dst/ram     ;
  mov  r2,40000h/16 ;length      ; transfer the ROM content
 @@lop:                          ; into RAM (done in units of 4 words/16 bytes)
  ldmia [r0]!,r4,r5,r6,r7        ; currently fills whole 256K of RAM,
  stmia [r1]!,r4,r5,r6,r7        ; even though the proggy is smaller
  subs  r2,r2,1                  ;
  bne   @@lop                    ;/
  sub   r15,lr,8000000h-2000000h ;-return (retadr rom/8000XXXh -&gt; ram/2000XXXh)
 ;------------------
 init_interrupts:
  mov  r4,4000000h               ;-base address for below I/O registers
  ldr  r0,=irq_handler           ;\install IRQ handler address
  str  r0,[r4,-4]   ;IRQ HANDLER ;/at 3FFFFFC aka 3007FFC
  mov  r0,0008h                  ;\enable generating vblank irqs
  strh r0,[r4,4h]   ;DISPSTAT    ;/
  mrs  r0,cpsr                   ;\
  bic  r0,r0,80h                 ; cpu interrupt enable (clear i-flag)
  msr  cpsr,r0                   ;/
  mov  r0,0                      ;\
  str  r0,[r4,134h] ;RCNT        ; init SIO normal mode, external clock,
  ldr  r0,=5080h                 ; 32bit, IRQ enable, transfer started
  str  r0,[r4,128h] ;SIOCNT      ; output "BOOT" (indicate burst boot prepared)
  ldr  r0,[msg_boot]             ;
  str  r0,[r4,120h] ;SIODATA32   ;/
  mov  r0,1                      ;\interrupt master enable
  str  r0,[r4,208h] ;IME=1       ;/
  mov  r0,81h                    ;\enable execution of vblank IRQs,
  str  r0,[r4,200h] ;IE=81h      ;/and of SIO IRQs (burst boot)
  bx   lr
 ;------------------
 rom_start:   ;entry point when booted from flashcart/rom
  bl   download_rom_to_ram       ;-download ROM to RAM (returns to ram_start)
 ram_start:   ;entry point for multiboot/burstboot
  mov  r0,0feh                   ;\reset all registers, and clear all memory
  swi  10000h ;RegisterRamReset  ;/(except program code in wram at 2000000h)
  bl   init_interrupts           ;-install burst boot irq handler
  mov  r4,4000000h               ;\enable video,
  strh r4,[r4,000h] ;DISPCNT     ;/by clearing the forced blank bit
 @@mainloop:
  swi  50000h ;VBlankIntrWait    ;-wait one frame (cpu in low power mode)
  mov  r5,5000000h               ;\increment the backdrop palette color
  str  r8,[r5]                   ; (ie. display a blinking screen)
  add  r8,r8,1                   ;/
  b    @@mainloop
 ;------------------
 .pool
 end
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cpureference"></A><FONT size="+2">&nbsp;CPU 
    Reference</FONT></TD></TR></TBODY></TABLE><BR><B>General ARM7TDMI 
Information</B><BR><A href="#cpuoverview">CPU 
Overview</A><BR><A href="#cpuregisterset">CPU 
Register Set</A><BR><A href="#cpuflags">CPU 
Flags</A><BR><A href="#cpuexceptions">CPU 
Exceptions</A><BR><BR><B>The ARM7TDMI Instruction Sets</B><BR><A href="#thumbinstructionset">THUMB 
Instruction Set</A><BR><A href="#arminstructionset">ARM 
Instruction Set</A><BR><A href="#pseudoinstructionsanddirectives">Pseudo 
Instructions and Directives</A><BR><BR><B>Further Information</B><BR><A href="#armcp15systemcontrolcoprocessor">ARM 
CP15 System Control Coprocessor</A><BR><A href="#cpuinstructioncycletimes">CPU 
Instruction Cycle Times</A><BR><A href="#cpuversions">CPU 
Versions</A><BR><A href="#cpudatasheet">CPU 
Data Sheet</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cpuoverview"></A><FONT size="+2">&nbsp;CPU 
  Overview</FONT></TD></TR></TBODY></TABLE><BR>The ARM7TDMI is a 32bit RISC 
(Reduced Instruction Set Computer) CPU, designed by ARM (Advanced RISC 
Machines), and designed for both high performance and low power 
consumption.<BR><BR><B>Fast Execution</B><BR>Depending on the CPU state, all 
opcodes are sized 32bit or 16bit (that's counting both the opcode bits and its 
parameters bits) providing fast decoding and execution. Additionally, pipelining 
allows - (a) one instruction to be executed while (b) the next instruction is 
decoded and (c) the next instruction is fetched from memory - all at the same 
time.<BR><BR><B>Data Formats</B><BR>The CPU manages to deal with 8bit, 16bit, 
and 32bit data, that are called:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>   8bit - Byte
  16bit - Halfword
  32bit - Word
</PRE></TD></TR></TBODY></TABLE><BR><B>The 
two CPU states</B><BR>As mentioned above, two CPU states exist:<BR>- ARM state: 
Uses the full 32bit instruction set (32bit opcodes)<BR>- THUMB state: Uses a 
cutdown 16bit instruction set (16bit opcodes)<BR>Regardless of the opcode-width, 
both states are using 32bit registers, allowing 32bit memory addressing as well 
as 32bit arithmetic/logical operations.<BR><BR><B>When to use ARM state</B><BR>
Basically, there are two advantages in ARM state:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> - Each single opcode provides more functionality, resulting
   in faster execution when using a 32bit bus memory system
   (such like opcodes stored in GBA Work RAM).
 - All registers R0-R15 can be accessed directly.
</PRE></TD></TR></TBODY></TABLE>The 
downsides are:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> - Not so fast when using 16bit memory system
   (but it still works though).
 - Program code occupies more memory space.
</PRE></TD></TR></TBODY></TABLE><BR><B>When 
to use THUMB state</B><BR>There are two major advantages in THUMB state:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> - Faster execution up to approx 160% when using a 16bit bus
   memory system (such like opcodes stored in GBA GamePak ROM).
 - Reduces code size, decreases memory overload down to approx 65%.
</PRE></TD></TR></TBODY></TABLE>The 
disadvantages are:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> - Not as multi-functional opcodes as in ARM state, so it will
   be sometimes required use more than one opcode to gain a
   similar result as for a single opcode in ARM state.
 - Most opcodes allow only registers R0-R7 to be used directly.
</PRE></TD></TR></TBODY></TABLE><BR><B>Combining 
ARM and THUMB state</B><BR>Switching between ARM and THUMB state is done by a 
normal branch (BX) instruction which takes only a handful of cycles to execute 
(allowing to change states as often as desired - with almost no 
overload).<BR><BR>Also, as both ARM and THUMB are using the same register set, 
it is possible to pass data between ARM and THUMB mode very easily.<BR><BR>The 
best memory &amp; execution performance can be gained by combining both states: 
THUMB for normal program code, and ARM code for timing critical subroutines 
(such like interrupt handlers, or complicated algorithms).<BR><BR>Note: ARM and 
THUMB code cannot be executed simultaneously.<BR><BR><B>Automatic state 
changes</B><BR>Beside for the above manual state switching by using BX 
instructions, the following situations involve automatic state changes:<BR>- CPU 
switches to ARM state when executing an exception<BR>- User switches back to old 
state when leaving an exception<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cpuregisterset"></A><FONT size="+2">&nbsp;CPU Register 
      Set</FONT></TD></TR></TBODY></TABLE><BR><B>Overview</B><BR>The following table 
shows the ARM7TDMI register set which is available in each mode. There's a total 
of 37 registers (32bit each), 31 general registers (Rxx) and 6 status registers 
(xPSR).<BR>Note that only some registers are 'banked', for example, each mode 
has it's own R14 register: called R14, R14_fiq, R14_svc, etc. for each mode
 respectively.<BR>However, other registers are not banked, for example, each 
mode is using the same R0 register, so writing to R0 will always affect the 
content of R0 in other modes also.<BR><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE><B>  System/User FIQ       Supervisor Abort     IRQ       Undefined</B>
  --------------------------------------------------------------
  R0          R0        R0         R0        R0        R0
  R1          R1        R1         R1        R1        R1
  R2          R2        R2         R2        R2        R2
  R3          R3        R3         R3        R3        R3
  R4          R4        R4         R4        R4        R4
  R5          R5        R5         R5        R5        R5
  R6          R6        R6         R6        R6        R6
  R7          R7        R7         R7        R7        R7
  --------------------------------------------------------------
  R8          R8_fiq    R8         R8        R8        R8
  R9          R9_fiq    R9         R9        R9        R9
  R10         R10_fiq   R10        R10       R10       R10
  R11         R11_fiq   R11        R11       R11       R11
  R12         R12_fiq   R12        R12       R12       R12
  R13 (SP)    R13_fiq   R13_svc    R13_abt   R13_irq   R13_und
  R14 (LR)    R14_fiq   R14_svc    R14_abt   R14_irq   R14_und
  R15 (PC)    R15       R15        R15       R15       R15
  --------------------------------------------------------------
  CPSR        CPSR      CPSR       CPSR      CPSR      CPSR
  --          SPSR_fiq  SPSR_svc   SPSR_abt  SPSR_irq  SPSR_und
  --------------------------------------------------------------
</PRE></TD></TR></TBODY></TABLE><BR><B>R0-R12 
Registers (General Purpose Registers)</B><BR>These thirteen registers may be 
used for whatever general purposes. Basically, each is having same functionality 
and performance, ie. there is no 'fast accumulator' for arithmetic operations, 
and no 'special pointer register' for memory addressing.<BR>However, in THUMB 
mode only R0-R7 (Lo registers) may be accessed freely, while R8-R12 and up (Hi 
registers) can be accessed only by some instructions.<BR><BR><B>R13 Register 
(SP)</B><BR>This register is used as Stack Pointer (SP) in THUMB state. While in 
ARM state the user may decided to use R13 and/or other register(s) as stack
 pointer(s), or as general purpose register.<BR>As shown in the table above, 
there's a separate R13 register in each mode, and (when used as SP) each 
exception handler may (and MUST!) use its own stack.<BR><BR><B>R14 Register 
(LR)</B><BR>This register is used as Link Register (LR). That is, when calling 
to a sub-routine by a Branch with Link (BL) instruction, then the return address 
(ie. old value of PC) is saved in this register.<BR>Storing the return address 
in the LR register is obviously faster than pushing it into memory, however, as 
there's only one LR register for each mode, the user must manually push its 
content before issuing 'nested' subroutines.<BR>Same happens when an exception 
is called, PC is saved in LR of new mode.<BR>Note: In ARM mode, R14 may be used 
as general purpose register also, provided that above usage as LR register isn't 
required.<BR><BR><B>R15 Register (PC)</B><BR>R15 is always used as program 
counter (PC). Note that when reading R15, this will usually return a value of 
PC+nn because of read-ahead (pipelining), whereas 'nn' depends on the 
instruction and on the CPU state (ARM or THUMB).<BR><BR><B>CPSR and SPSR 
(Program Status Registers) (ARMv3 and up)</B><BR>The current condition codes 
(flags) and CPU control bits are stored in the CPSR register. When an exception 
arises, the old CPSR is saved in the SPSR of the respective exception-mode (much 
like PC is saved in LR).<BR>For details refer to chapter about CPU 
Flags.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cpuflags"></A><FONT size="+2">&nbsp;CPU 
  Flags</FONT></TD></TR></TBODY></TABLE><BR><B>Current Program Status Register 
(CPSR)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  31    N - Sign Flag       (0=Not Signed, 1=Signed)
  30    Z - Zero Flag       (0=Not Zero, 1=Zero)
  29    C - Carry Flag      (0=No Carry, 1=Carry)
  28    V - Overflow Flag   (0=No Overflow, 1=Overflow)
  27    Q - Sticky Overflow (1=Sticky Overflow, ARMv5TE and up only)
  26-8  Reserved            (For future use) - Do not change manually!
  7     I - IRQ disable     (0=Enable, 1=Disable)
  6     F - FIQ disable     (0=Enable, 1=Disable)
  5     T - State Bit       (0=ARM, 1=THUMB) - Do not change manually!
  4-0   M4-M0 - Mode Bits   (See below)
</PRE></TD></TR></TBODY></TABLE><BR><B>Bit 
31-28: Condition Code Flags (N,Z,C,V)</B><BR>These bits reflect results of 
logical or arithmetic instructions. In ARM mode, it is often optionally whether 
an instruction should modify flags or not, for example, it is possible to 
execute a SUB instruction that does NOT modify the condition flags.<BR>In ARM 
state, all instructions can be executed conditionally depending on the settings 
of the flags, such like MOVEQ (Move if Z=1). While In THUMB state, only Branch 
instructions (jumps) can be made conditionally.<BR><BR><B>Bit 27: Sticky 
Overflow Flag (Q) - ARMv5TE and ARMv5TExP and up only</B><BR>Used by QADD, QSUB, 
QDADD, QDSUB, SMLAxy, and SMLAWy only. These opcodes set the Q-flag in case of 
overflows, but leave it unchanged otherwise. The Q-flag can be tested/reset by 
MSR/MRS opcodes only.<BR><BR><B>Bit 27-8: Reserved Bits (except Bit 27 on 
ARMv5TE and up, see above)</B><BR>These bits are reserved for possible future 
implementations. For best forwards compatibility, the user should never change 
the state of these bits, and should not expect these bits to be set to a 
specific value.<BR><BR><B>Bit 7-0: Control Bits (I,F,T,M4-M0)</B><BR>These bits 
may change when an exception occurs. In privileged modes (non-user modes) they 
may be also changed manually.<BR>The interrupt bits I and F are used to disable 
IRQ and FIQ interrupts respectively (a setting of "1" means disabled).<BR>The T 
Bit signalizes the current state of the CPU (0=ARM, 1=THUMB), this bit should 
never be changed manually - instead, changing between ARM and THUMB state must 
be done by BX instructions.<BR>The Mode Bits M4-M0 contain the current operating 
mode.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Binary Hex Dec  Expl.
  10000b 10h 16 - User (non-privileged)
  10001b 11h 17 - FIQ
  10010b 12h 18 - IRQ
  10011b 13h 19 - Supervisor (SWI)
  10111b 17h 23 - Abort
  11011b 1Bh 27 - Undefined
  11111b 1Fh 31 - System (privileged 'User' mode) (ARMv4 and up)
</PRE></TD></TR></TBODY></TABLE>Writing 
any other values into the Mode bits is not allowed.<BR><BR><B>Saved Program 
Status Registers (SPSR_&lt;mode&gt;)</B><BR>Additionally to above CPSR, five 
Saved Program Status Registers exist:<BR>SPSR_fiq, SPSR_svc, SPSR_abt, SPSR_irq, 
SPSR_und<BR>Whenever the CPU enters an exception, the current status register 
(CPSR) is copied to the respective SPSR_&lt;mode&gt; register. Note that there 
is only one SPSR for each mode, so nested exceptions inside of the same mode are 
allowed only if the exception handler saves the content of SPSR in memory.<BR>
For example, for an IRQ exception: IRQ-mode is entered, and CPSR is copied to 
SPSR_irq. If the interrupt handler wants to enable nested IRQs, then it must 
first push SPSR_irq before doing so.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cpuexceptions"></A><FONT size="+2">&nbsp;CPU 
    Exceptions</FONT></TD></TR></TBODY></TABLE><BR>Exceptions are caused by 
interrupts or errors. In the ARM7TDMI the following exceptions may arise, sorted 
by priority, starting with highest priority:<BR>- Reset<BR>- Data Abort<BR>- 
FIQ<BR>- IRQ<BR>- Prefetch Abort<BR>- Software Interrupt<BR>- Undefined 
Instruction<BR><BR><B>Exception Vectors</B><BR>The following are the exception 
vectors in memory. That is, when an exception arises, CPU is switched into ARM 
state, and the program counter (PC) is loaded by the respective address.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Address    Exception                  Mode on Entry      Interrupt Flags
  BASE+00h   Reset                      Supervisor (_svc)  I=1, F=1
  BASE+04h   Undefined Instruction      Undefined  (_und)  I=1, F=unchanged
  BASE+08h   Software Interrupt (SWI)   Supervisor (_svc)  I=1, F=unchanged
  BASE+0Ch   Prefetch Abort             Abort      (_abt)  I=1, F=unchanged
  BASE+10h   Data Abort                 Abort      (_abt)  I=1, F=unchanged
  BASE+14h   (Reserved)                 -          -       -
  BASE+18h   Normal Interrupt (IRQ)     IRQ        (_irq)  I=1, F=unchanged
  BASE+1Ch   Fast Interrupt (FIQ)       FIQ        (_fiq)  I=1, F=1
</PRE></TD></TR></TBODY></TABLE>BASE 
is normally 00000000h, but may be optionally FFFF0000h in some ARM CPUs.<BR>As 
there's only space for one ARM opcode at each of the above addresses, it'd be 
usually recommended to deposit a Branch opcode into each vector, which'd then 
redirect to the actual exception handlers address.<BR><BR><B>Actions performed 
by CPU when entering an exception</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  - R14=PC+nn              ;save old PC, ie. return address
  - SPSR_&lt;new mode&gt;=CPSR   ;save old flags
  - CPSR new T,M bits      ;set to T=0 (ARM state), and M4-0=new mode
  - CPSR new I bit         ;IRQs disabled (I=1), done by ALL exceptions
  - CPSR new F bit         ;FIQs disabled (F=1), done by Reset and FIQ only
  - PC=exception_vector    ;see table above
</PRE></TD></TR></TBODY></TABLE>Above 
"PC+nn" depends on the type of exception. Basically, in ARM state that nn-offset 
is caused by pipelining, and in THUMB state an identical ARM-style 'offset' is 
generated (even though the 'base address' may be only 
halfword-aligned).<BR><BR><B>Required user-handler actions when returning from 
an exception</B><BR>Restore any general registers (R0-R14) which might have been 
modified by the exception handler. Use return-instruction as listed in the
 respective descriptions below, this will both restore PC and CPSR - that
 automatically involves that the old CPU state (THUMB or ARM) as well as old 
state of FIQ and IRQ disable flags are restored.<BR>As mentioned above (see 
action on entering...), the return address is always saved in ARM-style format, 
so that exception handler may use the same return-instruction, regardless of 
whether the exception has been generated from inside of ARM or THUMB 
state.<BR><BR><B>FIQ (Fast Interrupt Request)</B><BR>This interrupt is generated 
by a LOW level on the nFIQ input. It is supposed to process timing critical 
interrupts at a high priority, as fast as possible.<BR>Additionally to the 
common banked registers (R13_fiq,R14_fiq), five extra banked registers 
(R8_fiq-R12_fiq) are available in FIQ mode. The exception handler may freely 
access these registers without modifying the main programs R8-R12 registers (and 
without having to save that registers on stack).<BR>In privileged (non-user) 
modes, FIQs may be also manually disabled by setting the F Bit in 
CPSR.<BR><BR><B>IRQ (Normal Interrupt Request)</B><BR>This interrupt is 
generated by a LOW level on the nIRQ input. Unlike FIQ, the IRQ mode is not 
having its own banked R8-R12 registers.<BR>IRQ is having lower priority than 
FIQ, and IRQs are automatically disabled when a FIQ exception becomes executed. 
In privileged (non-user) modes, IRQs may be also manually disabled by setting 
the I Bit in CPSR.<BR>To return from IRQ Mode (continuing at following 
opcode):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  SUBS PC,R14,4   ;both PC=R14_irq-4, and CPSR=SPSR_irq
</PRE></TD></TR></TBODY></TABLE><BR><B>Software 
Interrupt</B><BR>Generated by a software interrupt instruction (SWI). 
Recommended to request a supervisor (operating system) function. The SWI 
instruction may also contain a parameter in the 'comment field' of the 
opcode:<BR>In case that your main program issues SWIs from both inside of THUMB 
and ARM states, then your exception handler must separate between 24bit comment 
fields in ARM opcodes, and 8bit comment fields in THUMB opcodes (if necessary 
determine old state by examining T Bit in SPSR_svc); However, in Little Endian 
mode, you could use only the most significant 8bits of the 24bit ARM comment 
field (as done in the GBA, for example) - the exception handler could then 
process the BYTE at [R14-2], regardless of whether it's been called from ARM or 
THUMB state.<BR>To return from Supervisor Mode (continuing at following 
opcode):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  MOVS PC,R14   ;both PC=R14_svc, and CPSR=SPSR_svc
</PRE></TD></TR></TBODY></TABLE>Note: 
Like all other exceptions, SWIs are always executed in ARM state, no matter 
whether it's been caused by an ARM or THUMB state SWI
 instruction.<BR><BR><B>Undefined Instruction Exception (supported by ARMv3 and 
up)</B><BR>This exception is generated when the CPU comes across an instruction
 which it cannot handle. Most likely signalizing that the program has locked up, 
and that an errormessage should be displayed.<BR>However, it might be also used 
to emulate custom functions, ie. as an additional 'SWI' instruction (which'd use 
R14_und and SPSR_und though, and it'd thus allow to execute the Undefined 
Instruction handler from inside of Supervisor mode without having to save 
R14_svc and SPSR_svc).<BR>To return from Undefined Mode (continuing at following 
opcode):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  MOVS PC,R14   ;both PC=R14_und, and CPSR=SPSR_und
</PRE></TD></TR></TBODY></TABLE>Note 
that not all unused opcodes are necessarily producing an exception, for example, 
an ARM state Multiply instruction with Bit 6 set to "1" would be blindly 
accepted as 'legal' opcode.<BR><BR><B>Abort (supported by ARMv3 and up)</B><BR>
Aborts (page faults) are mostly supposed for virtual memory systems (ie. not 
used in GBA, as far as I know), otherwise they might be used just to display an 
error message. Two types of aborts exists:<BR>- Prefetch Abort (occurs during an 
instruction prefetch)<BR>- Prefetch Abort (also occurs on BKPT opcodes, ARMv5 
and up)<BR>- Data Abort (occurs during a data access)<BR>A virtual memory 
systems abort handler would then most likely determine the fault address: For 
prefetch abort that's just "R14_abt-4". For Data abort, the THUMB or ARM 
instruction at "R14_abt-8" needs to be 'disassembled' in order to determine the 
addressed data in memory.<BR>The handler would then fix the error by loading the 
respective memory page into physical memory, and then retry to execute the SAME
 instruction again, by returning as follows:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  prefetch abort: SUBS PC,R14,#4   ;PC=R14_abt-4, and CPSR=SPSR_abt
  data abort:     SUBS PC,R14,#8   ;PC=R14_abt-8, and CPSR=SPSR_abt
</PRE></TD></TR></TBODY></TABLE>Separate 
exception vectors for prefetch/data abort exists, each should use the respective 
return instruction as shown above.<BR><BR><B>Reset</B><BR>Forces PC=VVVV0000h, 
and forces control bits of CPSR to T=0 (ARM state), F=1 and I=1 (disable FIQ and 
IRQ), and M4-0=10011b (Supervisor mode).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumbinstructionset"></A><FONT size="+2">&nbsp;THUMB 
      Instruction Set</FONT></TD></TR></TBODY></TABLE><BR>When operating in THUMB 
state, cut-down 16bit opcodes are used.<BR>THUMB supported on T-variants of 
ARMv4 and up, ie. ARMv4T, ARMv5T, etc.<BR><BR><B>Summary</B><BR><A href="#thumbinstructionsummary">THUMB 
Instruction Summary</A><BR><BR><B>Register Operations</B><BR><A href="#thumb1moveshiftedregister">THUMB.1: 
move shifted register</A><BR><A href="#thumb2addsubtract">THUMB.2: 
add/subtract</A><BR><A href="#thumb3movecompareaddsubtractimmediate">THUMB.3: 
move/compare/add/subtract immediate</A><BR><A href="#thumb4aluoperations">THUMB.4: 
ALU operations</A><BR><A href="#thumb5hiregisteroperationsbranchexchange">THUMB.5: 
Hi register operations/branch exchange</A><BR><BR><B>Memory Addressing 
Operations</B><BR><A href="#thumb6loadpcrelative">THUMB.6: 
load PC-relative</A><BR><A href="#thumb7loadstorewithregisteroffset">THUMB.7: 
load/store with register offset</A><BR><A href="#thumb8loadstoresignextendedbytehalfword">THUMB.8: 
load/store sign-extended byte/halfword</A><BR><A href="#thumb9loadstorewithimmediateoffset">THUMB.9: 
load/store with immediate offset</A><BR><A href="#thumb10loadstorehalfword">THUMB.10: 
load/store halfword</A><BR><A href="#thumb11loadstoresprelative">THUMB.11: 
load/store SP-relative</A><BR><A href="#thumb12getrelativeaddress">THUMB.12: 
get relative address</A><BR><A href="#thumb13addoffsettostackpointer">THUMB.13: 
add offset to stack pointer</A><BR><A href="#thumb14pushpopregisters">THUMB.14: 
push/pop registers</A><BR><A href="#thumb15multipleloadstore">THUMB.15: 
multiple load/store</A><BR><BR><B>Jumps and Calls</B><BR><A href="#thumb16conditionalbranch">THUMB.16: 
conditional branch</A><BR><A href="#thumb17softwareinterruptandbreakpoint">THUMB.17: 
software interrupt and breakpoint</A><BR><A href="#thumb18unconditionalbranch">THUMB.18: 
unconditional branch</A><BR><A href="#thumb19longbranchwithlink">THUMB.19: 
long branch with link</A><BR>(See also THUMB.5: BX Rs, and ADD/MOV 
PC,Rs.)<BR><BR><B>Note:</B><BR>Switching between ARM and THUMB state can be done 
by using the Branch and Exchange (BX) instruction.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumbinstructionsummary"></A><FONT size="+2">&nbsp;THUMB 
      Instruction Summary</FONT></TD></TR></TBODY></TABLE><BR>The table below lists 
all THUMB mode instructions with clock cycles, affected CPSR flags, 
Format/chapter number, and description.<BR>Only register R0..R7 can be used in 
thumb mode (unless R8-15,SP,PC are explicitly mentioned).<BR><BR><B>Logical 
Operations</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Instruction        Cycles Flags Format Expl.
  MOV Rd,Imm8bit      1S     NZ--  3   Rd=nn
  MOV Rd,Rs           1S     NZ00  2   Rd=Rs+0
  MOV R0..14,R8..15   1S     ----  5   Rd=Rs
  MOV R8..14,R0..15   1S     ----  5   Rd=Rs
  MOV R15,R0..15      2S+1N  ----  5   PC=Rs
  MVN Rd,Rs           1S     NZ--  4   Rd=NOT Rs
  AND Rd,Rs           1S     NZ--  4   Rd=Rd AND Rs
  TST Rd,Rs           1S     NZ--  4 Void=Rd AND Rs
  BIC Rd,Rs           1S     NZ--  4   Rd=Rd AND NOT Rs
  ORR Rd,Rs           1S     NZ--  4   Rd=Rd OR Rs
  EOR Rd,Rs           1S     NZ--  4   Rd=Rd XOR Rs
  LSL Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SHL nn
  LSL Rd,Rs           1S+1I  NZc-  4   Rd=Rd SHL (Rs AND 0FFh)
  LSR Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SHR nn
  LSR Rd,Rs           1S+1I  NZc-  4   Rd=Rd SHR (Rs AND 0FFh)
  ASR Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SRA nn
  ASR Rd,Rs           1S+1I  NZc-  4   Rd=Rd SRA (Rs AND 0FFh)
  ROR Rd,Rs           1S+1I  NZc-  4   Rd=Rd ROR (Rs AND 0FFh)
  NOP                 1S     ----  5   R8=R8
</PRE></TD></TR></TBODY></TABLE>Carry flag affected only if 
shift amount is non-zero.<BR><BR><B>Arithmetic Operations and Multiply</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Instruction        Cycles Flags Format Expl.
  ADD Rd,Rs,Imm3bit   1S     NZCV  2   Rd=Rs+nn
  ADD Rd,Imm8bit      1S     NZCV  3   Rd=Rd+nn
  ADD Rd,Rs,Rn        1S     NZCV  2   Rd=Rs+Rn
  ADD R0..14,R8..15   1S     ----  5   Rd=Rd+Rs
  ADD R8..14,R0..15   1S     ----  5   Rd=Rd+Rs
  ADD R15,R0..15      2S+1N  ----  5   PC=Rd+Rs
  ADD Rd,PC,Imm8bit*4 1S     ---- 12   Rd=(($+4) AND NOT 2)+nn
  ADD Rd,SP,Imm8bit*4 1S     ---- 12   Rd=SP+nn
  ADD SP,Imm7bit*4    1S     ---- 13   SP=SP+nn
  ADD SP,-Imm7bit*4   1S     ---- 13   SP=SP-nn
  ADC Rd,Rs           1S     NZCV  4   Rd=Rd+Rs+Cy
  SUB Rd,Rs,Imm3Bit   1S     NZCV  2   Rd=Rs-nn
  SUB Rd,Imm8bit      1S     NZCV  3   Rd=Rd-nn
  SUB Rd,Rs,Rn        1S     NZCV  2   Rd=Rs-Rn
  SBC Rd,Rs           1S     NZCV  4   Rd=Rd-Rs-NOT Cy
  NEG Rd,Rs           1S     NZCV  4   Rd=0-Rs
  CMP Rd,Imm8bit      1S     NZCV  3 Void=Rd-nn
  CMP Rd,Rs           1S     NZCV  4 Void=Rd-Rs
  CMP R0-15,R8-15     1S     NZCV  5 Void=Rd-Rs
  CMP R8-15,R0-15     1S     NZCV  5 Void=Rd-Rs
  CMN Rd,Rs           1S     NZCV  4 Void=Rd+Rs
  MUL Rd,Rs           1S+mI  NZx-  4   Rd=Rd*Rs
</PRE></TD></TR></TBODY></TABLE><BR><B>Jumps 
and Calls</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Instruction        Cycles    Flags Format Expl.
  B disp              2S+1N     ---- 18  PC=$+/-2048
  BL disp             3S+1N     ---- 19  PC=$+/-4M, LR=$+5
  B{cond=true} disp   2S+1N     ---- 16  PC=$+/-0..256
  B{cond=false} disp  1S        ---- 16  N/A
  BX R0..15           2S+1N     ----  5  PC=Rs, ARM/THUMB (Rs bit0)
  SWI Imm8bit         2S+1N     ---- 17  PC=8, ARM SVC mode, LR=$+2
  BKPT Imm8bit        ???       ---- 17  ??? ARM9 Prefetch Abort
  BLX disp            ???       ---- ??? ??? ARM9
  BLX R0..R14         ???       ---- ??? ??? ARM9
  POP {Rlist,}PC   (n+1)S+2N+1I ---- 14
  MOV R15,R0..15      2S+1N     ----  5  PC=Rs
  ADD R15,R0..15      2S+1N     ----  5  PC=Rd+Rs
</PRE></TD></TR></TBODY></TABLE>The 
thumb BL instruction occupies two 16bit opcodes, 32bit in 
total.<BR><BR><B>Memory Load/Store</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Instruction        Cycles    Flags Format Expl.
  LDR  Rd,[Rb,5bit*4] 1S+1N+1I  ----  9  Rd = WORD[Rb+nn]
  LDR  Rd,[PC,8bit*4] 1S+1N+1I  ----  6  Rd = WORD[PC+nn]
  LDR  Rd,[SP,8bit*4] 1S+1N+1I  ---- 11  Rd = WORD[SP+nn]
  LDR  Rd,[Rb,Ro]     1S+1N+1I  ----  7  Rd = WORD[Rb+Ro]
  LDRB Rd,[Rb,5bit*1] 1S+1N+1I  ----  9  Rd = BYTE[Rb+nn]
  LDRB Rd,[Rb,Ro]     1S+1N+1I  ----  7  Rd = BYTE[Rb+Ro]
  LDRH Rd,[Rb,5bit*2] 1S+1N+1I  ---- 10  Rd = HALFWORD[Rb+nn]
  LDRH Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = HALFWORD[Rb+Ro]
  LDSB Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = SIGNED_BYTE[Rb+Ro]
  LDSH Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = SIGNED_HALFWORD[Rb+Ro]
  STR  Rd,[Rb,5bit*4] 2N        ----  9  WORD[Rb+nn] = Rd
  STR  Rd,[SP,8bit*4] 2N        ---- 11  WORD[SP+nn] = Rd
  STR  Rd,[Rb,Ro]     2N        ----  7  WORD[Rb+Ro] = Rd
  STRB Rd,[Rb,5bit*1] 2N        ----  9  BYTE[Rb+nn] = Rd
  STRB Rd,[Rb,Ro]     2N        ----  7  BYTE[Rb+Ro] = Rd
  STRH Rd,[Rb,5bit*2] 2N        ---- 10  HALFWORD[Rb+nn] = Rd
  STRH Rd,[Rb,Ro]     2N        ----  8  HALFWORD[Rb+Ro]=Rd
  PUSH {Rlist}{LR}    (n-1)S+2N ---- 14
  POP  {Rlist}{PC}              ---- 14  (ARM9: with mode switch)
  STMIA Rb!,{Rlist}   (n-1)S+2N ---- 15
  LDMIA Rb!,{Rlist}   nS+1N+1I  ---- 15
</PRE></TD></TR></TBODY></TABLE><BR><B>THUMB 
Binary Opcode Format</B><BR>This table summarizes the position of 
opcode/parameter bits for THUMB mode instructions, Format 1-19.<BR><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> Form|_15|_14|_13|_12|_11|_10|_9_|_8_|_7_|_6_|_5_|_4_|_3_|_2_|_1_|_0_|
 __1_|_0___0___0_|__Op___|_______Offset______|____Rs_____|____Rd_____|Shifted
 __2_|_0___0___0___1___1_|_I,_Op_|___Rn/nn___|____Rs_____|____Rd_____|ADD/SUB
 __3_|_0___0___1_|__Op___|____Rd_____|_____________Offset____________|Immedi.
 __4_|_0___1___0___0___0___0_|______Op_______|____Rs_____|____Rd_____|AluOp
 __5_|_0___1___0___0___0___1_|__Op___|Hd_|Hs_|____Rs_____|____Rd_____|HiReg/BX
 __6_|_0___1___0___0___1_|____Rd_____|_____________Word______________|LDR PC
 __7_|_0___1___0___1_|__Op___|_0_|___Ro______|____Rb_____|____Rd_____|LDR/STR
 __8_|_0___1___0___1_|__Op___|_1_|___Ro______|____Rb_____|____Rd_____|""H/SB/SH
 __9_|_0___1___1_|__Op___|_______Offset______|____Rb_____|____Rd_____|""{B}
 _10_|_1___0___0___0_|Op_|_______Offset______|____Rb_____|____Rd_____|""H
 _11_|_1___0___0___1_|Op_|____Rd_____|_____________Word______________|"" SP
 _12_|_1___0___1___0_|Op_|____Rd_____|_____________Word______________|ADD PC/SP
 _13_|_1___0___1___1___0___0___0___0_|_S_|___________Word____________|ADD SP,nn
 _14_|_1___0___1___1_|Op_|_1___0_|_R_|____________Rlist______________|PUSH/POP
 _17_|_1___0___1___1___1___1___1___0_|___________User_Data___________|BKPT ARM9
 _15_|_1___1___0___0_|Op_|____Rb_____|____________Rlist______________|STM/LDM
 _16_|_1___1___0___1_|_____Cond______|_________Signed_Offset_________|B{cond}
 _U__|_1___1___0___1___1___1___1___0_|_____________var_______________|UNDEF ARM9
 _17_|_1___1___0___1___1___1___1___1_|___________User_Data___________|SWI
 _18_|_1___1___1___0___0_|________________Offset_____________________|B
 _19_|_1___1___1___0___1_|_________________________var___________|_0_|BLXsuf ARM9
 _U__|_1___1___1___0___1_|_________________________var___________|_1_|UNDEF ARM9
 _19_|_1___1___1___1_|_H_|______________Offset_Low/High______________|BL (BLX ARM9)
</PRE></TD></TR></TBODY></TABLE><BR><BR>
Further UNDEFS ??? ARM9?<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> 1011 0001 xxxxxxxx (reserved)
 1011 0x1x xxxxxxxx (reserved)
 1011 10xx xxxxxxxx (reserved)
 1011 1111 xxxxxxxx (reserved)
 1101 1110 xxxxxxxx (free for user)
</PRE></TD></TR></TBODY></TABLE><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb1moveshiftedregister"></A><FONT size="+2">&nbsp;THUMB.1: 
      move shifted register</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode 
Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-13  Must be 000b for 'move shifted register' instructions
  12-11  Opcode
           00b: LSL Rd,Rs,#Offset   (logical/arithmetic shift left)
           01b: LSR Rd,Rs,#Offset   (logical    shift right)
           10b: ASR Rd,Rs,#Offset   (arithmetic shift right)
           11b: Reserved (used for add/subtract instructions)
  10-6   Offset                     (0-31)
  5-3    Rs - Source register       (R0..R7)
  2-0    Rd - Destination register  (R0..R7)
</PRE></TD></TR></TBODY></TABLE>Example: 
LSL Rd,Rs,#nn ; Rd = Rs &lt;&lt; nn ; ARM equivalent: MOVS Rd,Rs,LSL #nn<BR>Zero 
shift amount is having special meaning (same as for ARM shifts), LSL#0 performs 
no shift (the the carry flag remains unchanged), LSR/ASR#0 are interpreted as 
LSR/ASR#32. Attempts to specify LSR/ASR#0 in source code are automatically 
redirected as LSL#0, and source LSR/ASR#32 is redirected as opcode 
LSR/ASR#0.<BR>Execution Time: 1S<BR>Flags: Z=zeroflag, N=sign, C=carry (except 
LSL#0: C=unchanged), V=unchanged.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb2addsubtract"></A><FONT size="+2">&nbsp;THUMB.2: 
      add/subtract</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-11  Must be 00011b for 'add/subtract' instructions
  10-9   Opcode (0-3)
           0: ADD Rd,Rs,Rn   ;add register        Rd=Rs+Rn
           1: SUB Rd,Rs,Rn   ;subtract register   Rd=Rs-Rn
           2: ADD Rd,Rs,#nn  ;add immediate       Rd=Rs+nn
           3: SUB Rd,Rs,#nn  ;subtract immediate  Rd=Rs-nn
         Pseudo/alias opcode with Imm=0:
           2: MOV Rd,Rs      ;move (affects cpsr) Rd=Rs+0
  8-6    For Register Operand:
           Rn - Register Operand (R0..R7)
         For Immediate Operand:
           nn - Immediate Value  (0-7)
  5-3    Rs - Source register       (R0..R7)
  2-0    Rd - Destination register  (R0..R7)
</PRE></TD></TR></TBODY></TABLE>Return: 
Rd contains result, N,Z,C,V affected (including MOV).<BR>Execution Time: 
1S<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb3movecompareaddsubtractimmediate"></A><FONT 
      size="+2">&nbsp;THUMB.3: move/compare/add/subtract 
  immediate</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-13  Must be 001b for this type of instructions
  12-11  Opcode
           00b: MOV Rd,#nn      ;move     Rd   = #nn
           01b: CMP Rd,#nn      ;compare  Void = Rd - #nn
           10b: ADD Rd,#nn      ;add      Rd   = Rd + #nn
           11b: SUB Rd,#nn      ;subtract Rd   = Rd - #nn
  10-8   Rd - Destination Register  (R0..R7)
  7-0    nn - Unsigned Immediate    (0-255)
</PRE></TD></TR></TBODY></TABLE>ARM 
equivalents for MOV/CMP/ADD/SUB are MOVS/CMP/ADDS/SUBS same format.<BR>Execution 
Time: 1S<BR>Return: Rd contains result (except CMP), N,Z,C,V affected (for MOV 
only N,Z).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb4aluoperations"></A><FONT size="+2">&nbsp;THUMB.4: ALU 
      operations</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-10  Must be 010000b for this type of instructions
  9-6    Opcode (0-Fh)
           0: AND Rd,Rs     ;AND logical       Rd = Rd AND Rs
           1: EOR Rd,Rs     ;XOR logical       Rd = Rd XOR Rs
           2: LSL Rd,Rs     ;log. shift left   Rd = Rd &lt;&lt; (Rs AND 0FFh)
           3: LSR Rd,Rs     ;log. shift right  Rd = Rd &gt;&gt; (Rs AND 0FFh)
           4: ASR Rd,Rs     ;arit shift right  Rd = Rd SRA Rs
           5: ADC Rd,Rs     ;add with carry    Rd = Rd + Rs + Cy
           6: SBC Rd,Rs     ;sub with carry    Rd = Rd - Rs - NOT Cy
           7: ROR Rd,Rs     ;rotate right      Rd = Rd ROR (Rs AND 0FFh)
           8: TST Rd,Rs     ;test            Void = Rd AND (Rs AND 0FFh)
           9: NEG Rd,Rs     ;negate            Rd = 0 - Rs
           A: CMP Rd,Rs     ;compare         Void = Rd - Rs
           B: CMN Rd,Rs     ;neg.compare     Void = Rd + Rs
           C: ORR Rd,Rs     ;OR logical        Rd = Rd OR Rs
           D: MUL Rd,Rs     ;multiply          Rd = Rd * Rs
           E: BIC Rd,Rs     ;bit clear         Rd = Rd AND NOT Rs
           F: MVN Rd,Rs     ;not               Rd = NOT Rs
  5-3    Rs - Source Register       (R0..R7)
  2-0    Rd - Destination Register  (R0..R7)
</PRE></TD></TR></TBODY></TABLE>ARM 
equivalent for NEG would be RSBS.<BR>Return: Rd contains result (except 
TST,CMP,CMN),<BR>Affected Flags:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  N,Z,C,V for  ADC,SBC,NEG,CMP,CMN
  N,Z,C   for  LSL,LSR,ASR,ROR (carry flag unchanged if zero shift amount)
  N,Z,C   for  MUL on ARMv4 and below: carry flag destroyed
  N,Z     for  MUL on ARMv5 and above: carry flag unchanged
  N,Z     for  AND,EOR,TST,ORR,BIC,MVN
</PRE></TD></TR></TBODY></TABLE>Execution 
Time:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  1S      for  AND,EOR,ADC,SBC,TST,NEG,CMP,CMN,ORR,BIC,MVN
  1S+1I   for  LSL,LSR,ASR,ROR
  1S+mI   for  MUL (m=1..4 depending on MSBs of incoming Rd value)
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb5hiregisteroperationsbranchexchange"></A><FONT 
      size="+2">&nbsp;THUMB.5: Hi register operations/branch 
  exchange</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-10  Must be 010001b for this type of instructions
  9-8    Opcode (0-3)
           0: ADD Rd,Rs   ;add        Rd = Rd+Rs
           1: CMP Rd,Rs   ;compare  Void = Rd-Rs  ;CPSR affected
           2: MOV Rd,Rs   ;move       Rd = Rs
           2: NOP         ;nop        R8 = R8
           3: BX  Rs      ;jump       PC = Rs     ;may switch THUMB/ARM
           3: BLX Rs      ;call       PC = Rs     ;may switch THUMB/ARM (ARM9)
  7      MSBd - Destination Register most significant bit (or BL/BLX flag)
  6      MSBs - Source Register most significant bit
  5-3    Rs - Source Register        (together with MSBs: R0..R15)
  2-0    Rd - Destination Register   (together with MSBd: R0..R15)
</PRE></TD></TR></TBODY></TABLE>Restrictions: 
For ADD/CMP/MOV, MSBs and/or MSBd must be set, ie. it is not allowed that both 
are cleared.<BR>When using R15 (PC) as operand, the value will be the address of 
the instruction plus 4.<BR>For BX, MSBs may be 0 or 1, MSBd must be zero, Rd is 
not used/zero.<BR>For BLX, MSBs may be 0 or 1, MSBd must be set, Rd is not 
used/zero.<BR>For BX/BLX, when Bit 0 of the value in Rs is zero:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Processor will be switched into ARM mode!
  If so, Bit 1 of Rs must be cleared (32bit word aligned).
  Thus, BX PC (switch to ARM) may be issued from word-aligned address
  only, the destination is PC+4 (ie. the following halfword is skipped).
</PRE></TD></TR></TBODY></TABLE>BLX 
may not use R15. BLX saves the return address as LR=PC+3 (with thumb bit).<BR>
Assemblers/Disassemblers should use MOV R8,R8 as NOP (in THUMB mode).<BR>Return: 
Only CMP affects CPSR condition flags!<BR>Execution Time:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> 1S     for ADD/MOV/CMP
 2S+1N  for ADD/MOV with Rd=R15, and for BX
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb6loadpcrelative"></A><FONT size="+2">&nbsp;THUMB.6: load 
      PC-relative</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-11  Must be 01001b for this type of instructions
  N/A    Opcode (fixed)
           LDR Rd,[PC,#nn]      ;load 32bit    Rd = WORD[PC+nn]
  10-8   Rd - Destination Register   (R0..R7)
  7-0    nn - Unsigned offset        (0-1020 in steps of 4)
</PRE></TD></TR></TBODY></TABLE>The 
value of PC will be interpreted as (($+4) AND NOT 2).<BR>Return: No flags 
affected, data loaded into Rd.<BR>Execution Time: 1S+1N+1I<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb7loadstorewithregisteroffset"></A><FONT 
      size="+2">&nbsp;THUMB.7: load/store with register 
  offset</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-12  Must be 0101b for this type of instructions
  11-10  Opcode (0-3)
          0: STR  Rd,[Rb,Ro]   ;store 32bit data  WORD[Rb+Ro] = Rd
          1: STRB Rd,[Rb,Ro]   ;store  8bit data  BYTE[Rb+Ro] = Rd
          2: LDR  Rd,[Rb,Ro]   ;load  32bit data  Rd = WORD[Rb+Ro]
          3: LDRB Rd,[Rb,Ro]   ;load   8bit data  Rd = BYTE[Rb+Ro]
  9      Must be zero (0) for this type of instructions
  8-6    Ro - Offset Register              (R0..R7)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</PRE></TD></TR></TBODY></TABLE>Return: 
No flags affected, data loaded either into Rd or into memory.<BR>Execution Time: 
1S+1N+1I for LDR, or 2N for STR<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb8loadstoresignextendedbytehalfword"></A><FONT 
      size="+2">&nbsp;THUMB.8: load/store sign-extended 
  byte/halfword</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-12  Must be 0101b for this type of instructions
  11-10  Opcode (0-3)
          0: STRH Rd,[Rb,Ro]  ;store 16bit data          HALFWORD[Rb+Ro] = Rd
          1: LDSB Rd,[Rb,Ro]  ;load sign-extended 8bit   Rd = BYTE[Rb+Ro]
          2: LDRH Rd,[Rb,Ro]  ;load zero-extended 16bit  Rd = HALFWORD[Rb+Ro]
          3: LDSH Rd,[Rb,Ro]  ;load sign-extended 16bit  Rd = HALFWORD[Rb+Ro]
  9      Must be set (1) for this type of instructions
  8-6    Ro - Offset Register              (R0..R7)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</PRE></TD></TR></TBODY></TABLE>Return: 
No flags affected, data loaded either into Rd or into memory.<BR>Execution Time: 
1S+1N+1I for LDR, or 2N for STR<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb9loadstorewithimmediateoffset"></A><FONT 
      size="+2">&nbsp;THUMB.9: load/store with immediate 
  offset</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-13  Must be 011b for this type of instructions
  12-11  Opcode (0-3)
          0: STR  Rd,[Rb,#nn]  ;store 32bit data   WORD[Rb+nn] = Rd
          1: LDR  Rd,[Rb,#nn]  ;load  32bit data   Rd = WORD[Rb+nn]
          2: STRB Rd,[Rb,#nn]  ;store  8bit data   BYTE[Rb+nn] = Rd
          3: LDRB Rd,[Rb,#nn]  ;load   8bit data   Rd = BYTE[Rb+nn]
  10-6   nn - Unsigned Offset              (0-31 for BYTE, 0-124 for WORD)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</PRE></TD></TR></TBODY></TABLE>Return: 
No flags affected, data loaded either into Rd or into memory.<BR>Execution Time: 
1S+1N+1I for LDR, or 2N for STR<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb10loadstorehalfword"></A><FONT size="+2">&nbsp;THUMB.10: 
      load/store halfword</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-12  Must be 1000b for this type of instructions
  11     Opcode (0-1)
          0: STRH Rd,[Rb,#nn]  ;store 16bit data   HALFWORD[Rb+nn] = Rd
          1: LDRH Rd,[Rb,#nn]  ;load  16bit data   Rd = HALFWORD[Rb+nn]
  10-6   nn - Unsigned Offset              (0-62, step 2)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</PRE></TD></TR></TBODY></TABLE>Return: 
No flags affected, data loaded either into Rd or into memory.<BR>Execution Time: 
1S+1N+1I for LDR, or 2N for STR<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb11loadstoresprelative"></A><FONT 
      size="+2">&nbsp;THUMB.11: load/store 
SP-relative</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-12  Must be 1001b for this type of instructions
  11     Opcode (0-1)
          0: STR  Rd,[SP,#nn]  ;store 32bit data   WORD[SP+nn] = Rd
          1: LDR  Rd,[SP,#nn]  ;load  32bit data   Rd = WORD[SP+nn]
  10-8   Rd - Source/Destination Register  (R0..R7)
  7-0    nn - Unsigned Offset              (0-1020, step 4)
</PRE></TD></TR></TBODY></TABLE>Return: 
No flags affected, data loaded either into Rd or into memory.<BR>Execution Time: 
1S+1N+1I for LDR, or 2N for STR<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb12getrelativeaddress"></A><FONT 
      size="+2">&nbsp;THUMB.12: get relative 
address</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-12  Must be 1010b for this type of instructions
  11     Opcode/Source Register (0-1)
          0: ADD  Rd,PC,#nn    ;Rd = (($+4) AND NOT 2) + nn
          1: ADD  Rd,SP,#nn    ;Rd = SP + nn
  10-8   Rd - Destination Register         (R0..R7)
  7-0    nn - Unsigned Offset              (0-1020, step 4)
</PRE></TD></TR></TBODY></TABLE>Return: 
No flags affected, result in Rd.<BR>Execution Time: 1S<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb13addoffsettostackpointer"></A><FONT 
      size="+2">&nbsp;THUMB.13: add offset to stack 
pointer</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-8   Must be 10110000b for this type of instructions
  7      Opcode/Sign
          0: ADD  SP,#nn       ;SP = SP + nn
          1: ADD  SP,#-nn      ;SP = SP - nn
  6-0    nn - Unsigned Offset    (0-508, step 4)
</PRE></TD></TR></TBODY></TABLE>Return: 
No flags affected, SP adjusted.<BR>Execution Time: 1S<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb14pushpopregisters"></A><FONT size="+2">&nbsp;THUMB.14: 
      push/pop registers</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-12  Must be 1011b for this type of instructions
  11     Opcode (0-1)
          0: PUSH {Rlist}{LR}   ;store in memory, decrements SP (R13)
          1: POP  {Rlist}{PC}   ;load from memory, increments SP (R13)
  10-9   Must be 10b for this type of instructions
  8      PC/LR Bit (0-1)
          0: No
          1: PUSH LR (R14), or POP PC (R15)
  7-0    Rlist - List of Registers (R7..R0)
</PRE></TD></TR></TBODY></TABLE>In 
THUMB mode stack is always meant to be 'full descending', ie. PUSH is equivalent 
to 'STMFD/STMDB' and POP to 'LDMFD/LDMIA' in ARM mode.<BR><BR>Examples:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> PUSH {R0-R3}     ;push R0,R1,R2,R3
 PUSH {R0,R2,LR}  ;push R0,R2,LR
 POP  {R4,R7}     ;pop R4,R7
 POP  {R2-R4,PC}  ;pop R2,R3,R4,PC
</PRE></TD></TR></TBODY></TABLE>Note: 
When calling to a sub-routine, the return address is stored in LR register, when 
calling further sub-routines, PUSH {LR} must be used to save higher return 
address on stack. If so, POP {PC} can be later used to return from the 
sub-routine.<BR>POP {PC} ignores the least significant bit of the return address
 (processor remains in thumb state even if bit0 was cleared), when intending to 
return with optional mode switch, use a POP/BX combination (eg. POP {R3} / BX 
R3).<BR>ARM9: POP {PC} copies the LSB to thumb bit (switches to ARM if 
bit0=0).<BR>Return: No flags affected, SP adjusted, registers loaded/stored.<BR>
Execution Time: nS+1N+1I (POP), (n+1)S+2N+1I (POP PC), or (n-1)S+2N 
(PUSH).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb15multipleloadstore"></A><FONT size="+2">&nbsp;THUMB.15: 
      multiple load/store</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-12  Must be 1100b for this type of instructions
  11     Opcode (0-1)
          0: STMIA Rb!,{Rlist}   ;store in memory, increments Rb
          1: LDMIA Rb!,{Rlist}   ;load from memory, increments Rb
  10-8   Rb - Base register (modified) (R0-R7)
  7-0    Rlist - List of Registers     (R7..R0)
</PRE></TD></TR></TBODY></TABLE>Both 
STM and LDM are incrementing the Base Register.<BR>The lowest register in the 
list (ie. R0, if it's in the list) is stored/loaded at the lowest memory 
address.<BR>Examples:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> STMIA R7!,{R0-R2}  ;store R0,R1,R2
 LDMIA R0!,{R1,R5}  ;store R1,R5
</PRE></TD></TR></TBODY></TABLE>Return: 
No flags affected, Rb adjusted, registers loaded/stored.<BR>Execution Time: 
nS+1N+1I for LDM, or (n-1)S+2N for STM.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb16conditionalbranch"></A><FONT size="+2">&nbsp;THUMB.16: 
      conditional branch</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-12  Must be 1101b for this type of instructions
  11-8   Opcode/Condition (0-Fh)
          0: BEQ label   ;Z=1         ;equal (zero)
          1: BNE label   ;Z=0         ;not equal (nonzero)
          2: BCS label   ;C=1         ;unsigned higher or same (carry set)
          3: BCC label   ;C=0         ;unsigned lower (carry cleared)
          4: BMI label   ;N=1         ;negative (minus)
          5: BPL label   ;N=0         ;positive or zero (plus)
          6: BVS label   ;V=1         ;overflow (V set)
          7: BVC label   ;V=0         ;no overflowplus (V cleared)
          8: BHI label   ;C=1 and Z=0 ;unsigned higher
          9: BLS label   ;C=0 or Z=1  ;unsigned lower or same
          A: BGE label   ;N=V         ;greater or equal
          B: BLT label   ;N&lt;&gt;V        ;less than
          C: BGT label   ;Z=0 and N=V ;greater than
          D: BLE label   ;Z=1 or N&lt;&gt;V ;less or equal
          E: Undefined, should not be used
          F: Reserved for SWI instruction (see SWI opcode)
  7-0    Signed Offset, step 2 ($+4-256..$+4+254)
</PRE></TD></TR></TBODY></TABLE>Destination 
address must by halfword aligned (ie. bit 0 cleared)<BR>Return: No flags 
affected, PC adjusted if condition true<BR>Execution Time:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  2S+1N   if condition true (jump executed)
  1S      if condition false
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb17softwareinterruptandbreakpoint"></A><FONT 
      size="+2">&nbsp;THUMB.17: software interrupt and 
  breakpoint</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-8   Opcode
          11011111b: SWI nn   ;software interrupt
          10111110b: BKPT nn  ;software breakpoint (ARMv5 and up)
  7-0    nn - Comment Immediate    (0-255)
</PRE></TD></TR></TBODY></TABLE>SWI 
supposed for calls to the operating system - Enter Supervisor mode (SVC) in ARM 
state. BKPT intended for debugging - enters Abort mode in ARM state via Prefetch 
Abort vector.<BR><BR>Execution SWI/BKPT:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  R14_svc=PC+2     R14_abt=PC+4   ;save return address
  SPSR_svc=CPSR    SPSR_abt=CPSR  ;save CPSR flags
  CPSR=&lt;changed&gt;   CPSR=&lt;changed&gt; ;Enter svc/abt, ARM state, IRQs disabled
  PC=VVVV0008h     PC=VVVV000Ch   ;jump to SWI/PrefetchAbort vector address
</PRE></TD></TR></TBODY></TABLE>Execution 
Time: 2S+1N<BR><BR>Interpreting the Comment Field:<BR>The immediate parameter is 
ignored by the processor, the user interrupt handler may read-out this number by 
examining the lower 8bit of the 16bit opcode opcode at [R14_svc-2]. In case that 
your program executes SWI's from inside of ARM mode also: Your SWI handler must 
then examine the T Bit SPSR_svc in order to determine whether it's been a ARM 
SWI - if so, examining the lower 24bit of the 32bit opcode opcode at 
[R14_svc-4].<BR><BR>For Returning from SWI use this instruction:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  MOVS PC,R14
</PRE></TD></TR></TBODY></TABLE>That instructions does both 
restoring PC and CPSR, ie. PC=R14_svc, and CPSR=SPRS_svc. In this case (as 
called from THUMB mode), this does also include restoring THUMB mode.<BR><BR>
Nesting SWIs:<BR>SPSR_svc and R14_svc should be saved on stack before either 
invoking nested SWIs, or (if the IRQ handler uses SWIs) before enabling 
IRQs.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb18unconditionalbranch"></A><FONT 
      size="+2">&nbsp;THUMB.18: unconditional 
branch</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-11  Must be 11100b for this type of instructions
  N/A    Opcode (fixed)
          B label   ;branch (jump)
  10-0   Signed Offset, step 2 ($+4-2048..$+4+2046)
</PRE></TD></TR></TBODY></TABLE>Return: 
No flags affected, PC adjusted.<BR>Execution Time: 2S+1N<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="thumb19longbranchwithlink"></A><FONT 
      size="+2">&nbsp;THUMB.19: long branch with 
link</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>This may be 
used to call (or jump) to a subroutine, return address is saved in LR (R14).<BR>
Unlike all other THUMB mode instructions, this instruction occupies 32bit of 
memory which are split into two 16bit THUMB opcodes.<BR><BR>First Instruction - 
LR = PC+4+(nn SHL 12)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-11  Must be 11110b for BL/BLX type of instructions
  10-0   nn - Upper 11 bits of Target Address
</PRE></TD></TR></TBODY></TABLE>Second 
Instruction - PC = LR + (nn SHL 1), and LR = PC+2 OR 1 (and BLX: T=0)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  15-11  Opcode
          11111b: BL label   ;branch long with link
          11101b: BLX label  ;branch long with link switch to ARM mode (ARM9)
  10-0   nn - Lower 11 bits of Target Address (BLX: Bit0 Must be zero)
</PRE></TD></TR></TBODY></TABLE><BR>
The destination address range is (PC+4)-400000h..+3FFFFEh, ie. PC+/-4M.<BR>
Target must be halfword-aligned. As Bit 0 in LR is set, it may be used to return 
by a BX LR instruction (keeping CPU in THUMB mode).<BR>Return: No flags 
affected, PC adjusted, return address in LR.<BR>Execution Time: 3S+1N (first 
opcode 1S, second opcode 2S+1N).<BR><BR>Note<BR>Exceptions may or may not occur 
between first and second opcode, this is "implementation defined" 
???<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arminstructionset"></A><FONT size="+2">&nbsp;ARM Instruction 
      Set</FONT></TD></TR></TBODY></TABLE><BR>When operating in ARM state, full 32bit 
opcodes are used.<BR><BR><B>Summaries</B><BR><A href="#arminstructionsummary">ARM 
Instruction Summary</A><BR><A href="#armconditionfield">ARM 
Condition Field</A><BR><BR><B>Jumps and Calls</B><BR><A href="#arm3branchandexchangebxblx">ARM.3: 
Branch and Exchange (BX, BLX)</A><BR><A href="#arm4branchandbranchwithlinkbblblx">ARM.4: 
Branch and Branch with Link (B, BL, BLX)</A><BR>(Also, most various ALU, LDR, 
LDM opcodes can change PC.)<BR><BR><B>Register Operations</B><BR><A href="#arm5dataprocessing">ARM.5: 
Data Processing</A><BR><A href="#arm6psrtransfermrsmsr">ARM.6: 
PSR Transfer (MRS, MSR)</A><BR><A href="#arm7multiplyandmultiplyaccumulatemulmla">ARM.7: 
Multiply and Multiply-Accumulate (MUL,MLA)</A><BR><BR><B>Memory Addressing 
Operations</B><BR><A href="#arm9singledatatransferldrstrpld">ARM.9: 
Single Data Transfer (LDR, STR, PLD)</A><BR><A href="#arm10halfworddoublewordandsigneddatatransfer">ARM.10: 
Halfword, Doubleword, and Signed Data Transfer</A><BR><A href="#arm11blockdatatransferldmstm">ARM.11: 
Block Data Transfer (LDM,STM)</A><BR><A href="#arm12singledataswapswp">ARM.12: 
Single Data Swap (SWP)</A><BR><BR><B>Exception Calls and Coprocessor</B><BR><A 
href="#arm13softwareinterruptswibkpt">ARM.13: 
Software Interrupt (SWI,BKPT)</A><BR><A href="#arm14coprocessordataoperationscdp">ARM.14: 
Coprocessor Data Operations (CDP)</A><BR><A href="#arm15coprocessordatatransfersldcstc">ARM.15: 
Coprocessor Data Transfers (LDC,STC)</A><BR><A href="#arm16coprocessorregistertransfersmrcmcr">ARM.16: 
Coprocessor Register Transfers (MRC, MCR)</A><BR><A href="#armxcoprocessordoubleregistertransfermcrrmrrc">ARM.X: 
Coprocessor Double-Register Transfer (MCRR,MRRC)</A><BR><A href="#arm17undefinedinstruction">ARM.17: 
Undefined Instruction</A><BR><BR><A href="#armxcountleadingzeros">ARM.X: 
Count Leading Zeros</A><BR><A href="#armxqaddqsub">ARM.X: 
QADD/QSUB</A><BR><BR><A href="#arm26bitmemoryinterface">ARM 
26bit Memory Interface</A><BR><BR><B>Note:</B><BR>Switching between ARM and 
THUMB state can be done by using the Branch and Exchange (BX) 
instruction.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arminstructionsummary"></A><FONT size="+2">&nbsp;ARM 
      Instruction Summary</FONT></TD></TR></TBODY></TABLE><BR>Modification of CPSR 
flags is optional for all {S} instructions.<BR><BR><B>Logical Operations</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Instruction             Cycles   Flags Format Expl.
  MOV{cond}{S} Rd,Op2      1S+x+y   NZc- 5   Rd = Op2
  MVN{cond}{S} Rd,Op2      1S+x+y   NZc- 5   Rd = NOT Op2
  AND{cond}{S} Rd,Rn,Op2   1S+x+y   NZc- 5   Rd = Rn AND Op2
  TST{cond}{P}    Rn,Op2   1S+x     NZc- 5 Void = Rn AND Op2
  EOR{cond}{S} Rd,Rn,Op2   1S+x+y   NZc- 5   Rd = Rn XOR Op2
  TEQ{cond}{P}    Rn,Op2   1S+x     NZc- 5 Void = Rn XOR Op2
  ORR{cond}{S} Rd,Rn,Op2   1S+x+y   NZc- 5   Rd = Rn OR Op2
  BIC{cond}{S} Rd,Rn,Op2   1S+x+y   NZc- 5   Rd = Rn AND NOT Op2
</PRE></TD></TR></TBODY></TABLE>Add 
x=1I cycles if Op2 shifted-by-register. Add y=1S+1N cycles if Rd=R15.<BR>Carry 
flag affected only if Op2 contains a non-zero shift amount.<BR><BR><B>Arithmetic 
Operations</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Instruction             Cycles  Flags Format Expl.
  ADD{cond}{S} Rd,Rn,Op2   1S+x+y   NZCV 5   Rd = Rn+Op2
  ADC{cond}{S} Rd,Rn,Op2   1S+x+y   NZCV 5   Rd = Rn+Op2+Cy
  SUB{cond}{S} Rd,Rn,Op2   1S+x+y   NZCV 5   Rd = Rn-Op2
  SBC{cond}{S} Rd,Rn,Op2   1S+x+y   NZCV 5   Rd = Rn-Op2+Cy-1
  RSB{cond}{S} Rd,Rn,Op2   1S+x+y   NZCV 5   Rd = Op2-Rn
  RSC{cond}{S} Rd,Rn,Op2   1S+x+y   NZCV 5   Rd = Op2-Rn+Cy-1
  CMP{cond}{P}    Rn,Op2   1S+x     NZCV 5 Void = Rn-Op2
  CMN{cond}{P}    Rn,Op2   1S+x     NZCV 5 Void = Rn+Op2
</PRE></TD></TR></TBODY></TABLE>Add 
x=1I cycles if Op2 shifted-by-register. Add y=1S+1N cycles if 
Rd=R15.<BR><BR><B>Multiply</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Instruction                     Cycles  Flags Format Expl.
  MUL{cond}{S} Rd,Rm,Rs            1S+mI     NZx- 7  Rd = Rm*Rs
  MLA{cond}{S} Rd,Rm,Rs,Rn         1S+mI+1I  NZx- 7  Rd = Rm*Rs+Rn
  UMULL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+1I  NZx- 7  RdHiLo = Rm*Rs
  UMLAL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+2I  NZx- 7  RdHiLo = Rm*Rs+RdHiLo
  SMULL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+1I  NZx- 7  RdHiLo = Rm*Rs
  SMLAL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+2I  NZx- 7  RdHiLo = Rm*Rs+RdHiLo
  SMLAxy{cond} Rd,Rm,Rs,Rn       ---q 7  Rd=HalfRm*HalfRs+Rn ARMv5TE(xP)
  SMLAWy{cond} Rd,Rm,Rs,Rn       ---q 7  Rd=(Rm*HalfRs)/10000h+Rn ARMv5TE(xP)
  SMULWy{cond} Rd,Rm,Rs          ---- 7  Rd=(Rm*HalfRs)/10000h    ARMv5TE(xP)
  SMLALxy{cond} RdLo,RdHi,Rm,Rs  ---- 7  RdHiLo=RdHiLo+HalfRm*HalfRs ARMv5TE(xP)
  SMULxy{cond} Rd,Rm,Rs          ---- 7  Rd=HalfRm*HalfRs ARMv5TE(xP)
</PRE></TD></TR></TBODY></TABLE><BR><B>Memory 
Load/Store</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Instruction                     Cycles       Flags Format Expl.
  LDR{cond}{B}{T} Rd,&lt;Address&gt;     1S+1N+1I +y   ---- 9  Rd=[Rn+/-&lt;offset&gt;]
  LDR{cond}H      Rd,&lt;Address&gt;     1S+1N+1I +y   ---- 10 Load Unsigned halfword
  LDR{cond}D      Rd,&lt;Address&gt;                   ---- 10 Load Dword ARMv5TE
  LDR{cond}SB     Rd,&lt;Address&gt;     1S+1N+1I +y   ---- 10 Load Signed byte
  LDR{cond}SH     Rd,&lt;Address&gt;     1S+1N+1I +y   ---- 10 Load Signed halfword
  LDM{cond}{amod} Rn{!},&lt;Rlist&gt;{^} nS+1N+1I +y   ---- 11 Load Multiple
  STR{cond}{B}{T} Rd,&lt;Address&gt;     2N            ---- 9  [Rn+/-&lt;offset&gt;]=Rd
  STR{cond}H      Rd,&lt;Address&gt;     2N            ---- 10 Store halfword
  STR{cond}D      Rd,&lt;Address&gt;                   ---- 10 Store Dword ARMv5TE
  STM{cond}{amod} Rn{!},&lt;Rlist&gt;{^} (n-1)S+2N     ---- 11 Store Multiple
  SWP{cond}{B}    Rd,Rm,[Rn]       1S+2N+1I      ---- 12 Rd=[Rn], [Rn]=Rm
  PLD             &lt;Address&gt;        1S            ---- 9  Prepare Cache ARMv5TE
</PRE></TD></TR></TBODY></TABLE>For LDR/LDM, add 
y=1S+1N if Rd=R15, or if R15 in Rlist.<BR><BR><B>Jumps, Calls, CPSR Mode, and 
others</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Instruction              Cycles  Flags Format Expl.
  B{cond}   label           2S+1N    ---- 4   PC=$+8+/-32M
  BL{cond}  label           2S+1N    ---- 4   PC=$+8+/-32M, LR=$+4
  BX{cond}  Rn              2S+1N    ---- 3   PC=Rn, T=Rn.0 (THUMB/ARM)
  BLX{cond} Rn              2S+1N    ---- 3   PC=Rn, T=Rn.0, LR=PC+4, ARM9
  BLX       label           2S+1N    ---- 3   PC=PC+$+/-32M, LR=$+4, T=1, ARM9
  MRS{cond} Rd,Psr          1S       ---- 6   Rd=Psr
  MSR{cond} Psr{_field},Op  1S      (psr) 6   Psr[field]=Op
  SWI{cond} Imm24bit        2S+1N    ---- 13  PC=8, ARM Svc mode, LR=$+4
  BKPT      Imm16bit        ???      ---- ??? PC=C, ARM Abt mode, LR=$+4 ARM9
  The Undefined Instruction 2S+1I+1N ---- 17  PC=4, ARM Und mode, LR=$+4
  cond=false                1S       ---- ..  Any opcode with condition=false
  NOP                       1S       ---- 5   R0=R0
</PRE></TD></TR></TBODY></TABLE><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  CLZ{cond} Rd,Rm           ???      ---- ??? Count Leading Zeros ARMv5
  QADD{cond} Rd,Rm,Rn            ---q   Rd=Rm+Rn       ARMv5TE(xP)
  QSUB{cond} Rd,Rm,Rn            ---q   Rd=Rm-Rn       ARMv5TE(xP)
  QDADD{cond} Rd,Rm,Rn           ---q   Rd=Rm+Rn*2     ARMv5TE(xP)
  QDSUB{cond} Rd,Rm,Rn           ---q   Rd=Rm-Rn*2     ARMv5TE(xP)
</PRE></TD></TR></TBODY></TABLE><BR><B>Coprocessor 
Functions (if any)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Instruction                         Cycles  Flags Format Expl.
  CDP{cond} Pn,&lt;cpopc&gt;,Cd,Cn,Cm{,&lt;cp&gt;} 1S+bI   ---- 14 Coprocessor specific
  STC{cond}{L} Pn,Cd,&lt;Address&gt;         (n-1)S+2N+bI 15 [address] = CRd
  LDC{cond}{L} Pn,Cd,&lt;Address&gt;         (n-1)S+2N+bI 15 CRd = [address]
  MCR{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;} 1S+bI+1C     16 CRn = Rn {&lt;op&gt; CRm}
  MRC{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;} 1S+(b+1)I+1C 16 Rn = CRn {&lt;op&gt; CRm}
  CDP2,STC2,LDC2,MCR2,MRC2 - ARMv5 Extensions similar above, without {cond}
  MCRR{cond} Pn,&lt;cpopc&gt;,Rd,Rn,Cm  ;write Rd,Rn to coproc ARMv5TE
  MRRC{cond} Pn,&lt;cpopc&gt;,Rd,Rn,Cm  ;read Rd,Rn from coproc ARMv5TE
</PRE></TD></TR></TBODY></TABLE><BR>
Note that no sections 1-2 exist, that is because the sections numbers comply 
with chapter numbers of the official ARM docs, which described ARM opcodes in 
chapter 3-17.<BR><BR><B>ARM Binary Opcode Format</B><BR><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  |..3 ..................2 ..................1 ..................0|
  |1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0|
  |_Cond__|0_0_0|___Op__|S|__Rn___|__Rd___|__Shift__|Typ|0|__Rm___| DataProc
  |_Cond__|0_0_0|___Op__|S|__Rn___|__Rd___|__Rs___|0|Typ|1|__Rm___| DataProc
  |_Cond__|0_0_1|___Op__|S|__Rn___|__Rd___|_Shift_|___Immediate___| DataProc
  |_Cond__|0_0_1_1_0|P|1|0|_Field_|__Rd___|_Shift_|___Immediate___| PSR Imm
  |_Cond__|0_0_0_1_0|P|L|0|_Field_|__Rd___|0_0_0_0|0_0_0_0|__Rm___| PSR Reg
  |_Cond__|0_0_0_1_0_0_1_0_1_1_1_1_1_1_1_1_1_1_1_1|0_0|L|1|__Rn___| BX,BLX
  |1_1_1_0|0_0_0_1_0_0_1_0|_____immediate_________|0_1_1_1|_immed_| BKPT ARM9
  |_Cond__|0_0_0_1_0_1_1_0_1_1_1_1|__Rd___|1_1_1_1|0_0_0_1|__Rm___| CLZ ARM9
  |_Cond__|0_0_0_1_0|Op_|0|__Rn___|__Rd___|0_0_0_0|0_1_0_1|__Rm___| QALU ARM9
  |_Cond__|0_0_0_0_0_0|A|S|__Rd___|__Rn___|__Rs___|1_0_0_1|__Rm___| Multiply
  |_Cond__|0_0_0_0_1|U|A|S|_RdHi__|_RdLo__|__Rs___|1_0_0_1|__Rm___| MulLong
  |_Cond__|0_0_0_1_0|Op_|0|Rd/RdHi|Rn/RdLo|__Rs___|1|y|x|0|__Rm___| MulHalf
  |_Cond__|0_0_0_1_0|B|0_0|__Rn___|__Rd___|0_0_0_0|1_0_0_1|__Rm___| TransSwp12
  |_Cond__|0_0_0|P|U|0|W|L|__Rn___|__Rd___|0_0_0_0|1|S|H|1|__Rm___| TransReg10
  |_Cond__|0_0_0|P|U|1|W|L|__Rn___|__Rd___|OffsetH|1|S|H|1|OffsetL| TransImm10
  |_Cond__|0_1_0|P|U|B|W|L|__Rn___|__Rd___|_________Offset________| TransImm9
  |_Cond__|0_1_1|P|U|B|W|L|__Rn___|__Rd___|__Shift__|Typ|0|__Rm___| TransReg9
  |_Cond__|0_1_1|________________xxx____________________|1|__xxx__| Undefined
  |_Cond__|1_0_0|P|U|S|W|L|__Rn___|__________Register_List________| BlockTrans
  |_Cond__|1_0_1|L|___________________Offset______________________| B,BL,BLX
  |_Cond__|1_1_0|P|U|N|W|L|__Rn___|__CRd__|__CP#__|____Offset_____| CoDataTrans
  |_Cond__|1_1_0_0_0_1_0|L|__Rn___|__Rd___|__CP#__|_CPopc_|__CRm__| CoRR ARM9
  |_Cond__|1_1_1_0|_CPopc_|__CRn__|__CRd__|__CP#__|_CP__|0|__CRm__| CoDataOp
  |_Cond__|1_1_1_0|CPopc|L|__CRn__|__Rd___|__CP#__|_CP__|1|__CRm__| CoRegTrans
  |_Cond__|1_1_1_1|_____________Ignored_by_Processor______________| SWI
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armconditionfield"></A><FONT size="+2">&nbsp;ARM Condition 
      Field</FONT></TD></TR></TBODY></TABLE><BR>In ARM mode, all instructions can be 
conditionally executed depending on the state of the CPSR flags (C,N,Z,V). The 
respective suffixes {cond} must be appended to the mnemonics. For example: BEQ = 
Branch if Equal, MOVMI = Move if Signed.<BR><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE><B>  Code Suffix Flags         Meaning</B>
  0:   EQ     Z=1           equal (zero)
  1:   NE     Z=0           not equal (nonzero)
  2:   CS     C=1           unsigned higher or same (carry set)
  3:   CC     C=0           unsigned lower (carry cleared)
  4:   MI     N=1           negative (minus)
  5:   PL     N=0           positive or zero (plus)
  6:   VS     V=1           overflow (V set)
  7:   VC     V=0           no overflowplus (V cleared)
  8:   HI     C=1 and Z=0   unsigned higher
  9:   LS     C=0 or Z=1    unsigned lower or same
  A:   GE     N=V           greater or equal
  B:   LT     N&lt;&gt;V          less than
  C:   GT     Z=0 and N=V   greater than
  D:   LE     Z=1 or N&lt;&gt;V   less or equal
  E:   AL     -             always
  F:   NV     -             never (ARMv1,v2 only) (Reserved ARMv3 and up)
</PRE></TD></TR></TBODY></TABLE><BR>
To define a non-conditional instruction which is always to be executed
 (regardless of any flags), the AL suffix may be used - that is the same as if 
no suffix is specified. For example, MOVAL would be usually abbreviated to 
MOV.<BR><BR>ARMv5 and up includes a few additional opcodes without condition 
field and which cannot be made conditional, these opcodes are: BKPT, PLD, CDP2, 
LDC2, MCR2, MRC2, STC2, and BLX_imm (however BLX_reg can be 
conditional).<BR><BR>Execution Time: If condition=false: 1S cycle.<BR>Otherwise 
as specified for the respective opcode.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm3branchandexchangebxblx"></A><FONT size="+2">&nbsp;ARM.3: 
      Branch and Exchange (BX, BLX)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode 
Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition
  27-8   Must be "0001.0010.1111.1111.1111" for this instruction
  7-4    Opcode
          0001b: BX{cond}  Rn    ;PC=Rn, T=Rn.0  (ARMv4T and ARMv5 and up)
          0011b: BLX{cond} Rn    ;PC=Rn, T=Rn.0, LR=PC+4    (ARMv5 and up)
  3-0    Rn - Operand Register  (R0-R14)
</PRE></TD></TR></TBODY></TABLE>Switching 
to THUMB Mode: Set Bit 0 of the value in Rn to 1, program continues then at Rn-1 
in THUMB mode.<BR>Results in undefined behaviour if using R15 (PC+8 itself) as 
operand.<BR>Execution Time: 2S + 1N<BR>Return: No flags affected.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm4branchandbranchwithlinkbblblx"></A><FONT 
      size="+2">&nbsp;ARM.4: Branch and Branch with Link (B, BL, 
  BLX)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>Branch (B) is 
supposed to jump to a subroutine. Branch with Link is meant to be used to call 
to a subroutine, return address is then saved in R14.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition (must be 1111b for BLX)
  27-25  Must be "101" for this instruction
  24     Opcode (0-1) (or Halfword Offset for BLX)
          0: B{cond} label    ;branch            PC=PC+8+nn*4
          1: BL{cond} label   ;branch/link       PC=PC+8+nn*4, LR=PC+4
          H: BLX label ;ARM9  ;branch/link/thumb PC=PC+8+nn*4+H*2, LR=PC+4, T=1
  23-0   nn - Signed Offset, step 4      (-32M..+32M in steps of 4)
</PRE></TD></TR></TBODY></TABLE>Branch 
with Link can be used to 'call' to a sub-routine, which may then 'return' by MOV 
PC,R14 for example.<BR>Execution Time: 2S + 1N<BR>Return: No flags 
affected.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm5dataprocessing"></A><FONT size="+2">&nbsp;ARM.5: Data 
      Processing</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition
  27-26  Must be 00b for this instruction
  25     I - Immediate 2nd Operand Flag (0=Register, 1=Immediate)
  24-21  Opcode (0-Fh)               ;*=Arithmetic, otherwise Logical
           0: AND{cond}{S} Rd,Rn,Op2    ;AND logical       Rd = Rn AND Op2
           1: EOR{cond}{S} Rd,Rn,Op2    ;XOR logical       Rd = Rn XOR Op2
           2: SUB{cond}{S} Rd,Rn,Op2 ;* ;subtract          Rd = Rn-Op2
           3: RSB{cond}{S} Rd,Rn,Op2 ;* ;subtract reversed Rd = Op2-Rn
           4: ADD{cond}{S} Rd,Rn,Op2 ;* ;add               Rd = Rn+Op2
           5: ADC{cond}{S} Rd,Rn,Op2 ;* ;add with carry    Rd = Rn+Op2+Cy
           6: SBC{cond}{S} Rd,Rn,Op2 ;* ;sub with carry    Rd = Rn-Op2+Cy-1
           7: RSC{cond}{S} Rd,Rn,Op2 ;* ;sub cy. reversed  Rd = Op2-Rn+Cy-1
           8: TST{cond}{P}    Rn,Op2    ;test            Void = Rn AND Op2
           9: TEQ{cond}{P}    Rn,Op2    ;test exclusive  Void = Rn XOR Op2
           A: CMP{cond}{P}    Rn,Op2 ;* ;compare         Void = Rn-Op2
           B: CMN{cond}{P}    Rn,Op2 ;* ;compare neg.    Void = Rn+Op2
           C: ORR{cond}{S} Rd,Rn,Op2    ;OR logical        Rd = Rn OR Op2
           D: MOV{cond}{S} Rd,Op2       ;move              Rd = Op2
           E: BIC{cond}{S} Rd,Rn,Op2    ;bit clear         Rd = Rn AND NOT Op2
           F: MVN{cond}{S} Rd,Op2       ;not               Rd = NOT Op2
  20     S - Set Condition Codes (0=No, 1=Yes) (Must be 1 for opcode 8-B)
  19-16  Rn - 1st Operand Register (R0..R15) (including PC=R15)
              Must be 0000b for MOV/MVN.
  15-12  Rd - Destination Register (R0..R15) (including PC=R15)
              Must be 0000b {or 1111b) for CMP/CMN/TST/TEQ{P}.
  When above Bit 25 I=0 (Register as 2nd Operand)
    When below Bit 4 R=0 - Shift by Immediate
      11-7   Is - Shift amount   (1-31, 0=Special/See below)
    When below Bit 4 R=1 - Shift by Register
      11-8   Rs - Shift register (R0-R14) - only lower 8bit 0-255 used
      7      Reserved, must be zero  (otherwise multiply or undefined opcode)
    6-5    Shift Type (0=LSL, 1=LSR, 2=ASR, 3=ROR)
    4      R - Shift by Register Flag (0=Immediate, 1=Register)
    3-0    Rm - 2nd Operand Register (R0..R15) (including PC=R15)
  When above Bit 25 I=1 (Immediate as 2nd Operand)
    11-8   Is - ROR-Shift applied to nn (0-30, in steps of 2)
    7-0    nn - 2nd Operand Unsigned 8bit Immediate
</PRE></TD></TR></TBODY></TABLE><BR><B>Second 
Operand (Op2)</B><BR>This may be a shifted register, or a shifted immediate. See 
Bit 25 and 11-0.<BR>Unshifted Register: Specify Op2 as "Rm", assembler converts 
to "Rm,LSL#0".<BR>Shifted Register: Specify as "Rm,SSS#Is" or "Rm,SSS Rs" 
(SSS=LSL/LSR/ASR/ROR).<BR>Immediate: Specify as 32bit value, for example: 
"#000NN000h", assembler should automatically convert into "#0NNh,ROR#0ssh" as 
far as possible (ie. as far as a section of not more than 8bits of the immediate 
is non-zero).<BR><BR><B>Zero Shift Amount (Shift Register by Immediate, with 
Immediate=0)</B><BR>LSL#0: No shift performed, ie. directly Op2=Rm, the C flag 
is NOT affected.<BR>LSR#0: Interpreted as LSR#32, ie. Op2 becomes zero, C 
becomes Bit 31 of Rm.<BR>ASR#0: Interpreted as ASR#32, ie. Op2 and C are filled 
by Bit 31 of Rm.<BR>ROR#0: Interpreted as RRX#1 (RCR), like ROR#1, but Op2 Bit 
31 set to old C.<BR>In source code, LSR#32, ASR#32, and RRX#1 should be 
specified as such - attempts to specify LSR#0, ASR#0, or ROR#0 will be 
internally converted to LSL#0 by the assembler.<BR><BR><B>Using R15 (PC)</B><BR>
When using R15 as Destination (Rd), note below CPSR description and Execution 
time description.<BR>When using R15 as operand (Rm or Rn), the returned value 
depends on the instruction: PC+12 if I=0,R=1 (shift by register), otherwise PC+8 
(shift by immediate).<BR><BR><B>Returned CPSR Flags</B><BR>If S=1, 
Rd&lt;&gt;R15, logical operations (AND,EOR,TST,TEQ,ORR,MOV,BIC,MVN):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  V=not affected
  C=carryflag of shift operation (not affected if LSL#0 or Rs=00h)
  Z=zeroflag of result
  N=signflag of result (result bit 31)
</PRE></TD></TR></TBODY></TABLE>If 
S=1, Rd&lt;&gt;R15, arithmetic operations (SUB,RSB,ADD,ADC,SBC,RSC,CMP,CMN):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  V=overflowflag of result
  C=carryflag of result
  Z=zeroflag of result
  N=signflag of result (result bit 31)
</PRE></TD></TR></TBODY></TABLE>IF 
S=1, with unused Rd bits=1111b, {P} opcodes (CMPP/CMNP/TSTP/TEQP):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  R15=result  ;modify PSR bits in R15, ARMv2 and below only.
  In user mode only N,Z,C,V bits of R15 can be changed.
  In other modes additionally I,F,M1,M0 can be changed.
  The PC bits in R15 are left unchanged in all modes.
</PRE></TD></TR></TBODY></TABLE>If 
S=1, Rd=R15; should not be used in user mode:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  CPSR = SPSR_&lt;current mode&gt;
  PC = result
  For example: MOVS PC,R14  ;return from SWI (PC=R14_svc, CPSR=SPSR_svc).
</PRE></TD></TR></TBODY></TABLE>If 
S=0: Flags are not affected (not allowed for CMP,CMN,TEQ,TST).<BR><BR>The 
instruction "MOV R0,R0" is used as "NOP" opcode in 32bit ARM state.<BR>Execution 
Time: (1+p)S+rI+pN. Whereas r=1 if I=0 and R=1 (ie. shift by register); 
otherwise r=0. And p=1 if Rd=R15; otherwise p=0.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm6psrtransfermrsmsr"></A><FONT size="+2">&nbsp;ARM.6: PSR 
      Transfer (MRS, MSR)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
These instructions occupy an unused area (TEQ,TST,CMP,CMN with S=0) of Data 
Processing opcodes (ARM.5).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition
  27-26  Must be 00b for this instruction
  25     I - Immediate Operand Flag  (0=Register, 1=Immediate) (Zero for MRS)
  24-23  Must be 10b for this instruction
  22     Psr - Source/Destination PSR  (0=CPSR, 1=SPSR_&lt;current mode&gt;)
  21     Opcode
           0: MRS{cond} Rd,Psr          ;Rd = Psr
           1: MSR{cond} Psr{_field},Op  ;Psr[field] = Op
  20     Must be 0b for this instruction (otherwise TST,TEQ,CMP,CMN)
  For MRS:
    19-16   Must be 1111b for this instruction (otherwise SWP)
    15-12   Rd - Destination Register  (R0-R14)
    11-0    Not used, must be zero.
  For MSR:
    19      f  write to flags field     Bit 31-24 (aka _flg)
    18      s  write to status field    Bit 23-16 (reserved, don't change)
    17      x  write to extension field Bit 15-8  (reserved, don't change)
    16      c  write to control field   Bit 7-0   (aka _ctl)
    15-12   Not used, must be 1111b.
  For MSR Psr,Rm (I=0)
    11-4    Not used, must be zero. (otherwise BX)
    3-0     Rm - Source Register &lt;op&gt;  (R0-R14)
  For MSR Psr,Imm (I=1)
    11-8    Shift applied to Imm   (ROR in steps of two 0-30)
    7-0     Imm - Unsigned 8bit Immediate
    In source code, a 32bit immediate should be specified as operand.
    The assembler should then convert that into a shifted 8bit value.
</PRE></TD></TR></TBODY></TABLE>MSR/MRS 
and CPSR/SPSR supported by ARMv3 and up.<BR>ARMv2 and below contained PSR flags 
in R15, accessed by CMP/CMN/TST/TEQ{P}.<BR>The field mask bits specify which 
bits of the destination Psr are write-able (or write-protected), one or more of 
these bits should be set, for example, CPSR_fsxc (aka CPSR aka CPSR_all) unlocks 
all bits (see below user mode restriction though).<BR>Restrictions:<BR>In 
non-privileged mode (user mode): only condition code bits of CPSR can be 
changed, control bits can't.<BR>Only the SPSR of the current mode can be 
accessed; In User and System modes no SPSR exists.<BR>The T-bit may not be 
changed; for THUMB/ARM switching use BX instruction.<BR>Unused Bits in CPSR are 
reserved for future use and should never be changed (except for unused bits in 
the flags field).<BR>Execution Time: 1S.<BR><BR>Note: The A22i assembler 
recognizes MOV as alias for both MSR and MRS because it is practically not 
possible to remember whether MSR or MRS was the load or store opcode, and/or 
whether it does load to or from the Psr register.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm7multiplyandmultiplyaccumulatemulmla"></A><FONT 
      size="+2">&nbsp;ARM.7: Multiply and Multiply-Accumulate 
  (MUL,MLA)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition
  27-25  Must be 000b for this instruction
  24-21  Opcode
          0000b: MUL{cond}{S}   Rd,Rm,Rs        ;multiply   Rd = Rm*Rs
          0001b: MLA{cond}{S}   Rd,Rm,Rs,Rn     ;mul.&amp; accumulate Rd = Rm*Rs+Rn
          0100b: UMULL{cond}{S} RdLo,RdHi,Rm,Rs ;multiply   RdHiLo=Rm*Rs
          0101b: UMLAL{cond}{S} RdLo,RdHi,Rm,Rs ;mul.&amp; acc. RdHiLo=Rm*Rs+RdHiLo
          0110b: SMULL{cond}{S} RdLo,RdHi,Rm,Rs ;sign.mul.  RdHiLo=Rm*Rs
          0111b: SMLAL{cond}{S} RdLo,RdHi,Rm,Rs ;sign.m&amp;a.  RdHiLo=Rm*Rs+RdHiLo
          1000b: SMLAxy{cond}   Rd,Rm,Rs,Rn     ;Rd=HalfRm*HalfRs+Rn
          1001b: SMLAWy{cond}   Rd,Rm,Rs,Rn     ;Rd=(Rm*HalfRs)/10000h+Rn
          1001b: SMULWy{cond}   Rd,Rm,Rs        ;Rd=(Rm*HalfRs)/10000h
          1010b: SMLALxy{cond}  RdLo,RdHi,Rm,Rs ;RdHiLo=RdHiLo+HalfRm*HalfRs
          1011b: SMULxy{cond}   Rd,Rm,Rs        ;Rd=HalfRm*HalfRs
  20     S - Set Condition Codes (0=No, 1=Yes) (Must be 0 for Halfword mul)
  19-16  Rd (or RdHi) - Destination Register (R0-R14)
  15-12  Rn (or RdLo) - Accumulate Register  (R0-R14) (Set to 0000b if unused)
  11-8   Rs - Operand Register               (R0-R14)
  For Non-Halfword Multiplies
    7-4  Must be 1001b for these instructions
  For Halfword Multiplies
    7    Must be 1 for these instructions
    6    y - Rs Top/Bottom flag (0=B=Lower 16bit, 1=T=Upper 16bit)
    5    x - Rm Top/Bottom flag (as above), or 0 for SMLAW, or 1 for SMULW
    4    Must be 0 for these instructions
  3-0    Rm - Operand Register               (R0-R14)
</PRE></TD></TR></TBODY></TABLE><BR><B>Multiply 
and Multiply-Accumulate (MUL,MLA)</B><BR>Restrictions: Rd may not be same as Rm. 
Rd,Rn,Rs,Rm may not be R15.<BR>Note: Only the lower 32bit of the internal 64bit 
result are stored in Rd, thus no sign/zero extension is required and MUL and MLA 
can be used for both signed and unsigned calculations!<BR>Execution Time: 1S+mI 
for MUL, and 1S+(m+1)I for MLA. Whereas 'm' depends on whether/how many most 
significant bits of Rs are all zero or all one. That is m=1 for Bit 31-8, m=2 
for Bit 31-16, m=3 for Bit 31-24, and m=4 otherwise.<BR>Flags (if S=1): 
Z=zeroflag, N=signflag, C=destroyed (ARMv4 and below) or C=not affected (ARMv5 
and up), V=not affected. MUL/MLA supported by ARMv2 and up.<BR><BR><B>Multiply 
Long and Multiply-Accumulate Long (MULL, MLAL)</B><BR>Optionally supported, 
INCLUDED in ARMv3M, EXCLUDED in ARMv4xM/ARMv5xM.<BR>Restrictions: RdHi,RdLo,Rm 
must be different registers. R15 may not be used.<BR>Execution Time: 1S+(m+1)I 
for MULL, and 1S+(m+2)I for MLAL. Whereas 'm' depends on whether/how many most 
significant bits of Rs are "all zero" (UMULL/UMLAL) or "all zero or all one" 
(SMULL,SMLAL). That is m=1 for Bit 31-8, m=2 for Bit 31-16, m=3 for Bit 31-24, 
and m=4 otherwise.<BR>Flags (if S=1): Z=zeroflag, N=signflag, C=destroyed (ARMv4 
and below) or C=not affected (ARMv5 and up), V=destroyed??? (ARMv4 and below???) 
or V=not affected (ARMv5 and up).<BR><BR><B>Signed Halfword Multiply 
(SMLAxy,SMLAWy,SMLALxy,SMULxy,SMULWy)</B><BR>Supported by E variants of ARMv5 
and up, ie. ARMv5TE(xP).<BR>Q-flag gets set on 32bit SMLAxy/SMLAWy addition 
overflows, however, the result is NOT truncated (as it'd be done with QADD 
opcodes).<BR>Q-flag is NOT affected on (rare) 64bit SMLALxy addition 
overflows.<BR>SMULxy/SMULWy cannot overflow, and thus leave Q-flag unchanged as 
well.<BR>NZCV-flags are not affected by Halfword multiplies.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm9singledatatransferldrstrpld"></A><FONT 
      size="+2">&nbsp;ARM.9: Single Data Transfer (LDR, STR, 
  PLD)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition (Must be 1111b for PLD)
  27-26  Must be 01b for this instruction
  25     I - Immediate Offset Flag (0=Immediate, 1=Shifted Register)
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     B - Byte/Word bit (0=transfer word quantity, 1=transfer byte quantity)
  When above Bit 24 P=0 (Post-indexing, write-back is ALWAYS enabled):
    21     T - Memory Management (0=Normal, 1=Force non-privileged access)
  When above Bit 24 P=1 (Pre-indexing, write-back is optional):
    21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
          0: STR{cond}{B}{T} Rd,&lt;Address&gt;   ;[Rn+/-&lt;offset&gt;]=Rd
          1: LDR{cond}{B}{T} Rd,&lt;Address&gt;   ;Rd=[Rn+/-&lt;offset&gt;]
         (1: PLD &lt;Address&gt; ;Prepare Cache for Load, see notes below)
          Whereas, B=Byte, T=Force User Mode (only for POST-Indexing)
  19-16  Rn - Base register               (R0..R15) (including R15=PC+8)
  15-12  Rd - Source/Destination Register (R0..R15) (including R15=PC+12)
  When above I=0 (Immediate as Offset)
    11-0   Unsigned 12bit Immediate Offset (0-4095, steps of 1)
  When above I=1 (Register shifted by Immediate as Offset)
    11-7   Is - Shift amount      (1-31, 0=Special/See below)
    6-5    Shift Type             (0=LSL, 1=LSR, 2=ASR, 3=ROR)
    4      Must be 0 (Reserved, see ARM.17, The Undefined Instruction)
    3-0    Rm - Offset Register   (R0..R14) (not including PC=R15)
</PRE></TD></TR></TBODY></TABLE><BR><B>Instruction 
Formats for &lt;Address&gt;</B><BR>An expression which generates an address:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  &lt;expression&gt;                  ;an immediate used as address
  ;*** restriction: must be located in range PC+/-4095+8, if so,
  ;*** assembler will calculate offset and use PC (R15) as base.
</PRE></TD></TR></TBODY></TABLE>Pre-indexed 
addressing specification:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  [Rn]                          ;offset = zero
  [Rn, &lt;#{+/-}expression&gt;]{!}   ;offset = immediate
  [Rn, {+/-}Rm{,&lt;shift&gt;} ]{!}   ;offset = register shifted by immediate
</PRE></TD></TR></TBODY></TABLE>Post-indexed 
addressing specification:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  [Rn], &lt;#{+/-}expression&gt;      ;offset = immediate
  [Rn], {+/-}Rm{,&lt;shift&gt;}       ;offset = register shifted by immediate
</PRE></TD></TR></TBODY></TABLE>Whereas...<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  &lt;shift&gt;  immediate shift such like LSL#4, ROR#2, etc. (see ARM.5).
  {!}      exclamation mark ("!") indicates write-back (Rn will be updated).
</PRE></TD></TR></TBODY></TABLE><BR><B>Notes</B><BR>
Shift amount 0 has special meaning, as described in ARM.5 Data Processing.<BR>
When writing a word (32bit) to memory, the address should be word-aligned.<BR>
When reading a byte from memory, upper 24 bits of Rd are zero-extended.<BR>LDR 
PC,&lt;op&gt; on ARMv4 leaves CPSR.T unchanged.<BR>LDR PC,&lt;op&gt; on ARMv5 
sets CPSR.T to &lt;op&gt; Bit0, (1=Switch to Thumb).<BR><BR>When reading a word 
from a halfword-aligned address (which is located in the middle between two 
word-aligned addresses), the lower 16bit of Rd will contain [address] ie. the 
addressed halfword, and the upper 16bit of Rd will contain [Rd-2] ie. more or 
less unwanted garbage. However, by isolating lower bits this may be used to read 
a halfword from memory. (Above applies to little endian mode, as used in 
GBA.)<BR><BR>In a virtual memory based environment (ie. not in the GBA), aborts 
(ie. page faults) may take place during execution, if so, Rm and Rn should not 
specify the same register when post-indexing is used, as the abort-handler might 
have problems to reconstruct the original value of the register.<BR><BR>Return: 
CPSR flags are not affected.<BR>Execution Time: For normal LDR: 1S+1N+1I. For 
LDR PC: 2S+2N+1I. For STR: 2N.<BR><BR><B>PLD &lt;Address&gt; ;Prepare Cache for 
Load</B><BR>PLD must use following settings cond=1111b, P=1, B=1, W=0, L=1, 
Rd=1111b, the address may not use post-indexing, and may not use writeback, the
 opcode is encoded identical as LDRNVB R15,&lt;Address&gt;.<BR>PLD signalizes to 
the memory system that a specific memory address will be soon accessed, the 
memory system may use this hint to prepare caching/pipelining, aside from that, 
PLD does not have any affect to the program logic, and behaves identical as 
NOP.<BR>PLD supported by ARMv5TE only, not ARMv5, not ARMv5TExP.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm10halfworddoublewordandsigneddatatransfer"></A><FONT size="+2">&nbsp;ARM.10: 
      Halfword, Doubleword, and Signed Data 
Transfer</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition
  27-25  Must be 000b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     I - Immediate Offset Flag (0=Register Offset, 1=Immediate Offset)
  When above Bit 24 P=0 (Post-indexing, write-back is ALWAYS enabled):
    21     Not used, must be zero (0)
  When above Bit 24 P=1 (Pre-indexing, write-back is optional):
    21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
  19-16  Rn - Base register                (R0-R15) (Including R15=PC+8)
  15-12  Rd - Source/Destination Register  (R0-R15) (Including R15=PC+12)
  11-8   When above Bit 22 I=0 (Register as Offset):
           Not used. Must be 0000b
         When above Bit 22 I=1 (immediate as Offset):
           Immediate Offset (upper 4bits)
  7      Reserved, must be set (1)
  6-5    Opcode (0-3)
         When Bit 20 L=0 (Store) (and Doubleword Load/Store):
          0: Reserved for SWP instruction (see ARM.12 Single Data Swap)
          1: STR{cond}H  Rd,&lt;Address&gt;  ;Store halfword   [a]=Rd
          2: LDR{cond}D  Rd,&lt;Address&gt;  ;Load Doubleword  R(d)=[a], R(d+1)=[a+4]
          3: STR{cond}D  Rd,&lt;Address&gt;  ;Store Doubleword [a]=R(d), [a+4]=R(d+1)
         When Bit 20 L=1 (Load):
          0: Reserved.
          1: LDR{cond}H  Rd,&lt;Address&gt;  ;Load Unsigned halfword (zero-extended)
          2: LDR{cond}SB Rd,&lt;Address&gt;  ;Load Signed byte (sign extended)
          3: LDR{cond}SH Rd,&lt;Address&gt;  ;Load Signed halfword (sign extended)
  4      Reserved, must be set (1)
  3-0    When above Bit 22 I=0:
           Rm - Offset Register            (R0-R14) (not including R15)
         When above Bit 22 I=1:
           Immediate Offset (lower 4bits)  (0-255, together with upper bits)
</PRE></TD></TR></TBODY></TABLE>STRH,LDRH,LDRSB,LDRSH 
supported on ARMv4 and up.<BR>STRD/LDRD supported on ARMv5TE only, not ARMv5, 
not ARMv5TExP.<BR>STRD/LDRD: base writeback: Rn should not be same as R(d) or 
R(d+1).<BR>STRD: index register: Rm should not be same as R(d) or R(d+1).<BR>
STRD/LDRD: Rd must be an even numbered register (R0,R2,R4,R6,R8,R10,R12).<BR>
STRD/LDRD: Address must be double-word aligned (multiple of 
eight).<BR><BR><B>Instruction Formats for &lt;Address&gt;</B><BR>An expression 
which generates an address:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  &lt;expression&gt;                  ;an immediate used as address
  ;*** restriction: must be located in range PC+/-255+8, if so,
  ;*** assembler will calculate offset and use PC (R15) as base.
</PRE></TD></TR></TBODY></TABLE>Pre-indexed 
addressing specification:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  [Rn]                          ;offset = zero
  [Rn, &lt;#{+/-}expression&gt;]{!}   ;offset = immediate
  [Rn, {+/-}Rm]{!}              ;offset = register
</PRE></TD></TR></TBODY></TABLE>Post-indexed 
addressing specification:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  [Rn], &lt;#{+/-}expression&gt;      ;offset = immediate
  [Rn], {+/-}Rm                 ;offset = register
</PRE></TD></TR></TBODY></TABLE>Whereas...<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  {!}      exclamation mark ("!") indicates write-back (Rn will be updated).
</PRE></TD></TR></TBODY></TABLE><BR>
Return: No Flags affected.<BR>Execution Time: For Normal LDR, 1S+1N+1I. For LDR 
PC, 2S+2N+1I. For STRH 2N.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm11blockdatatransferldmstm"></A><FONT 
      size="+2">&nbsp;ARM.11: Block Data Transfer 
(LDM,STM)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition
  27-25  Must be 100b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     S - PSR &amp; force user bit (0=No, 1=load PSR or force user mode)
  21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
          0: STM{cond}{amod} Rn{!},&lt;Rlist&gt;{^}  ;Store (Push)
          1: LDM{cond}{amod} Rn{!},&lt;Rlist&gt;{^}  ;Load  (Pop)
          Whereas, {!}=Write-Back (W), and {^}=PSR/User Mode (S)
  19-16  Rn - Base register                (R0-R14) (not including R15)
  15-0   Rlist - Register List
  (Above 'offset' is meant to be the number of words specified in Rlist.)
</PRE></TD></TR></TBODY></TABLE><BR><B>Addressing 
Modes {amod}</B><BR>The IB,IA,DB,DA suffixes directly specify the desired U and 
P bits:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  IB  increment before          ;P=1, U=1
  IA  increment after           ;P=0, U=1
  DB  decrement before          ;P=1, U=0
  DA  decrement after           ;P=0, U=0
</PRE></TD></TR></TBODY></TABLE>Alternately, 
FD,ED,FA,EA could be used, mostly to simplify mnemonics for stack transfers.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  ED  empty stack, descending   ;LDM: P=1, U=1  ;STM: P=0, U=0
  FD  full stack,  descending   ;     P=0, U=1  ;     P=1, U=0
  EA  empty stack, ascending    ;     P=1, U=0  ;     P=0, U=1
  FA  full stack,  ascending    ;     P=0, U=0  ;     P=1, U=1
</PRE></TD></TR></TBODY></TABLE>Ie. 
the following expressions are aliases for each other:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  STMFD=STMDB=PUSH   STMED=STMDA   STMFA=STMIB   STMEA=STMIA
  LDMFD=LDMIA=POP    LDMED=LDMIB   LDMFA=LDMDA   LDMEA=LDMDB
</PRE></TD></TR></TBODY></TABLE>Note: 
The equivalent THUMB functions use fixed organization:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  PUSH/POP: full descending     ;base register SP (R13)
  LDM/STM:  increment after     ;base register R0..R7
</PRE></TD></TR></TBODY></TABLE>Descending 
is common stack organization as used in 80x86 and Z80 CPUs, SP is decremented 
when pushing/storing data, and incremented when popping/loading 
data.<BR><BR><B>When S Bit is set (S=1)</B><BR>If instruction is LDM and R15 is 
in the list: (Mode Changes)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  While R15 loaded, additionally: CPSR=SPSR_&lt;current mode&gt;
</PRE></TD></TR></TBODY></TABLE>Otherwise: 
(User bank transfer)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Rlist is referring to User Bank Registers, R0-R15 (rather than
  register related to the current mode, such like R14_svc etc.)
  Base write-back should not be used for User bank transfer.
  !  When instruction is LDM:                                   !
  !  If the following instruction reads from a banked register, !
  !  like R14_svc, then CPU might still read R14 instead. If    !
  !  necessary insert a dummy instruction such like MOV R0,R0.  !
</PRE></TD></TR></TBODY></TABLE><BR><B>Notes</B><BR>
The lowest Register in Rlist (R0 if its in the list) will be loaded/stored 
to/from the lowest memory address.<BR>The base address should be usually 
word-aligned.<BR>LDM Rn,...,PC on ARMv4 leaves CPSR.T unchanged.<BR>LDR 
Rn,...,PC on ARMv5 sets CPSR.T to &lt;op&gt; Bit0, (1=Switch to 
Thumb).<BR><BR><B>Inclusion of the base in the register list</B><BR>When 
write-back is specified, the base is written back at the end of the second cycle 
of the instruction. During a STM, the first register is written out at the start 
of the second cycle. A STM which includes storing the base as the first register 
to be stored, will therefore store the unchanged value, whereas with the base 
second or later in the transfer order, will store the modified value.<BR>A LDM 
will always overwrite the updated base if the base is in the list.<BR><BR>
Return: No Flags affected.<BR>Execution Time: For normal LDM, nS+1N+1I. For LDM 
PC, (n+1)S+2N+1I. For STM (n-1)S+2N. Where n is the number of words 
transferred.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm12singledataswapswp"></A><FONT size="+2">&nbsp;ARM.12: 
      Single Data Swap (SWP)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode 
Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition
  27-23  Must be 00010b for this instruction
         Opcode (fixed)
           SWP{cond}{B} Rd,Rm,[Rn]      ;Rd=[Rn], [Rn]=Rm
  22     B - Byte/Word bit (0=swap word quantity, 1=swap byte quantity)
  21-20  Must be 00b for this instruction
  19-16  Rn - Base register                     (R0-R14)
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 00001001b for this instruction
  3-0    Rm - Source Register                   (R0-R14)
</PRE></TD></TR></TBODY></TABLE>SWP/SWPB 
supported by ARMv2a and up.<BR>Swap works properly including if Rm and Rn 
specify the same register.<BR>R15 may not be used for either Rn,Rd,Rm. (Rn=R15 
would be MRS opcode).<BR>Upper bits of Rd are zero-expanded when using Byte 
quantity. For info about byte and word data memory addressing, read LDR and STR 
opcode description.<BR>Execution Time: 1S+2N+1I. That is, 2N data cycles, 1S 
code cycle, plus 1I.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm13softwareinterruptswibkpt"></A><FONT 
      size="+2">&nbsp;ARM.13: Software Interrupt 
(SWI,BKPT)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition (must be 1110b for BKPT, ie. Condition=always)
  27-24  Opcode
          1111b: SWI{cond} nn   ;software interrupt
          0001b: BKPT      nn   ;breakpoint (ARMv5 and up)
  For SWI:
   23-0   nn - Comment Field, ignored by processor (24bit value)
  For BKPT:
   23-20  Must be 0010b for BKPT
   19-8   nn - upper 12bits of comment field, ignored by processor
   7-4    Must be 0111b for BKPT
   3-0    nn - lower 4bits of comment field, ignored by processor
</PRE></TD></TR></TBODY></TABLE>SWI 
supposed for calls to the operating system - Enter Supervisor mode (SVC) in ARM 
state. BKPT intended for debugging - enters Abort mode in ARM state via Prefetch 
Abort vector.<BR><BR>Execution SWI/BKPT:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  R14_svc=PC+4     R14_abt=PC+4   ;save return address
  SPSR_svc=CPSR    SPSR_abt=CPSR  ;save CPSR flags
  CPSR=&lt;changed&gt;   CPSR=&lt;changed&gt; ;Enter svc/abt, ARM state, IRQs disabled
  PC=VVVV0008h     PC=VVVV000Ch   ;jump to SWI/PrefetchAbort vector address
</PRE></TD></TR></TBODY></TABLE>Execution 
Time: 2S+1N<BR><BR>Interpreting the Comment Field:<BR>The immediate parameter is 
ignored by the processor, the user interrupt handler may read-out this number by 
examining the lower 24bit of the 32bit opcode opcode at [R14_svc-4]. In case 
that your program executes SWI's from inside of THUMB mode also: Your SWI 
handler must then examine the T Bit SPSR_svc in order to determine whether it's 
been a THUMB SWI - if so, examining the lower 8bit of the 16bit opcode opcode at 
[R14_svc-2].<BR><BR>For Returning from SWI use this instruction:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  MOVS PC,R14
</PRE></TD></TR></TBODY></TABLE>That instructions does both 
restoring PC and CPSR, ie. PC=R14_svc, and CPSR=SPRS_svc.<BR><BR>Nesting 
SWIs:<BR>SPSR_svc and R14_svc should be saved on stack before either invoking
 nested SWIs, or (if the IRQ handler uses SWIs) before enabling 
IRQs.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm14coprocessordataoperationscdp"></A><FONT 
      size="+2">&nbsp;ARM.14: Coprocessor Data Operations 
  (CDP)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition (or 1111b for CDP2 opcode on ARMv5 and up)
  27-24  Must be 1110b for this instruction
         ARM-Opcode (fixed)
           CDP{cond} Pn,&lt;cpopc&gt;,Cd,Cn,Cm{,&lt;cp&gt;}
           CDP2      Pn,&lt;cpopc&gt;,Cd,Cn,Cm{,&lt;cp&gt;}
  23-20  CP Opc - Coprocessor operation code       (0-15)
  19-16  Cn     - Coprocessor operand Register     (C0-C15)
  15-12  Cd     - Coprocessor destination Register (C0-C15)
  11-8   Pn     - Coprocessor number               (P0-P15)
  7-5    CP     - Coprocessor information          (0-7)
  4      Reserved, must be zero (otherwise MCR/MRC opcode)
  3-0    Cm     - Coprocessor operand Register     (C0-C15)
</PRE></TD></TR></TBODY></TABLE>CDP 
supported by ARMv2 and up, CDP2 by ARMv5 and up.<BR>Execution time: 1S+bI, 
b=number of cycles in coprocessor busy-wait loop.<BR>Return: No flags affected, 
no ARM-registers used/modified.<BR>For details refer to original ARM docs, 
irrelevant in GBA because no coprocessor exists.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm15coprocessordatatransfersldcstc"></A><FONT 
      size="+2">&nbsp;ARM.15: Coprocessor Data Transfers 
  (LDC,STC)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition (or 1111b for LDC2/STC2 opcodes on ARMv5 and up)
  27-25  Must be 110b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     N - Transfer length (0-1, interpretation depends on co-processor)
  21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     Opcode (0-1)
          0: STC{cond}{L} Pn,Cd,&lt;Address&gt;  ;Store to memory (from coprocessor)
          0: STC2{L}      Pn,Cd,&lt;Address&gt;  ;Store to memory (from coprocessor)
          1: LDC{cond}{L} Pn,Cd,&lt;Address&gt;  ;Read from memory (to coprocessor)
          1: LDC2{L}      Pn,Cd,&lt;Address&gt;  ;Read from memory (to coprocessor)
          whereas {L} indicates long transfer (Bit 22: N=1)
  19-16  Rn     - ARM Base Register              (R0-R15)     (R15=PC+8)
  15-12  Cd     - Coprocessor src/dest Register  (C0-C15)
  11-8   Pn     - Coprocessor number             (P0-P15)
  7-0    Offset - Unsigned Immediate, step 4     (0-1020, in steps of 4)
</PRE></TD></TR></TBODY></TABLE>LDC/STC 
supported by ARMv2 and up, LDC2/STC2 by ARMv5 and up.<BR>Execution time: 
(n-1)S+2N+bI, n=number of words transferred.<BR>For details refer to original 
ARM docs, irrelevant in GBA because no coprocessor exists.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm16coprocessorregistertransfersmrcmcr"></A><FONT 
      size="+2">&nbsp;ARM.16: Coprocessor Register Transfers (MRC, 
  MCR)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition (or 1111b for MRC2/MCR2 opcodes on ARMv5 and up)
  27-24  Must be 1110b for this instruction
  23-21  CP Opc - Coprocessor operation code         (0-7)
  20     ARM-Opcode (0-1)
          0: MCR{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from ARM to CoPro
          0: MCR2      Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from ARM to CoPro
          1: MRC{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from CoPro to ARM
          1: MRC2      Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from CoPro to ARM
  19-16  Cn     - Coprocessor source/dest. Register  (C0-C15)
  15-12  Rd     - ARM source/destination Register    (R0-R15)
  11-8   Pn     - Coprocessor number                 (P0-P15)
  7-5    CP     - Coprocessor information            (0-7)
  4      Reserved, must be one (1) (otherwise CDP opcode)
  3-0    Cm     - Coprocessor operand Register       (C0-C15)
</PRE></TD></TR></TBODY></TABLE>MCR/MRC 
supported by ARMv2 and up, MCR2/MRC2 by ARMv5 and up.<BR>A22i syntax allows to 
use MOV with Rd specified as first (dest), or last (source) operand. Native 
MCR/MRC syntax uses Rd as middle operand, &lt;cp&gt; can be ommited if 
&lt;cp&gt; is zero.<BR>When using MCR with R15: Coprocessor will receive a data 
value of PC+12.<BR>When using MRC with R15: Bit 31-28 of data are copied to Bit 
31-28 of CPSR (ie. N,Z,C,V flags), other data bits are ignored, CPSR Bit 27-0 
are not affected, R15 (PC) is not affected.<BR>Execution time: 1S+bI+1C for MCR, 
1S+(b+1)I+1C for MRC.<BR>Return: For MRC only: Either R0-R14 modified, or flags 
affected (see above).<BR>For details refer to original ARM docs, irrelevant in 
GBA because no coprocessor exists.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armxcoprocessordoubleregistertransfermcrrmrrc"></A><FONT 
      size="+2">&nbsp;ARM.X: Coprocessor Double-Register Transfer 
      (MCRR,MRRC)</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition
  27-21  Must be 1100010b for this instruction
  20     L - Opcode (Load/Store)
          0: MCRR{cond} Pn,opcode,Rd,Rn,Cm  ;write Rd,Rn to coproc
          1: MRRC{cond} Pn,opcode,Rd,Rn,Cm  ;read Rd,Rn from coproc
  19-16  Rn - Second source/dest register      (R0-R14)
  15-12  Rd - First source/dest register       (R0-R14)
  11-8   Pn     - Coprocessor number           (P0-P15)
  7-4    CP Opc - Coprocessor operation code   (0-15)
  3-0    Cm     - Coprocessor operand Register (C0-C15)
</PRE></TD></TR></TBODY></TABLE>Supported 
by ARMv5TE only, not ARMv5, not ARMv5TExP.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm17undefinedinstruction"></A><FONT size="+2">&nbsp;ARM.17: 
      Undefined Instruction</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode 
Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition
  27-25  Must be 011b for this instruction
  24-5   Reserved for future use
  4      Must be 1b for this instruction
  3-0    Reserved for future use
</PRE></TD></TR></TBODY></TABLE>No 
assembler mnemonic exists, following bitstreams are (not) reserved.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  cond011xxxxxxxxxxxxxxxxxxxx1xxxx - reserved for future use (except below).
  cond01111111xxxxxxxxxxxx1111xxxx - free for user.
</PRE></TD></TR></TBODY></TABLE>Execution 
time: 2S+1I+1N.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armxcountleadingzeros"></A><FONT size="+2">&nbsp;ARM.X: Count 
      Leading Zeros</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition
  27-16  Must be 0001.0110.1111b for this instruction
         Opcode (fixed)
           CLZ{cond} Rd,Rm  ;Rd=Number of leading zeros in Rm
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 1111.0001b for this instruction
  3-0    Rm - Source Register                   (R0-R14)
</PRE></TD></TR></TBODY></TABLE>CLZ 
supported by ARMv5 and up.<BR>Return: No Flags affected. Rd=0..32.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armxqaddqsub"></A><FONT size="+2">&nbsp;ARM.X: 
      QADD/QSUB</FONT></TD></TR></TBODY></TABLE><BR><B>Opcode Format</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  31-28  Condition
  27-24  Must be 0001b for this instruction
  23-20  Opcode
          0000b: QADD{cond}  Rd,Rm,Rn    ;Rd=Rm+Rn
          0010b: QSUB{cond}  Rd,Rm,Rn    ;Rd=Rm-Rn
          0100b: QDADD{cond} Rd,Rm,Rn    ;Rd=Rm+Rn*2 (doubled)
          0110b: QDSUB{cond} Rd,Rm,Rn    ;Rd=Rm-Rn*2 (doubled)
  19-16  Rn - Second Source Register            (R0-R14)
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 00000101b for this instruction
  3-0    Rm - First Source Register             (R0-R14)
</PRE></TD></TR></TBODY></TABLE>Supported 
by E variants of ARMv5 and up, ie. ARMv5TE(xP).<BR>Results truncated to signed 
32bit range in case of overflows, with the Q-flag being set (and being left 
unchanged otherwise). NZCV flags are not affected.<BR>Note: Rn*2 is internally 
processed first, and may get truncated - even if the final result would fit into 
range.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="arm26bitmemoryinterface"></A><FONT size="+2">&nbsp;ARM 26bit 
      Memory Interface</FONT></TD></TR></TBODY></TABLE><BR>The 26bit Memory Interface 
was used by ARMv1 and ARMv2. The 32bit interface is used by ARMv3 and newer, 
however, 26bit backward compatibility was included in all ARMv3 (except ARMv3G), 
and optionally in some non-T variants of ARMv4.<BR><BR><B>Format of R15 in 26bit 
Mode (Program Counter Register)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Name     Expl.
  31-28 N,Z,C,V  Flags (Sign, Zero, Carry, Overflow)
  27-26 I,F      Interrupt Disable bits (IRQ, FIQ) (1=Disable)
  25-2  PC       Program Counter, 24bit, Step 4 (64M range)
  1-0   M1,M0    Mode (0=User, 1=FIQ, 2=IRQ, 3=Supervisor)
</PRE></TD></TR></TBODY></TABLE>Branches 
with +/-32M range wrap the PC register, and can reach all 64M 
memory.<BR><BR><B>Reading from R15</B><BR>If R15 is specified in bit16-19 of an 
opcode, then NZCVIF and M0,1 are masked (zero), otherwise the full 32bits are 
used.<BR><BR><B>Writing to R15</B><BR>Data Processing opcodes with S=1, and LDM 
opcodes with PSR=1 can write to all 32bits in R15 (in 26bit mode, that is 
allowed even in user mode, though it does then affect only NZCF, not the write 
protected IFMM bits ???), other opcodes which write to R15 will modify only the
 program counter bits. Also, special CMP/CMN/TST/TEQ{P} opcodes can be used to 
write to the PSR bits in R15 without modifying the PC 
bits.<BR><BR><B>Exceptions</B><BR>SWIs, Reset, Data/Prefetch Aborts and 
Undefined instructions enter Supervisor mode. Interrupts enter IRQ and FIQ mode. 
Additionally, a special 26bit Address Exception exists, which enters Supervisor 
mode on accesses to memory addresses&gt;=64M as follows:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  R14_svc = PC ($+8, including old PSR bits)
  M1,M0 = 11b = supervisor mode, F=same, I=1, PC=14h
</PRE></TD></TR></TBODY></TABLE>to 
continue at the fault location, return by SUBS PC,LR,8.<BR><BR><B>26bit 
Backwards Compatibility on 32bit ARMv3 and up</B><BR>CPSR M4=0 = 26bit mode 
(with USR,FIQ,IRQ,SVC modes in M1,M0)<BR>32bit CPUs with 26bit compatibility 
mode can be configured to switch into 32bit mode when encountering 
exceptions.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="pseudoinstructionsanddirectives"></A><FONT 
      size="+2">&nbsp;Pseudo Instructions and 
Directives</FONT></TD></TR></TBODY></TABLE><BR><B>ARM Pseudo 
Instructions</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  nop              mov r0,r0
  ldr Rd,=Imm      ldr Rd,[r15,disp] ;use .pool as parameter field)
  add Rd,=addr     add/sub Rd,r15,disp
  adr Rd,addr      add/sub Rd,r15,disp
  adrl Rd,addr     two add/sub opcodes with disp=xx00h+00yyh
  mov Rd,Imm       mvn Rd,NOT Imm    ;or vice-versa
  and Rd,Rn,Imm    bic Rd,Rn,NOT Imm ;or vice-versa
  cmp Rd,Rn,Imm    cmn Rd,Rn,-Imm    ;or vice-versa
  add Rd,Rn,Imm    sub Rd,Rn,-Imm    ;or vice-versa
</PRE></TD></TR></TBODY></TABLE>All 
above opcodes may be made conditional by specifying a {cond} 
field.<BR><BR><B>THUMB Pseudo Instructions</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  nop              mov r8,r8
  ldr Rd,=Imm      ldr Rd,[r15,disp] ;use .pool as parameter field
  add Rd,=addr     add Rd,r15,disp
  adr Rd,addr      add Rd,r15,disp
  mov Rd,Rs        add Rd,Rs,0       ;with Rd,Rs in range r0-r7 each
</PRE></TD></TR></TBODY></TABLE><BR><B>A22i 
Directives</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  org  adr     assume following code from this address on
  .gba         indicate GBA program
  .fix         fix GBA header checksum
  .norewrite   do not delete existing output file (keep following data in file)
  .data?       following defines RAM data structure (assembled to nowhere)
  .code        following is normal ROM code/data (assembled to ROM image)
  .include     includes specified source code file (no nesting/error handling)
  .import      imports specified binary file (optional parameters: ,begin,len)
  .radix nn    changes default numeric format (nn=2,8,10,16 = bin/oct/dec/hex)
  .errif expr  generates an error message if expression is nonzero
  .if expr     assembles following code only if expression is nonzero
  .else        invert previous .if condition
  .endif       terminate .if/.ifdef/.ifndef
  .ifdef sym   assemble following only if symbol is defined
  .ifndef sym  assemble following only if symbol is not defined
  .align nn    aligns to an address divisible-by-nn, inserts 00's
  .msg         defines a no$gba debugmessage string, such like .msg 'Init Okay'
  .brk         defines a no$gba source code break opcode
  l equ n      l=n
  l:   [cmd]   l=$   (global label)
  @@l: [cmd]   @@l=$ (local label, all locals are reset at next global label)
  end          end of source code
  db ...       define 8bit data (bytes)
  dw ...       define 16bit data (halfwords)
  dd ...       define 32bit data (words)
  defs nn      define nn bytes space (zero-filled)
  ;...         defines a comment (ignored by the assembler)
  //           alias for CRLF, eg. allows &lt;db 'Text',0 // dw addr&gt; in one line
</PRE></TD></TR></TBODY></TABLE><BR><B>A22i 
Alias Directives (for compatibility with other assemblers)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  align        .align 4          code16    .thumb
  align nn     .align nn         .code 16  .thumb
  % nn         defs nn           code32    .arm
  .space nn    defs nn           .code 32  .arm
  ..ds nn      defs nn           ltorg     .pool
  x=n          x equ n           .ltorg    .pool
  .equ x,n     x equ n           ..ltorg   .pool
  .define x n  x equ n           dcb       db (8bit data)
  incbin       .import           defb      db (8bit data)
  @@@...       ;comment          .byte     db (8bit data)
  @ ...        ;comment          .ascii    db (8bit string)
  @*...        ;comment          dcw       dw (16bit data)
  @...         ;comment          defw      dw (16bit data)
  .text        .code             .hword    dw (16bit data)
  .bss         .data?            dcd       dd (32bit data)
  .global      (ignored)         defd      dd (32bit data)
  .extern      (ignored)         .long     dd (32bit data)
  .thumb_func  (ignored)         .word     dw/dd, don't use
  #directive   .directive        .end      end
  .fill nn,1,0 defs nn
</PRE></TD></TR></TBODY></TABLE><BR><B>Alias 
Conditions, Opcodes, Operands</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  hs   cs   ;condition higher or same = carry set
  asl  lsl  ;arithmetic shift left = logical shift left
</PRE></TD></TR></TBODY></TABLE><BR><B>A22i 
Numeric Formats &amp; Dialects</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Type          Normal       Alias
  Decimal       85           #85  &amp;d85
  Hexadecimal   55h          #55h  0x55  #0x55  $55  &amp;h55
  Octal         125o         0o125  &amp;o125
  Ascii         'U'          "U"
  Binary        01010101b    %01010101  0b01010101  &amp;b01010101
  Roman         &amp;rLXXXV      (very useful for arrays of kings and chapters)
</PRE></TD></TR></TBODY></TABLE>Note: 
The default numeric format can be changed by the .radix directive (usually 
10=decimal). For example, with radix 16, values like "85" and "0101b" are 
treated as hexadecimal numbers (in that case, decimal and binary numbers can be 
still defined with prefixes &amp;d and &amp;b).<BR><BR><B>A22i Numeric Operators 
Priority</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Prio  Operator           Aliases
  8     (,) brackets
  7     +,- sign
  6     *,/,MOD,SHL,SHR    MUL,DIV,&lt;&lt;,&gt;&gt;
  5     +,- operation
  4     EQ,GE,GT,LE,LT,NE  =,&gt;=,&gt;,&lt;=,&lt;,&lt;&gt;,==,!=
  3     NOT
  2     AND
  1     OR,XOR             EOR
</PRE></TD></TR></TBODY></TABLE>Operators 
of same priority are processed from left to right.<BR>Boolean operators 
(priority 4) return 1=TRUE, 0=FALSE.<BR><BR><B>A22i Nocash Syntax</B><BR>Even 
though A22i does recognize the official ARM syntax, it's also allowing to use 
friendly code:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  mov   r0,0ffh         ;no C64-style "#", and no C-style "0x" required
  stmia [r7]!,r0,r4-r5  ;square [base] brackets, no fancy {rlist} brackets
  mov   r0,cpsr         ;no confusing MSR and MRS (whatever which is which)
  mov   r0,p0,0,c0,c0,0 ;no confusing MCR and MRC (whatever which is which)
  ldr   r0,[score]      ;allows to use clean brackets for relative addresses
  push  rlist           ;alias for stmfd [r13]!,rlist (and same for pop/ldmfd)
  label:                ;label definitions recommended to use ":" colons
</PRE></TD></TR></TBODY></TABLE><BR>
[A22i is the no$gba debug version's built-in source code assembler.]<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armcp15systemcontrolcoprocessor"></A><FONT 
      size="+2">&nbsp;ARM CP15 System Control 
Coprocessor</FONT></TD></TR></TBODY></TABLE><BR><A href="#armcp15overview">ARM 
CP15 Overview</A><BR><A href="#armcp15idcodes">ARM 
CP15 ID Codes</A><BR><A href="#armcp15controlregister">ARM 
CP15 Control Register</A><BR><A href="#armcp15memorymanagmentunitmmu">ARM 
CP15 Memory Managment Unit (MMU)</A><BR><A href="#armcp15protectionunitpu">ARM 
CP15 Protection Unit (PU)</A><BR><A href="#armcp15cachecontrol">ARM 
CP15 Cache Control</A><BR><A href="#armcp15fastcontextswitchextensionfcse">ARM 
CP15 Fast Context Switch Extension (FCSE)</A><BR><A href="#armcp15tightlycoupledmemorytcm">ARM 
CP15 Tightly Coupled Memory (TCM)</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armcp15overview"></A><FONT size="+2">&nbsp;ARM CP15 
      Overview</FONT></TD></TR></TBODY></TABLE><BR><B>CP15</B><BR>In many ARM CPUs, 
particulary such with memory control facilities, coprocessor number 15 (CP15) is 
used as built-in System Control Coprocessor.<BR>CPUs without memory control 
functions typically do include a CP15 at all, in that case even an attempt to 
read the Main ID register will cause an Undefined Instruction 
exception.<BR><BR><B>CP15 Opcodes</B><BR>CP15 can be accessed via MCR and MRC 
opcodes, with Pn=P15, and &lt;cpopc&gt;=0.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  MCR{cond} P15,0,Rd,Cn,Cm,&lt;cp&gt;   ;move from ARM to CP15
  MRC{cond} P15,0,Rd,Cn,Cm,&lt;cp&gt;   ;move from CP15 to ARM
</PRE></TD></TR></TBODY></TABLE>Rd 
can be any ARM register in range R0-R14, R15 should not be used with P15.<BR>
Cn,Cm,&lt;cp&gt; are used to select a CP15 register, eg. C0,C0,0 = Main ID 
Register.<BR>Other coprocessor opcodes (CDP, LDC, STC) cannot be used with 
P15.<BR><BR><B>CP15 Register List</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Register     Expl.
  C0,C0,0      Main ID Register (R)
  C0,C0,1      Cache Type and Size (R)
  C0,C0,2      TCM Physical Size (R)
  C1,C0,0      Control Register (R/W, or R=Fixed)
  C2,C0,0      PU Cachability Bits for Data/Unified Protection Region
  C2,C0,1      PU Cachability Bits for Instruction Protection Region
  C3,C0,0      PU Write-Bufferability Bits for Data Protection Regions
  C5,C0,0      PU Access Permission Data/Unified Protection Region
  C5,C0,1      PU Access Permission Instruction Protection Region
  C5,C0,2      PU Extended Access Permission Data/Unified Protection Region
  C5,C0,3      PU Extended Access Permission Instruction Protection Region
  C6,C0..C7,0  PU Protection Unit Data/Unified Region 0..7
  C6,C0..C7,1  PU Protection Unit Instruction Region 0..7
  C7,Cm,Op2    Cache Commands and Halt Function (W)
  C9,C0,0      Cache Data Lockdown
  C9,C0,1      Cache Instruction Lockdown
  C9,C1,0      TCM Data TCM Base and Virtual Size
  C9,C1,1      TCM Instruction TCM Base and Virtual Size
  C13,C0,0     Process ID for Fast Context Switch Extension (FCSE)
  C15,Cm,Op2   Implementation Defined
</PRE></TD></TR></TBODY></TABLE><BR><B>Data/Unified 
Registers</B><BR>Some Cache/PU/TCM registers are declared as "Data/Unified".<BR>
That registers are used for Data accesses in case that the CPU contains separate 
Data and Instruction registers, otherwise the registers are used for both 
(unified) Data and Instruction accesses.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armcp15idcodes"></A><FONT size="+2">&nbsp;ARM CP15 ID 
      Codes</FONT></TD></TR></TBODY></TABLE><BR><B>C0,C0,0 - Main ID Register 
(R)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  12-15 ARM Era (0=Pre-ARM7, 7=ARM7, other=Post-ARM7)
</PRE></TD></TR></TBODY></TABLE>Post-ARM7 
Processors<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-3   Revision Number
  4-15  Primary Part Number (Bit12-15 must be other than 0 or 7)
        (eg. 946h for ARM946)
  16-19 Architecture        (1=v4, 2=v4T, 3=v5, 4=v5T, 5=v5TE)
  20-23 Variant Number
  24-31 Implementor         (41h=ARM, 44h=Digital Equipment Corp, 69h=Intel)
</PRE></TD></TR></TBODY></TABLE>ARM7 
Processors<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-3   Revision Number
  4-15  Primary Part Number (Bit12-15 must be 7)
  16-22 Variant Number
  23    Architecture        (0=v3, 1=v4T)
  24-31 Implementor         (41h=ARM, 44h=Digital Equipment Corp, 69h=Intel)
</PRE></TD></TR></TBODY></TABLE>Pre-ARM7 
Processors<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-3   Revision Number
  4-11  Processor ID LSBs (30h=ARM3/v2, 60h,61h,62=ARM600,610,620/v3)
  12-31 Processor ID MSBs (fixed, 41560h)
</PRE></TD></TR></TBODY></TABLE><BR><B>C0,C0,1 
- Cache Type Register (R)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-11  Instruction Cache (bits 0-1=len, 2=m, 3-5=assoc, 6-8=size, 9-11=zero)
  12-23 Data Cache        (bits 0-1=len, 2=m, 3-5=assoc, 6-8=size, 9-11=zero)
  24    Separate Cache Flag (0=Unified, 1=Separate Data/Instruction Caches)
  25-28 Cache Type (0,1,2,6,7=see below, other=reserved)
         Type Method         Cache cleaning         Cache lock-down
         0    Write-through  Not needed             Not supported
         1    Write-back     Read data block        Not supported
         2    Write-back     Register 7 operations  Not supported
         6    Write-back     Register 7 operations  Format A
         7    Write-back     Register 7 operations  Format B
  29-31 Reserved (zero)
</PRE></TD></TR></TBODY></TABLE>The 
12bit Instruction/Data values are decoded as shown below,<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Cache Absent  = (ASSOC=0 and M=1)       ;in that case overriding below
  Cache Size    = 200h+(100h*M) shl SIZE  ;min 0.5Kbytes, max 96Kbytes
  Associativity = (1+(0.5*M)) shl ASSOC   ;min 1-way,     max 192-way
  Line Length   = 8 shl LEN               ;min 8 bytes,   max 64 bytes
</PRE></TD></TR></TBODY></TABLE>For 
Unified cache (Bit 24=0), Instruction and Data values are 
identical.<BR><BR><B>C0,C0,2 - Tightly Coupled Memory (TCM) Size Register 
(R)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-1   Reserved    (0)
  2     ITCM Absent (0=Present, 1=Absent)
  3-5   Reserved    (0)
  6-9   ITCM Size   (Size = 512 SHL N) (or 0=None)
  10-13 Reserved    (0)
  14    DTCM Absent (0=Present, 1=Absent)
  15-17 Reserved    (0)
  18-21 DTCM Size   (Size = 512 SHL N) (or 0=None)
  22-31 Reserved    (0)
</PRE></TD></TR></TBODY></TABLE><BR><B>C0,C0,3..7 
- Reserved (R)</B><BR>Unused/Reserved registers containing the same value as 
C0,C0,0.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armcp15controlregister"></A><FONT size="+2">&nbsp;ARM CP15 
      Control Register</FONT></TD></TR></TBODY></TABLE><BR><B>C1,C0,0 - Control 
Register (R/W, or R=Fixed)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0  MMU/PU Enable         (0=Disable, 1=Enable) (Fixed 0 if none)
  1  Alignment Fault Check (0=Disable, 1=Enable) (Fixed 0/1 if none/always on)
  2  Data/Unified Cache    (0=Disable, 1=Enable) (Fixed 0/1 if none/always on)
  3  Write Buffer          (0=Disable, 1=Enable) (Fixed 0/1 if none/always on)
  4  Exception Handling    (0=26bit, 1=32bit)    (Fixed 1 if always 32bit)
  5  26bit-address faults  (0=Enable, 1=Disable) (Fixed 1 if always 32bit)
  6  Abort Model (pre v4)  (0=Early, 1=Late Abort) (Fixed 1 if ARMv4 and up)
  7  Endian                (0=Little, 1=Big)     (Fixed 0/1 if fixed)
  8  System Protection bit (MMU-only)
  9  ROM Protection bit    (MMU-only)
  10 Implementation defined
  11 Branch Prediction     (0=Disable, 1=Enable)
  12 Instruction Cache     (0=Disable, 1=Enable) (ignored if Unified cache)
  13 Exception Vectors     (0=00000000h, 1=FFFF0000h)
  14 Cache Replacement     (0=Normal, 1=Predictable)
  15 Pre-ARMv5 Mode        (0=Normal, 1=Pre ARMv5; LDM/LDR/POP)
  16 DTCM Enable           (0=Disable, 1=Enable)
  17 DTCM Load Mode        (0=R/W, 1=DTCM Write-only)
  18 ITCM Enable           (0=Disable, 1=Enable)
  19 ITCM Load Mode        (0=R/W, 1=ITCM Write-only)
  20-31 Reserved           (keep these bits unchanged) (usually zero)
</PRE></TD></TR></TBODY></TABLE>Various 
bits in this register may be read-only (fixed 0 if unsupported, or fixed 1 if 
always activated).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armcp15memorymanagmentunitmmu"></A><FONT size="+2">&nbsp;ARM 
      CP15 Memory Managment Unit (MMU)</FONT></TD></TR></TBODY></TABLE><BR>Function of 
some registers depends on wheter the CPU contains a MMU or PU.<BR>MMU handles 
virtual addressing tables.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  C2,Cm,Op2  MMU Translation Table Base
  C3,Cm,Op2  MMU Domain Access Control
  C5,Cm,Op2  MMU Fault Status
  C6,Cm,Op2  MMU Fault Address
  C8,Cm,Op2  MMU TLB Control
  C10,Cm,Op2 MMU TLB Lockdown
</PRE></TD></TR></TBODY></TABLE>The 
GBA, and Nintendo DS do not have a MMU.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armcp15protectionunitpu"></A><FONT size="+2">&nbsp;ARM CP15 
      Protection Unit (PU)</FONT></TD></TR></TBODY></TABLE><BR>Protection Unit can be 
enabled in Bit0 of C1,C0,0 (Control Register).<BR><BR><B>C2,C0,0 - Cachability 
Bits for Data/Unified Protection Region (R/W)</B><BR><B>C2,C0,1 - Cachability 
Bits for Instruction Protection Region (if any) (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-7  Cachable (C) bits for region 0-7
  8-31 Reserved/zero
</PRE></TD></TR></TBODY></TABLE><BR><B>C3,C0,0 
- Write-Bufferability Bits for Data Protection Regions (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-7  Bufferable (B) bits for region 0-7
  8-31 Reserved/zero
</PRE></TD></TR></TBODY></TABLE>Instruction 
fetches are, obviously, always read-operations. So, there are no
 write-bufferability bits for Instruction Protection Regions.<BR><BR><B>C5,C0,0 
- Access Permission Data/Unified Protection Region (R/W)</B><BR><B>C5,C0,1 - 
Access Permission Instruction Protection Region (if any) (R/W)</B><BR><B>C5,C0,2 
- Extended Access Permission Data/Unified Protection Region 
(R/W)</B><BR><B>C5,C0,3 - Extended Access Permission Instruction Protection 
Region (if any) (R/W/W)</B><BR>For C5,C0,0 and C5,C0,1:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-15  Access Permission (AP) bits for region 0-7 (Bits 0-1=AP0, 2-3=AP1, etc)
  16-31 Reserved/zero
</PRE></TD></TR></TBODY></TABLE>For 
C5,C0,2 and C5,C0,3 (Extended):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-31  Access Permission (AP) bits for region 0-7 (Bits 0-3=AP0, 4-7=AP1, etc)
</PRE></TD></TR></TBODY></TABLE>The 
possible AP settings (0-3 for C5,C0,0..1, or 0-15 for C5,C0,2..3) are:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  AP  Privileged User
  0   -          -
  1   R/W        -
  2   R/W        R
  3   R/W        R/W
  5   R          -
  6   R          R
</PRE></TD></TR></TBODY></TABLE>Settings 
5,6 only for Extended Registers, settings 4,7..15 are 
Reserved.<BR><BR><B>C6,C0..C7,0 - Protection Unit Data/Unified Region 0..7 
(R/W)</B><BR><B>C6,C0..C7,1 - Protection Unit Instruction Region 0..7 (R/W) if 
any</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0     Protection Region Enable (0=Disable, 1=Enable)
  1-5   Protection Region Size   (2 SHL X) ;min=(X=11)=4KB, max=(X=31)=4GB
  6-11  Reserved/zero
  12-31 Protection Region Base address (Addr = Y*4K; must be SIZE-aligned)
</PRE></TD></TR></TBODY></TABLE>Overlapping 
Regions are allowed, Region 7 is having highest priority, region 0 lowest 
priority.<BR><BR><B>Background Region</B><BR>Additionally, any memory areas 
outside of the eight Protection Regions are handled as Background Region, this 
region has neither Read nor Write access.<BR><BR><B>Unified Region Note</B><BR>
On some systems (eg. NDS), the Region registers may be unified (same settings
 used for code and data), whilst the Cachabilty and Permission registers may be 
non-unified (separate registers for code and data settings).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armcp15cachecontrol"></A><FONT size="+2">&nbsp;ARM CP15 Cache 
      Control</FONT></TD></TR></TBODY></TABLE><BR>Cache enabled/controlled by Bit 
2,3,12,14 in Control Register.<BR>Cache type detected in Cache Type 
Register.<BR><BR><B>C7,C0..C15,0..7 - Cache Commands (W)</B><BR>Write-only Cache 
Command Register. Cm,Op2 operands used to select a specific command, with 
parameter value in Rd.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Cn,Cm,Op2 Rd   Command
  C7,C0,4   0    Wait For Interrupt (Halt)
  C7,C5,0   0    Invalidate Entire Instruction Cache
  C7,C5,1   VA   Invalidate Instruction Cache Line
  C7,C5,2   S/I  Invalidate Instruction Cache Line
  C7,C5,4   0    Flush Prefetch Buffer
  C7,C5,6   0    Flush Entire Branch Target Cache
  C7,C5,7   IMP  Flush Branch Target Cache Entry
  C7,C6,0   0    Invalidate Entire Data Cache
  C7,C6,1   VA   Invalidate Data Cache Line
  C7,C6,2   S/I  Invalidate Data Cache Line
  C7,C7,0   0    Invalidate Entire Unified Cache
  C7,C7,1   VA   Invalidate Unified Cache Line
  C7,C7,2   S/I  Invalidate Unified Cache Line
  C7,C8,2   0    Wait For Interrupt (Halt), alternately to C7,C0,4
  C7,C10,1  VA   Clean Data Cache Line
  C7,C10,2  S/I  Clean Data Cache Line
  C7,C10,4  0    Drain Write Buffer
  C7,C11,1  VA   Clean Unified Cache Line
  C7,C11,2  S/I  Clean Unified Cache Line
  C7,C13,1  VA   Prefetch Instruction Cache Line
  C7,C14,1  VA   Clean and Invalidate Data Cache Line
  C7,C14,2  S/I  Clean and Invalidate Data Cache Line
  C7,C15,1  VA   Clean and Invalidate Unified Cache Line
  C7,C15,2  S/I  Clean and Invalidate Unified Cache Line
</PRE></TD></TR></TBODY></TABLE>Parameter 
values (Rd) formats:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0    Not used, should be zero
  VA   Virtual Address
  S/I  Set/index; Bit 31..(32-A) = Index, Bit (L+S-1)..L = Set ?
  IMP  ?
</PRE></TD></TR></TBODY></TABLE><BR><B>C9,C0,0 
- Data Cache Lockdown</B><BR><B>C9,C0,1 - Instruction Cache Lockdown</B><BR>
(Width (W) of index field depends on cache ASSOCIATIVETY.)<BR>Format A:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0..(31-W)  Reserved/zero
  (32-W)..31 Lockdown Block Index
</PRE></TD></TR></TBODY></TABLE>Format 
B:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0..(W-1)   Lockdown Block Index
  W..30      Reserved/zero
  31         L
</PRE></TD></TR></TBODY></TABLE><BR>
Cache/Write-buffer should not be enabled for the whole 4GB memory area,
 high-speed TCM memory doesn't require caching, and caching would have fatal
 results on I/O ports. So, cache can be used only in combination with the
 Protection Unit, which allows to enable/disable caching in specified 
regions.<BR><BR><B>Note</B><BR>ARMv5 instruction set supports a Cache Prepare 
for Load opcode (PLD), see<BR><A href="#arm9singledatatransferldrstrpld">ARM.9: 
Single Data Transfer (LDR, STR, PLD)</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armcp15fastcontextswitchextensionfcse"></A><FONT 
      size="+2">&nbsp;ARM CP15 Fast Context Switch Extension 
  (FCSE)</FONT></TD></TR></TBODY></TABLE><BR><B>C13,C0,0 - Process ID for Fast 
Context Switch Extension (FCSE) (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-24  Reserved/zero
  25-31 Process ID (PID) (0-127) (0=Disable)
</PRE></TD></TR></TBODY></TABLE>The 
FCSE allows different processes (each assembled with ORG 0) to be located at 
virtual addresses in the 1st 32MB area. The FCSE splits the total 4GB address 
space into blocks of 32MB, accesses to Block(0) are redirected to
 Block(PID):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  IF addr&lt;32M then addr=addr+PID*32M
  Respectively, with PID=0, the address remains unchanged (FCSE disabled).
</PRE></TD></TR></TBODY></TABLE>The 
CPU-to-Memory address handling is shown below:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  1. CPU outputs a virtual address (VA)
  2. FCSE adjusts the VA to a modified virtual address (MVA)
  3. Cache hits determined by examining the MVA, continue below if no hit
  4. MMU translates MVA to physical address (PA) (if no MMU present: PA=MVA)
  5. Memory access occurs at PA
</PRE></TD></TR></TBODY></TABLE>The 
FCSE allows limited virtual addressing even if no MMU is present.<BR>If the MMU 
is present, then either the FCSE and/or the MMU can be used for virtual 
addressing; the advantage of using the FCSE (a single write to C13,C0,0) is less 
overload; using the MMU for the same purpose would require to change virtual 
address translation table in memory, and to flush the cache.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="armcp15tightlycoupledmemorytcm"></A><FONT size="+2">&nbsp;ARM 
      CP15 Tightly Coupled Memory (TCM)</FONT></TD></TR></TBODY></TABLE><BR>TCM is 
high-speed memory, directly contained in the ARM CPU core.<BR><BR><B>TCM and 
DMA</B><BR>TCM doesn't use the ARM bus. A minor disadvantage is that TCM cannot 
be accessed by DMA. However, the main advantage is that, when using TCM, the CPU
 can be kept running without any waitstates even while the bus is used for DMA
 transfers. Operation during DMA works only if all code/data is located in TCM, 
waitstates are generated if any code/data outside TCM is accessed; in worst case 
(if there are no gaps in the DMA) then the CPU is halted until the DMA 
finishes.<BR><BR><B>TCM and DMA and IRQ</B><BR>No idea if/how IRQs are handled 
during DMA? Eventually (unlikely) code in TCM is kept executed until DMA 
finishes (ie. until the IRQ vector can be accessed. Eventually the IRQ vector is 
instantly accessed (causing to halt the CPU until DMA finishes). In both cases: 
Assuming that IRQs are enabled, and that the IRQ vector and/or IRQ handler are 
located outside TCM.<BR><BR><B>Separate Instruction (ITCM) and Data (DTCM) 
Memory</B><BR>DTCM can be used only for Data accesses, typically used for stacks 
and other frequently accessed data.<BR>ITCM is primarily intended for 
instruction accesses, but it can be also used for Data accesses (among others 
allowing to copy code to ITCM), however, performance isn't optimal when 
simultaneously accessing ITCM for code and data (such like opcodes in ITCM that 
use literal pool values in ITCM).<BR><BR><B>TCM Enable, TCM Load Mode</B><BR>
CP15 Control Register allows to enable ITCM and DTCM, and to switch ITCM/DTCM
 into Load Mode. In Load Mode (when TCM is enabled), TCM becomes write-only;
 this allows to read data from source addresses in main memory, and to write
 data to destination addresses in TCM by using the same addresses; useful for
 initializing TCM with overlapping source/dest addresses; Load mode works with
 all Load/Store opcodes, it does NOT work with SWP/SWPB opcodes.<BR><BR>TCM 
Physical Size can be detected in 3rd ID Code Register. 
(C0,C0,2)<BR><BR><B>C9,C1,0 - Data TCM Size/Base (R/W)</B><BR><B>C9,C1,1 - 
Instruction TCM Size/Base (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0     Reserved     (0)
  1-5   Virtual Size (Size = 512 SHL N) ;min=(N=3)=4KB, max=(N=23)=4GB
  6-11  Reserved     (0)
  12-31 Region Base  (Base = X SHL 12)  ;Base must be Size-aligned
</PRE></TD></TR></TBODY></TABLE>The 
ITCM region base may be fixed (read-only). The Virtual size settings should be 
normally same as the Physical sizes (see C0,C0,2). However, smaller sizes are 
allowed (using only the 1st some KB), as well as bigger sizes (TCM area is then 
filled with mirrors of physical TCM).<BR><BR><B>TCM and PU</B><BR>TCM can be 
used without Protection Unit.<BR>When the protection unit is enabled, TCM is 
controlled by the PU just like normal memory, the PU should provide R/W Access 
Permission for TCM regions; cache and write-buffer are not required for 
high-speed TCM (so both should be disabled for TCM regions).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cpuinstructioncycletimes"></A><FONT size="+2">&nbsp;CPU 
      Instruction Cycle Times</FONT></TD></TR></TBODY></TABLE><BR>Instruction Cycle 
Summary<BR><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE><B>  Instruction      Cycles      Additional</B>
  ---------------------------------------------------------------------
  Data Processing  1S          +1S+1N if R15 loaded, +1I if SHIFT(Rs)
  MSR,MRS          1S
  LDR              1S+1N+1I    +1S+1N if R15 loaded
  STR              2N
  LDM              nS+1N+1I    +1S+1N if R15 loaded
  STM              (n-1)S+2N
  SWP              1S+2N+1I
  BL (THUMB)       3S+1N
  B,BL             2S+1N
  SWI,trap         2S+1N
  MUL              1S+ml
  MLA              1S+(m+1)I
  MULL             1S+(m+1)I
  MLAL             1S+(m+2)I
  CDP              1S+bI
  LDC,STC          (n-1)S+2N+bI
  MCR              1N+bI+1C
  MRC              1S+(b+1)I+1C
  {cond} false     1S
</PRE></TD></TR></TBODY></TABLE>Whereas,<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  n = number of words transferred
  b = number of cycles spent in coprocessor busy-wait loop
  m = depends on most significant byte(s) of multiplier operand
</PRE></TD></TR></TBODY></TABLE>Above 
'trap' is meant to be the execution time for exceptions. And '{cond} false' is 
meant to be the execution time for conditional instructions which haven't been 
actually executed because the condition has been false.<BR><BR>The separate 
meaning of the N,S,I,C cycles is:<BR><BR><B>N - Non-sequential cycle</B><BR>
Requests a transfer to/from an address which is NOT related to the address used 
in the previous cycle. (Called 1st Access in GBA language).<BR>The execution 
time for 1N is 1 clock cycle (plus non-sequential access
 waitstates).<BR><BR><B>S - Sequential cycle</B><BR>Requests a transfer to/from 
an address which is located directly after the address used in the previous 
cycle. Ie. for 16bit or 32bit accesses at incrementing addresses, the first 
access is Non-sequential, the following accesses are sequential. (Called 2nd 
Access in GBA language).<BR>The execution time for 1S is 1 clock cycle (plus 
sequential access waitstates).<BR><BR><B>I - Internal Cycle</B><BR>CPU is just 
too busy, not even requesting a memory transfer for now.<BR>The execution time 
for 1I is 1 clock cycle (without any waitstates).<BR><BR><B>C - Coprocessor 
Cycle</B><BR>The CPU uses the data bus to communicate with the coprocessor (if 
any), but no memory transfers are requested.<BR><BR><B>Memory Waitstates</B><BR>
Ideally, memory may be accessed free of waitstates (1N and 1S are then equal to 
1 clock cycle each). However, a memory system may generate waitstates for 
several reasons: The memory may be just too slow. Memory is currently accessed 
by DMA, eg. sound, video, memory transfers, etc. Or when data is squeezed 
through a 16bit data bus (in that special case, 32bit access may have more 
waitstates than 8bit and 16bit accesses). Also, the memory system may separate 
between S and N cycles (if so, S cycles would be typically faster than N 
cycles).<BR><BR><B>Memory Waitstates for Different Memory Areas</B><BR>Different 
memory areas (eg. ROM and RAM) may have different waitstates. When executing 
code in one area which accesses data in another area, then the S+N cycles must 
be split into code and data accesses: 1N is used for data access, plus (n-1)S 
for LDM/STM, the remaining S+N are code access. If an instruction jumps to a 
different memory area, then all code cycles for that opcode are having waitstate 
characteristics of the NEW memory area (except Thumb BL which still executes 1S 
in OLD area).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cpuversions"></A><FONT size="+2">&nbsp;CPU 
  Versions</FONT></TD></TR></TBODY></TABLE><BR><B>Version Numbers</B><BR>ARM CPUs 
are distributed by name ARM#, and are described as ARMv# in specifications, 
whereas "#" is NOT the same than "v#", for example, ARM7TDMI is ARMv4TM. That is 
so confusing, that ARM didn't even attempt to clarify the relationship between 
the various "#" and "v#" values.<BR><BR><B>Version Variants</B><BR>Suffixes like 
"M" (long multiply), "T" (Thumb support), "E" (Enhanced DSP) indicate presence 
of special features, additionally to the standard instruction set of a given 
version, or, when preceded by an "x", indicate the absence of that 
features.<BR><BR><B>ARMv1 aka ARM1</B><BR>Some sort of a beta version, according 
to ARM never been used<BR>in any commercial products.<BR><BR><B>ARMv2 and 
up</B><BR>MUL,MLA<BR>CDP,LDC,MCR,MRC,STC<BR>SWP/SWPB (ARMv2a and up only)<BR>Two 
new FIQ registers<BR><BR><B>ARMv3 and up</B><BR>MRS,MSR opcodes (instead 
CMP/CMN/TST/TEQ{P} opcodes)<BR>CPSR,SPSR registers (instead PSR bits in R15)<BR>
Removed never condition, cond=NV no longer valid<BR>32bit addressing (instead 
26bit addressing in older versions)<BR>26bit addressing backwards comptibility 
mode (except v3G)<BR>Abt and Und modes (instead handling aborts/undefined in Svc 
mode)<BR>SMLAL,SMULL,UMLAL,UMULL (optionally, INCLUDED in v3M, EXCLUDED in 
v4xM/v5xM)<BR><BR><B>ARMv4 aka ARM7 and up</B><BR>LDRH,LDRSB,LDRSH,STRH<BR>Sys 
mode (privileged user mode)<BR>BX (only ARMv4T, and any ARMv5 or ARMv5T and 
up)<BR>THUMB code (only T variants, ie. ARMv4T, ARMv5T)<BR><BR><B>ARMv5 and 
up</B><BR>BKPT,BLX,CLZ (BKPT,BLX also in THUMB mode)<BR>LDM/LDR/POP PC with mode 
switch (POP PC also in THUMB mode)<BR>CDP2,LDC2,MCR2,MRC2,STC2 (new coprocessor 
opcodes)<BR>C-flag unchanged by MUL (instead undefined flag value)<BR>changed 
instruction cycle timings / interlock ??? or not ???<BR>QADD,QDADD,QDSUB,QSUB 
opcodes, CPSR.Q flag (v5TE and V5TExP only)<BR>
SMLAxy,SMLALxy,SMLAWy,SMULxy,SMULWy (v5TE and V5TExP only)<BR>
LDRD,STRD,PLD,MCRR,MRRC (v5TE only, not v5, not v5TExP)<BR><BR><B>ARMv6</B><BR>
No public specifications available.<BR><BR><B>A Milestone in Computer 
History</B><BR>Original ARMv2 has been used in the relative rare and expensive 
Archimedes deluxe home computer series in the late eighties, the Archimedes has
 caught a lot of attention, particularly for being the first home computer that 
used a BIOS being programmed in BASIC language - which has been a absolutely 
revolutionary decadency at that time.<BR>Inspired, programmers all over the 
world have successfully developed even slower and much more inefficient 
programming languages, which are nowadays consequently used by nearly all ARM 
programmers, and by most non-ARM programmers as well.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="cpudatasheet"></A><FONT size="+2">&nbsp;CPU Data 
    Sheet</FONT></TD></TR></TBODY></TABLE><BR>This present document is an attempt to 
supply a brief ARM7TDMI reference, hopefully including all information which is 
relevant for programmers.<BR><BR>Some details that I have treated as meaningless 
for GBA programming aren't included - such like Big Endian format, and Virtual 
Memory data aborts, and most of the chapters listed below.<BR><BR>Have a look at 
the complete data sheet (URL see below) for more detailed verbose information 
about ARM7TDMI instructions. That document also includes:<BR><BR>- Signal 
Description<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Pins of the original CPU, probably other for GBA.
</PRE></TD></TR></TBODY></TABLE>- 
Memory Interface<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Optional virtual memory circuits, etc. not for GBA.
</PRE></TD></TR></TBODY></TABLE>- 
Coprocessor Interface<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  As far as I know, none such in GBA.
</PRE></TD></TR></TBODY></TABLE>- 
Debug Interface<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  For external hardware-based debugging.
</PRE></TD></TR></TBODY></TABLE>- 
ICEBreaker Module<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  For external hardware-based debugging also.
</PRE></TD></TR></TBODY></TABLE>- 
Instruction Cycle Operations<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Detailed: What happens during each cycle of each instruction.
</PRE></TD></TR></TBODY></TABLE>- 
DC Parameters (Power supply)<BR>- AC Parameters (Signal timings)<BR><BR>The 
official ARM7TDMI data sheet can be downloaded from ARMs webpage,<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  <A title="Linkification: http://www.arm.com/Documentation/UserMans/PDF/ARM7TDMI.html" class="linkification-ext" href="http://www.arm.com/Documentation/UserMans/PDF/ARM7TDMI.html">http://www.arm.com/Documentation/UserMans/PDF/ARM7TDMI.html</A>
</PRE></TD></TR></TBODY></TABLE>Be 
prepared for bloated PDF Format, approx 1.3 MB, about 200 pages.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="ndsreference"></A><FONT size="+2">&nbsp;NDS 
    Reference</FONT></TD></TR></TBODY></TABLE><BR><A href="#dsiomaps">DS 
I/O Maps</A><BR><A href="#dsmemorymaps">DS 
Memory Maps</A><BR><A href="#dsmemorycontrol">DS 
Memory Control</A><BR><A href="#dsvideo">DS 
Video</A><BR><A href="#dssound">DS 
Sound</A><BR><A 
href="#dsvarious">DS 
Various</A><BR><A href="#dsdmatransfers">DS 
DMA Transfers</A><BR><A href="#dstimers">DS 
Timers</A><BR><A href="#dsinterrupts">DS 
Interrupts</A><BR><A href="#dsmaths">DS 
Maths</A><BR><A href="#dskeypad">DS 
Keypad</A><BR><A href="#dsinterprocesscommunicationipc">DS 
Inter Process Communication (IPC)</A><BR><A href="#dsrealtimeclockrtc">DS 
Real-Time Clock (RTC)</A><BR><A href="#dsserialperipheralinterfacebusspi">DS 
Serial Peripheral Interface Bus (SPI)</A><BR><A href="#dstouchscreencontrollertsc">DS 
Touch Screen Controller (TSC)</A><BR><A href="#dspowermanagement">DS 
Power Management</A><BR><A href="#dscartridgesencryptionfirmware">DS 
Cartridges, Encryption, Firmware</A><BR><A href="#dsxboo">DS 
Xboo</A><BR><A href="#dsbackwardscompatiblegbamode">DS 
Backwards-compatible GBA-Mode</A><BR><A href="#biosfunctions">BIOS 
Functions</A><BR><A href="#cpureference">CPU 
Reference</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsiomaps"></A><FONT size="+2">&nbsp;DS I/O 
  Maps</FONT></TD></TR></TBODY></TABLE><BR>ARM9 I/O Map<BR><B>Display Engine 
A</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000000h  56h  2D Engine A (same registers as GBA, some changed bits)
  4000060h  2    DISP3DCNT - ?
  4000064h  4    DISPCAPCNT - Display Capture Control Register (R/W)
  4000068h  4    DISP_MMEM_FIFO - Main Memory Display FIFO (R?/W)
  400006Ch  2    MASTER_BRIGHT - Master Brightness Up/Down
</PRE></TD></TR></TBODY></TABLE><B>DMA, 
Timers, and Keypad</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  40000B0h  30h  DMA Channel 0..3
  40000E0h  10h  DMA FILL Registers for Channel 0..3
  4000100h  10h  Timers 0..3
  4000130h  2    KEYINPUT
  4000132h  2    KEYCNT
</PRE></TD></TR></TBODY></TABLE><B>IPC/ROM</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000180h  2  IPCSYNC - IPC Synchronize Register (R/W)
  4000184h  2  IPCFIFOCNT - IPC Fifo Control Register (R/W)
  4000188h  4  IPCFIFOSEND - IPC Send Fifo (W)
  40001A1h  1  rom... - undoc
  40001A4h  4  romctrl - undoc
  40001A8h  8  romcmd - undoc
  40001B0h     romcrypt - (not sure if encryption can be accessed by arm9...?)
</PRE></TD></TR></TBODY></TABLE><B>Memory 
and IRQ Control</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000204h  2  EXMEMCNT - External Memory Control (R/W)
  4000208h  2  IME - Interrupt Master Enable (R/W)
  4000210h  4  IE  - Interrupt Enable (R/W)
  4000214h  4  IF  - Interrupt Request Flags (R/W)
  4000240h  1  VRAMCNT_A - VRAM-A (128K) Bank Control (W)
  4000241h  1  VRAMCNT_B - VRAM-B (128K) Bank Control (W)
  4000242h  1  VRAMCNT_C - VRAM-C (128K) Bank Control (W)
  4000243h  1  VRAMCNT_D - VRAM-D (128K) Bank Control (W)
  4000244h  1  VRAMCNT_E - VRAM-E (64K) Bank Control (W)
  4000245h  1  VRAMCNT_F - VRAM-F (16K) Bank Control (W)
  4000246h  1  VRAMCNT_G - VRAM-G (16K) Bank Control (W)
  4000247h  1  WRAMCNT   - WRAM Bank Control (W)
  4000248h  1  VRAMCNT_H - VRAM-H (32K) Bank Control (W)
  4000249h  1  VRAMCNT_I - VRAM-I (16K) Bank Control (W)
</PRE></TD></TR></TBODY></TABLE><B>Maths</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000280h  2  DIVCNT - Division Control (R/W)
  4000290h  8  DIV_NUMER - Division Numerator (R/W)
  4000298h  8  DIV_DENOM - Division Denominator (R/W)
  40002A0h  8  DIV_RESULT - Division Quotient (=Numer/Denom) (R/W?)
  40002A8h  8  DIVREM_RESULT - Division Remainder (=Numer MOD Denom) (R/W?)
  40002B0h  2  SQRTCNT - Square Root Control (R/W)
  40002B4h  4  SQRT_RESULT - Square Root Result (R/W?)
  40002B8h  8  SQRT_PARAM - Square Root Parameter Input (R/W)
  4000300h  4  POSTFLG - Undoc
  4000304h  2  POWCNT1 - Graphics Power Control Register (R/W)
</PRE></TD></TR></TBODY></TABLE><B>3D 
Display Engine</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000320h..6A3h
</PRE></TD></TR></TBODY></TABLE><B>Display Engine 
B</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4001000h  56h  2D Engine B (same registers as GBA, some changed bits)
                 (above Engine B probably excludes separate DISPSTAT/VCOUNT?)
  400106Ch  2    DB_MASTER_BRIGHT - 16bit - Master Brightness Up/Down
</PRE></TD></TR></TBODY></TABLE><B></B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4100000h  4    IPCFIFORECV - IPC Receive Fifo (R)
  4100010h  4    undoc
</PRE></TD></TR></TBODY></TABLE><B>Main 
Memory Control</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  27FFFFEh  2    Main Memory Control
</PRE></TD></TR></TBODY></TABLE><B>Further 
Memory Control Registers</B><BR><A href="#armcp15systemcontrolcoprocessor">ARM 
CP15 System Control Coprocessor</A><BR><BR><B>ARM7 I/O Map</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000004h  2   DISPSTAT
  4000006h  2   VCOUNT
  40000B0h  30h DMA Channels 0..3
  4000100h  10h Timers 0..3
  4000120h  4   debug siodata32
  4000128h  4   debug siocnt
  4000130h  2   keyinput
  4000132h  2   keycnt
  4000134h  2   debug rcnt
  4000136h  2   EXTKEYIN
  4000138h  1   RTC Realtime Clock Bus
  4000180h  2   IPCSYNC - IPC Synchronize Register (R/W)
  4000184h  2   IPCFIFOCNT - IPC Fifo Control Register (R/W)
  4000188h  4   IPCFIFOSEND - IPC Send Fifo (W)
  40001A1h  1   Gamecard bus whatever
  40001A4h  4   Gamecard bus timing/control
  40001A8h  8   Gamecard bus 8-byte command out
  40001B0h  4   Gamecard Encryption
  40001B4h  4   Gamecard Encryption
  40001B8h  2   Gamecard Encryption
  40001BAh  2   Gamecard Encryption
  40001C0h  2   Firmware SPI bus Control
  40001C2h  2   Firmware SPI bus Data
  4000204h  2   EXMEMSTAT - External Memory Status
  4000206h  2   Unknown (set to 0030h) maybe bug, or WLAN/POWCNT related?
  4000208h  4   IME
  4000210h  4   IE
  4000214h  4   IF
  4000240h  1   VRAMSTAT - VRAM-C,D Bank Status (R)
  4000241h  1   WRAMSTAT - WRAM Bank Status (R)
  4000300h  1   POSTFLG
  4000301h  1   HALTCNT (different bits than on GBA) (plus NOP delay)
  4000304h  2   POWCNT2  Sound/Wifi Power Control Register (R/W)
  4000308h  4   BIOSPROT - Bios-data-read-protection address
</PRE></TD></TR></TBODY></TABLE><B>Sound 
Registers</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4000400h 100h Sound Channel 0..15 (10h bytes each)
  40004x0h  4  SOUNDxCNT - Sound Channel X Control Register (R/W)
  40004x4h  4  SOUNDxSAD - Sound Channel X Data Source Register (W)
  40004x8h  2  SOUNDxTMR - Sound Channel X Timer Register (W)
  40004xAh  2  SOUNDxPNT - Sound Channel X Loopstart Register (W)
  40004xCh  4  SOUNDxLEN - Sound Channel X Length Register (W)
  4000500h  2  SOUNDCNT - Sound Control Register (R/W)
  4000504h  2  SOUNDBIAS - Sound Bias Register (R/W)
  4000508h  1  SNDCAP0CNT - Sound Capture 0 Control Register (R/W)
  4000509h  1  SNDCAP1CNT - Sound Capture 1 Control Register (R/W)
  4000510h  4  SNDCAP0DAD - Sound Capture 0 Destination Address (W?)
  4000514h  2  SNDCAP0LEN - Sound Capture 0 Length (R/W)
  4000518h  4  SNDCAP1DAD - Sound Capture 1 Destination Address (W?)
  400051Ch  2  SNDCAP1LEN - Sound Capture 1 Length (R/W)
</PRE></TD></TR></TBODY></TABLE>gamecart...<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4100000h  4   IPCFIFORECV - IPC Receive Fifo (R)
  4100010h  4   Gamecard bus 4-byte data in, for manual or dma read
</PRE></TD></TR></TBODY></TABLE><B>WLAN 
Registers</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  4808036h  2   W
  4808158h  2   W
  480815Ah  2   W
  480815Ch  2   R
  480815Eh  2   R
  4808160h  2   W
  4808168h  2   W
  480817Ch  2   W
  480817Eh  2   W
  4808180h  2   R
  4808184h  2   W
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsmemorymaps"></A><FONT size="+2">&nbsp;DS Memory 
    Maps</FONT></TD></TR></TBODY></TABLE><BR><B>ARM9</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  01000000h  Instruction TCM (32KB) (moveable)
  02000000h  Main Memory (4MB)
  027C0000h  Data TCM (16KB) (moveable)
  03000000h  Shared WRAM (0KB, 16KB, or 32KB can be allocated to ARM9)
  04000000h  ARM9-I/O Ports
  05000000h  Standard Palettes (2KB) (Engine A BG/OBJ, Engine B BG/OBJ)
  06000000h  VRAM - Engine A, BG VRAM (max 512KB)
  06200000h  VRAM - Engine B, BG VRAM (max 128KB)
  06400000h  VRAM - Engine A, OBJ VRAM (max 256KB)
  06600000h  VRAM - Engine B, OBJ VRAM (max 128KB)
  06800000h  VRAM - "LCDC"-allocated (max 656KB)
  07000000h  OAM (2KB) (Engine A, Engine B)
  08000000h  GBA Slot ROM (max. 32MB)
  0A000000h  GBA Slot RAM (max. 64KB)
  FFFF0000h  ARM9-BIOS (32KB) (only 3K used)
</PRE></TD></TR></TBODY></TABLE>The 
ARM9 Exception Vectors are located at FFFF0000h. The IRQ handler redirects to 
[DTCM+3FFCh].<BR><BR><B>ARM7</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  00000000h  ARM7-BIOS (16KB)
  02000000h  Main Memory (4MB)
  03000000h  Shared WRAM (0KB, 16KB, or 32KB can be allocated to ARM7)
  03800000h  ARM7-WRAM (64KB)
  04000000h  ARM7-I/O Ports
  04800000h  Wireless Communications Wait State 0
  04808000h  Wireless Communications Wait State 1
  06000000h  VRAM allocated as Work RAM to ARM7 (max. 256K)
  08000000h  GBA Slot ROM (max. 32MB)
  0A000000h  GBA Slot RAM (max. 64KB)
</PRE></TD></TR></TBODY></TABLE>The 
ARM7 Exception Vectors are located at 00000000h. The IRQ handler redirects to 
[3FFFFFCh aka 380FFFCh].<BR><BR><B>Further Memory (not mapped to ARM9/ARM7 
bus)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  3D Engine Polygon RAM (52KBx2)
  3D Engine Vertex RAM (72KBx2)
  Firmware (256KB) (built-in serial flash memory)
  GBA-BIOS (16KB) (not used in NDS mode)
  NDS Slot ROM (serial 8bit-bus, max. 4GB with default protocol)
  NDS Slot EEPROM (serial 1bit-bus)
</PRE></TD></TR></TBODY></TABLE><BR><B>Shared-RAM</B><BR>
Even though Shared WRAM begins at 3000000h, programs are commonly using mirrors 
at 37F8000h (both ARM9 and ARM7). At the ARM7-side, this allows to use 32K 
Shared WRAM and 64K ARM7-WRAM as a continous 96K RAM block.<BR><BR><B>Undefined 
I/O Ports</B><BR>On the NDS (at the ARM9-side at least) undefined I/O ports are 
always zero.<BR><BR><B>Undefined Memory Regions</B><BR>16MB blocks that do not 
contain any defined memory regions (or that contain only mapped TCM regions) are 
typically completely undefined.<BR>16MB blocks that do contain valid memory 
regions are typically containing mirrors of that memory in the unused upper part 
of the 16MB area (only exceptions are TCM and BIOS which are not 
mirrored).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsmemorycontrol"></A><FONT size="+2">&nbsp;DS Memory 
      Control</FONT></TD></TR></TBODY></TABLE><BR><A href="#dsmemorycontrolcacheandtcm">DS 
Memory Control - Cache and TCM</A><BR><A href="#dsmemorycontrolcartridgesandmainram">DS 
Memory Control - Cartridges and Main RAM</A><BR><A href="#dsmemorycontrolwram">DS 
Memory Control - WRAM</A><BR><A href="#dsmemorycontrolvram">DS 
Memory Control - VRAM</A><BR><A href="#dsmemorycontrolbios">DS 
Memory Control - BIOS</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsmemorycontrolcacheandtcm"></A><FONT size="+2">&nbsp;DS 
      Memory Control - Cache and TCM</FONT></TD></TR></TBODY></TABLE><BR>TCM and Cache 
are controlled by the System Control Coprocessor,<BR><A href="#armcp15systemcontrolcoprocessor">ARM 
CP15 System Control Coprocessor</A><BR><BR>The specifications for the NDS9 
are:<BR><BR><B>Tightly Coupled Memory (TCM)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  ITCM 32K (default address 1000000h)
  DTCM 16K (default address 27C0000h)
</PRE></TD></TR></TBODY></TABLE><BR><B>Cache</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Data Cache 4KB, Instruction Cache 8KB
  4-way set associative method
  Cache line 8 words (32 bytes)
  Read-allocate method (ie. writes are not allocating cache lines)
  Round-robin and Pseudo-random replacement algorithms selectable
  Cache Lockdown, Instruction Prefetch, Data Preload
  Data write-through and write-back modes selectable
</PRE></TD></TR></TBODY></TABLE><BR><B>Protection 
Unit (PU)</B><BR>Recommended/default settings are:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Region  Name            Address   Size   Cache WBuf Code Data
  -       Background      00000000h 4GB    -     -    -    -
  0       I/O and VRAM    04000000h 64MB   -     -    R/W  R/W
  1       Main Memory     02000000h 4MB    On    On   R/W  R/W
  2       ARM7-dedicated  027C0000h 256KB  -     -    -    -
  3       GBA Slot        08000000h 128MB  -     -    -    R/W
  4       DTCM            027C0000h 16KB   -     -    -    R/W
  5       ITCM            01000000h 32KB   -     -    R/W  R/W
  6       BIOS            FFFF0000h 32KB   On    -    R    R
  7       Shared Work     027FF000h 4KB    -     -    -    R/W
</PRE></TD></TR></TBODY></TABLE>Notes: 
In Nintendos hardware-debugger, Main Memory is expanded to 8MB (for that reason, 
some addresses are at 27NN000h instead 23NN000h) (some of the extra memory is 
reserved for the debugger, some can be used for game development). Region 2 and 
7 are not understood? GBA Slot should be max 32MB+64KB, rounded up to 64MB, no 
idea why it is 128MB? DTCM and ITCM do not use Cache and Write-Buffer because 
TCM is fast. Above settings do not allow to access Shared Memory at 37F8000h? Do 
not use cache/wbuf for I/O, doing so might suppress writes, and/or might read 
outdated values.<BR>The main purpose of the Protection Unit is debugging, a 
major problem with GBA programs have been faulty accesses to memory address 
00000000h and up (due to [base+offset] addressing with uninitialized (zero) base 
values). This problem has been fixed in the NDS, for the ARM9 processor at 
least, still there are various leaks: For example, the 64MB I/O and VRAM area 
contains only ca. 660KB valid addresses, and the ARM7 probably doesn't have a
 Protection Unit at all. Alltogether, the protection is better than in GBA, but 
it's still pretty crude compared with software debugging tools.<BR>Region 
address/size are unified (same for code and data), however, cachabilty and 
access rights are non-unified (and may be separately defined for code and
 data).<BR><BR>Note: The NDS7 doesn't have any TCM, Cache, or CP15.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsmemorycontrolcartridgesandmainram"></A><FONT 
      size="+2">&nbsp;DS Memory Control - Cartridges and Main 
  RAM</FONT></TD></TR></TBODY></TABLE><BR><B>4000204h - NDS9 - EXMEMCNT - 16bit - 
External Memory Control (R/W)</B><BR><B>4000204h - NDS7 - EXMEMSTAT - 16bit - 
External Memory Status (R/W..R)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-1   32-pin GBA Slot SRAM Access Waitstate    (0-3 = 10, 8, 6, 18 cycles)
  2-3   32-pin GBA Slot ROM 1st Access Waitstate (0-3 = 10, 8, 6, 18 cycles)
  4     32-pin GBA Slot ROM 2nd Access Waitstate (0-1 = 6, 4 cycles)
  5-6   32-pin GBA Slot PHI-pin out   (0-3 = Low, 4.19MHz, 8.38MHz, 16.76MHz)
  7     32-pin GBA Slot Access Rights     (0=ARM9, 1=ARM7)
  8-10  Not used (always zero)
  11    17-pin NDS Slot Access Rights     (0=ARM9, 1=ARM7)
  12    Not used (always zero)
  13    Not used (always set ?)
  14    Main Memory Interface Mode Switch (0=Async/GBA/Reserved, 1=Synchronous)
  15    Main Memory Access Priority       (0=ARM9 Priority, 1=ARM7 Priority)
</PRE></TD></TR></TBODY></TABLE>Bit0-6 
can be changed by both NDS9 and NDS7, changing these bits affects the local 
EXMEM register only, not that of the other CPU.<BR>Bit7-15 can be changed by 
NDS9 only, changing these bits affects both EXMEM registers, ie. both NDS9 and 
NDS7 can read the current NDS9 setting.<BR>Bit14=0 is intended for GBA mode, 
however, writes to this bit appear to be ignored?<BR><A href="#dsmainmemorycontrol">DS 
Main Memory Control</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsmemorycontrolwram"></A><FONT size="+2">&nbsp;DS Memory 
      Control - WRAM</FONT></TD></TR></TBODY></TABLE><BR><B>4000247h - NDS9 - WRAMCNT 
- 8bit - WRAM Bank Control (R/W)</B><BR><B>4000241h - NDS7 - WRAMSTAT - 8bit - 
WRAM Bank Status (R)</B><BR>Should not be changed when using Nintendo's API.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-1   ARM9/ARM7 (0-3 = 32K/0K, 2nd 16K/1st 16K, 1st 16K/2nd 16K, 0K/32K)
  2-7   Not used
</PRE></TD></TR></TBODY></TABLE>The 
ARM9 WRAM area is 3000000h-3FFFFFFh (16MB range).<BR>The ARM7 WRAM area is 
3000000h-37FFFFFh (8MB range).<BR>The allocated 16K or 32K are mirrored 
everywhere in the above areas.<BR>De-allocation (0K) is a special case: At the 
ARM9-side, the WRAM area is then empty (containing undefined data). At the 
ARM7-side, the WRAM area is then containing mirrors of the 64KB ARM7-WRAM (the 
memory at 3800000h and up).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsmemorycontrolvram"></A><FONT size="+2">&nbsp;DS Memory 
      Control - VRAM</FONT></TD></TR></TBODY></TABLE><BR><B>4000240h - NDS7 - VRAMSTAT 
- 8bit - VRAM Bank Status (R)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0     VRAM C enabled and allocated to NDS7  (0=No, 1=Yes)
  1     VRAM D enabled and allocated to NDS7  (0=No, 1=Yes)
  2-7   Not used (always zero)
</PRE></TD></TR></TBODY></TABLE>The 
register indicates if VRAM C/D are allocated to NDS7 (as Work RAM), ie. if 
VRAMCNT_C/D are enabled (Bit7=1), with MST=2 (Bit0-2). However, it does not 
reflect the OFS value.<BR><BR><B>4000240h - VRAMCNT_A - 8bit - VRAM-A (128K) 
Bank Control (W)</B><BR><B>4000241h - VRAMCNT_B - 8bit - VRAM-B (128K) Bank 
Control (W)</B><BR><B>4000242h - VRAMCNT_C - 8bit - VRAM-C (128K) Bank Control 
(W)</B><BR><B>4000243h - VRAMCNT_D - 8bit - VRAM-D (128K) Bank Control 
(W)</B><BR><B>4000244h - VRAMCNT_E - 8bit - VRAM-E (64K) Bank Control 
(W)</B><BR><B>4000245h - VRAMCNT_F - 8bit - VRAM-F (16K) Bank Control 
(W)</B><BR><B>4000246h - VRAMCNT_G - 8bit - VRAM-G (16K) Bank Control 
(W)</B><BR><B>4000248h - VRAMCNT_H - 8bit - VRAM-H (32K) Bank Control 
(W)</B><BR><B>4000249h - VRAMCNT_I - 8bit - VRAM-I (16K) Bank Control 
(W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-2   VRAM MST              ;Bit2 not used by VRAM-A,B,H,I
  3-4   VRAM Offset (0-3)     ;Offset not used by VRAM-E,H,I
  5-6   Not used
  7     VRAM Enable (0=Disable, 1=Enable)
</PRE></TD></TR></TBODY></TABLE>There 
is a total of 656KB of VRAM in Blocks A-I.<BR>Table below shows the possible 
configurations.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE><B>  VRAM    SIZE  MST  OFS   ARM9, Plain ARM9-CPU Access (so-called LCDC mode)</B>
  A       128K  0    -     6800000h-681FFFFh
  B       128K  0    -     6820000h-683FFFFh
  C       128K  0    -     6840000h-685FFFFh
  D       128K  0    -     6860000h-687FFFFh
  E       64K   0    -     6880000h-688FFFFh
  F       16K   0    -     6890000h-6893FFFh
  G       16K   0    -     6894000h-6897FFFh
  H       32K   0    -     6898000h-689FFFFh
  I       16K   0    -     68A0000h-68A3FFFh
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine A, BG-VRAM (max 512K)</B>
  A,B,C,D 128K  1    0..3  6000000h+(20000h*OFS)
  E       64K   1    -     6000000h
  F,G     16K   1    0..3  6000000h+(4000h*OFS.0)+(10000h*OFS.1)
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine A, OBJ-VRAM (max 256K)</B>
  A,B     128K  2    0..1  6400000h+(20000h*OFS.0)  ;(OFS.1 must be zero)
  E       64K   2    -     6400000h
  F,G     16K   2    0..3  6400000h+(4000h*OFS.0)+(10000h*OFS.1)
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine A, BG Extended Palette</B>
  E       64K   4    -     Slot 0-3  ;only lower 32K used
  F,G     16K   4    0..1  Slot 0-1 (OFS=0), Slot 2-3 (OFS=1)
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine A, OBJ Extended Palette</B>
  F,G     16K   5    -     Slot 0  ;16K each (only lower 8K used)
<B>  VRAM    SIZE  MST  OFS   Texture Image</B>
  A,B,C,D 128K  3    0..3  Slot OFS(0-3) ... or Slot2-3=Clear image ?
<B>  VRAM    SIZE  MST  OFS   Texture Palette</B>
  E       64K   3    -     Slots 0-3                 ;OFS=don't care
  F,G     16K   3    0..3  Slot (OFS.0*1)+(OFS.1*4)  ;ie. Slot 0, 1, 4, or 5
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine B, BG-VRAM (max 128K)</B>
  C       128K  4    -     6200000h
  H       32K   1    -     6200000h
  I       16K   1    -     6208000h
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine B, OBJ-VRAM (max 128K)</B>
  D       128K  4    -     6600000h
  I       16K   2    -     6600000h
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine B, BG Extended Palette</B>
  H       32K   2    -     Slot 0-3
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine B, OBJ Extended Palette</B>
  I       16K   3    -     Slot 0  ;(only lower 8K used)
<B>  VRAM    SIZE  MST  OFS   &lt;ARM7&gt;, Plain &lt;ARM7&gt;-CPU Access</B>
  C,D     128K  2    0..1  6000000h+(20000h*OFS.0)  ;OFS.1 must be zero
</PRE></TD></TR></TBODY></TABLE><BR><B>Notes</B><BR>
In Plain-CPU modes, VRAM can be accessed only by the CPU (and by the Capture
 Unit, and by VRAM Display mode). In "Plain &lt;ARM7&gt;-CPU Access" mode, the 
VRAM blocks are allocated as Work RAM to the NDS7 CPU.<BR>In BG/OBJ VRAM modes, 
VRAM can be accessed by the CPU at specified addresses, and by the display 
controller.<BR>In Extended Palette and Texture Image/Palette modes, VRAM is not 
mapped to CPU address space, and can be accessed only by the display controller 
(so, to initialize or change the memory, it should be temporarily switched to
 Plain-CPU mode).<BR><BR><B>Other Video RAM</B><BR>Aside from the map-able VRAM 
blocks, there are also some video-related memory regions at fixed addresses:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  5000000h Engine A Standard BG Palette (512 bytes)
  5000200h Engine A Standard OBJ Palette (512 bytes)
  5000400h Engine B Standard BG Palette (512 bytes)
  5000600h Engine B Standard OBJ Palette (512 bytes)
  7000000h Engine A OAM (1024 bytes)
  7000400h Engine B OAM (1024 bytes)
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsmemorycontrolbios"></A><FONT size="+2">&nbsp;DS Memory 
      Control - BIOS</FONT></TD></TR></TBODY></TABLE><BR><B>4000308h - NDS7 - BIOSPROT 
- Bios-data-read-protection address</B><BR>Used to double-protect the first some 
KBytes of the NDS7 BIOS. The BIOS is split into two protection regions, one 
always active, one controlled by the BIOSPROT register. The overall idea is that 
only the BIOS can read from itself, any other attempts to read from that regions 
return FFh-bytes.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Opcodes at...      Can read from      Expl.
  0..[BIOSPROT]-1    0..3FFFh           Double-protected (when BIOSPROT is set)
  [BIOSPROT]..3FFFh  [BIOSPROT]..3FFFh  Normal-protected (always active)
</PRE></TD></TR></TBODY></TABLE>The 
initial BIOSPROT setting on power-up is zero (disabled). Before starting the 
cartridge, the BIOS boot code sets the register to 1204h (actually 1205h, but 
the mis-aligned low-bit is ignored). Once when initialized, further writes to 
the register are ignored.<BR><BR>The double-protected region contains the 
exception vectors, some bytes of code, and the cartridge KEY1 encryption seed 
(about 4KBytes). As far as I know, it is impossible to unlock the memory once 
when it is locked, however, with some trickery, it is possible execute code 
before it gets locked. Also, the two THUMB opcodes at 05ECh can be used to read 
all memory at 0..3FFFh,<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  05ECh  ldrb r3,[r3,12h]      ;requires incoming r3=src-12h
  05EEh  pop  r2,r4,r6,r7,r15  ;requires dummy values &amp; THUMB retadr on stack
</PRE></TD></TR></TBODY></TABLE>Additionally 
most BIOS functions (eg. CpuSet), include a software-based protection which 
rejects source addresses in the BIOS area (the only exception is GetCRC16, 
though it still cannot bypass the BIOSPROT setting).<BR><BR><B>Note</B><BR>The 
NDS9 BIOS doesn't include any software or hardware based read 
protection.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsvideo"></A><FONT size="+2">&nbsp;DS 
  Video</FONT></TD></TR></TBODY></TABLE><BR><A href="#lcdvideocontroller">LCD 
Video Controller</A><BR><BR><A href="#dsvideostuff">DS 
Video Stuff</A><BR><A href="#dsvideobgmodescontrol">DS 
Video BG Modes / Control</A><BR><A href="#dsvideoobjs">DS 
Video OBJs</A><BR><A href="#dsvideoextendedpalettes">DS 
Video Extended Palettes</A><BR><A href="#dsvideocaptureandmainmemorydisplaymode">DS 
Video Capture and Main Memory Display Mode</A><BR><A href="#dsvideodisplaysystemblockdiagram">DS 
Video Display System Block Diagram</A><BR><BR>For Display Power Control (and 
Display Swap), and VRAM Allocation, see<BR><A href="#dspowermanagement">DS 
Power Management</A><BR><A href="#dsmemorycontrolvram">DS 
Memory Control - VRAM</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsvideostuff"></A><FONT size="+2">&nbsp;DS Video 
    Stuff</FONT></TD></TR></TBODY></TABLE><BR><B>400006Ch - (DB_)MASTER_BRIGHT - 
16bit - Master Brightness Up/Down</B><BR>Supported for both Display Engine A 
(Port 400006Ch) and B (Port 400106Ch).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-4   Factor used for 6bit R,G,B Intensities (0-16, values &gt;16 same as 16)
          Brightness up:   New = Old + (63-Old) * Factor/16
          Brightness down: New = Old - Old      * Factor/16
  5-13  Not used
  14-15 Mode (0=Disable, 1=Up, 2=Down, 3=Reserved)
</PRE></TD></TR></TBODY></TABLE><BR><B>DISPSTAT/VCOUNT</B><BR>
The LY and LYC values are in range 0..262, so LY/LYC values have been expanded 
to 9bit values: LY = VCOUNT Bit 0..8, and LYC=DISPSTAT Bit8..15,7.<BR>VCOUNT 
register is write-able, allowing to synchronize linked DS consoles.<BR>For 
proper synchronization:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  write new LY values only in range of 202..212
  write only while old LY values are in range of 202..212
</PRE></TD></TR></TBODY></TABLE><BR><B>VRAM 
Waitstates</B><BR>The display controller performs VRAM-reads once every 6 clock 
cycles, a 1 cycle waitstate is generated if the CPU simultaneously accesses 
VRAM.<BR>With capture enabled, additionally VRAM-writes take place once every 6
 cycles, so the total VRAM-read/write access rate is then once every 3 
cycles.<BR><BR><B>DS Window Glitches</B><BR>The DS counts scanlines in range 
0..262 (0..106h), of which only the lower 8bit are compared with the WIN0V/WIN1V 
register settings. Respectively, Y1 coordinates 00h..06h will be triggered in 
scanlines 100h-106h by mistake. That means, the window gets activated within 
VBlank period, and will be active in scanline 0 and up (that is no problem with 
Y1=0, but Y1=1..6 will appear as if if Y1 would be 0). Workaround would be to 
disable the Window during VBlank, or to change Y1 during VBlank (to a value that 
does not occur during VBlank period, ie. 7..191).<BR>Also, there's a problem to 
fit the 256 pixel horizontal screen resolution into 8bit values: X1=00h is 
treated as 0 (left-most), X2=00h is treated as 100h (right-most). However, the 
window is not displayed if X1=X2=00h; the window width can be max 255 
pixels.<BR><BR><B>2D Engines</B><BR>Includes two 2D Engines, called A and B. 
Both engines are accessed by the ARM9 processor, each using different memory and 
register addresses:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Region______Engine A______________Engine B___________
  I/O Ports   4000000h              4001000h
  Palette     5000000h (1K)         5000400h (1K)
  BG VRAM     6000000h (max 512K)   6200000h (max 128K)
  OBJ VRAM    6400000h (max 256K)   6600000h (max 128K)
  OAM         7000000h (1K)         7000400h (1K)
</PRE></TD></TR></TBODY></TABLE>Engine 
A additionally supports 3D and large-screen 256-color Bitmaps, plus
 main-memory-display and vram-display modes, plus capture 
unit.<BR><BR><B>Viewing Angles</B><BR>The LCD screens are best viewed at viewing 
angles of 90 degrees. Colors may appear distorted, and may even become invisible 
at other viewing angles.<BR>When the console is handheld, both screens can be 
turned into preferred direction. When the console is settled on a table, only 
the upper screen can be turned, but the lower screen is stuck into horizontal 
position - which results rather bad visibility (unless the user moves his/her 
head directly above of it).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsvideobgmodescontrol"></A><FONT size="+2">&nbsp;DS Video BG 
      Modes / Control</FONT></TD></TR></TBODY></TABLE><BR><B>DS DISPCNT</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-2   BG Mode
  3     A:BG0 2D/3D Selection (instead CGB Mode) (0=2D, 1=3D)
  3     B:Not used            (instead CGB Mode)
  4     Tile OBJ Mapping  (0=2D; max 32KB, 1=1D; max 32KB..256KB; see Bit20-21)
  5-6   Bitmap OBJ Mapping
  7-15  Same as GBA
  16-17 A: Display Mode (instead Green Swap, Green swap still supp. in GBA mode)
  18-19 A: VRAM block (0..3=VRAM A..D) (For Capture, and above Display Mode=2)
  16    B: Display Mode (instead Green Swap, Green swap still supp. in GBA mode)
  17-19 B: Not used
  20-21 A/B: Ext OBJ CH
  22    A: Ext OBJ BM
  22    B: Not used
  23    A/B: OBJ Processing during H-Blank (was located in Bit5 on GBA)
  24-26 A: Character Base (in 64K steps) (merged with 16K step in BGxCNT)
  27-29 A: Screen Base (in 64K steps) (merged with 2K step in BGxCNT)
  24-29 B: Not used
  30-21 A/B: Ext Palette
</PRE></TD></TR></TBODY></TABLE><BR><B>BG 
Mode</B><BR>Engine A BG Mode (DISPCNT LSBs) (0-6, 7=Reserved)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Mode  BG0      BG1      BG2      BG3
  0     Text/3D  Text     Text     Text
  1     Text/3D  Text     Text     Affine
  2     Text/3D  Text     Affine   Affine
  3     Text/3D  Text     Text     Extended
  4     Text/3D  Text     Affine   Extended
  5     Text/3D  Text     Extended Extended
  6     3D       -        Large    -
</PRE></TD></TR></TBODY></TABLE>Engine 
B: Same as above, except that: Mode 6 is reserved (no Large screen bitmap), and 
BG0 is always Text (no 3D support).<BR>Affine = formerly Rot/Scal mode (with 
8bit BG Map entries)<BR>Extended Affine = can be 3 different types (selected in 
BGnCNT register):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> 1) rot/scal with 16bit BG Map entries (mixup of Text and Affine modes)
 2) rot/scal 256 color bitmap
 3) rot/scal direct color bitmap
</PRE></TD></TR></TBODY></TABLE>Large 
Screen Bitmap = rot/scal 256 color bitmap (using all 512K of 2D 
VRAM)<BR><BR><B>Display Mode (DISPCNT.16-17):</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0  Display off (screen becomes white)
  1  Graphics Display (normal BG and OBJ layers)
  2  Engine A only: VRAM Display (Bitmap from block selected in DISPCNT.18-19)
  3  Engine A only: Main Memory Display (Bitmap DMA transfer from Main RAM)
</PRE></TD></TR></TBODY></TABLE>Mode 
2-3 display a raw direct color bitmap (15bit RGB values, the upper bit in each 
halfword is unused), without any further BG,OBJ,3D layers, these modes are 
completely bypassing the 2D/3D engines as well as any 2D effects, however the 
Master Brightness effect can be applied to these modes. Mode 2 is particulary 
useful to display captured 2D/3D images (in that case it can indirectly use the 
2D/3D engine).<BR><BR><B>BGxCNT</B><BR>character base extended from bit2-3 to 
bit2-5 (bit4-5 formerly unused)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  engine A screen base: BGxCNT.bits*2K + DISPCNT.bits*64K
  engine B screen base: BGxCNT.bits*2K + 0
  engine A char base: BGxCNT.bits*16K + DISPCNT.bits*64K
  engine B char base: BGxCNT.bits*16K + 0
</PRE></TD></TR></TBODY></TABLE>char 
base is used only in tile/map modes (not bitmap modes)<BR>screen base is used in 
tile/map modes,<BR>screen base used in bitmap modes as BGxCNT.bits*16K, without 
DISPCNT.bits*64K<BR>screen base however NOT used at all for Large screen bitmap 
mode<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  bgcnt size  text     rotscal    bitmap   large bmp
  0           256x256  128x128    128x128  512x1024
  1           512x256  256x256    256x256  1024x512
  2           256x512  512x512    512x256  -
  3           512x512  1024x1024  512x512  -
</PRE></TD></TR></TBODY></TABLE>bitmaps 
that require more than 128K VRAM are supported on engine A only.<BR><BR>Extended 
Affine modes (selected in DISPCNT) are sub-selected in BGxCNT,<BR>(extended 
affine doesn't include 16-color modes, so color depth bit can be used for mode 
selection. Also, bitmap modes do not use charbase, so charbase.0 can be used for 
mode selection as well)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  ColorDepth  charbase.bit0
  0           x (charbase)      rot/scal tile/map mode with 16bit entries
  1           0 (mode)          256 color bitmap
  1           1 (mode)          direct color bitmap
</PRE></TD></TR></TBODY></TABLE><BR>
for BG0, BG1 only: bit13 selects extended palette slot<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>                   (BG0: 0=Slot0, 1=Slot2, BG1: 0=Slot1, 1=Slot3)
</PRE></TD></TR></TBODY></TABLE><BR>
Direct Color Bitmap BG, and Direct Color Bitmap OBJ<BR>BG/OBJ Supports 32K 
colors (15bit RGB value) - so far same as GBAs BG.<BR>However, the upper bit 
(Bit15) is used as Alpha flag.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsvideoobjs"></A><FONT size="+2">&nbsp;DS Video 
  OBJs</FONT></TD></TR></TBODY></TABLE><BR><B>DS OBJ Priority</B><BR>The GBA has 
been assigning OBJ priority in respect to the 7bit OAM entry number, regardless 
of the OBJs 2bit BG-priority attribute (which allowed to specify invalid 
priority orders). That problem has been fixed in DS mode by combining the above 
two values into a 9bit priority value.<BR><BR><B>OBJ Tile Mapping 
(DISPCNT.4,20-21):</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit4  Bit20-21  Dimension Boundary Total
  0     x         2D        32       32K   ;Same as GBA 2D Mapping
  1     0         1D        32       32K   ;Same as GBA 1D Mapping
  1     1         1D        64       64K
  1     2         1D        128      128K
  1     3         1D        256      256K (Engine B: 128K)
</PRE></TD></TR></TBODY></TABLE>TileVramAddress 
= TileNumber * BoundaryValue<BR>Even if the boundary gets changed, OBJs are kept 
composed of 8x8 tiles.<BR><BR><B>Bitmap OBJ Mapping (DISPCNT.5-6,22):</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit5-6 Bit22  Dimension    Boundary Total
  0      x      2D/128 dots  32 bytes   32K  (Source Bitmap width 128 dots)
  1      x      2D/256 dots  32 bytes   32K  (Source Bitmap width 256 dots)
  2      0      1D           128 bytes  128K (Source Width = Target Width)
  2      1      1D           256 bytes  256K (Engine A only)
  3      x      Reserved
</PRE></TD></TR></TBODY></TABLE>BitmapVramAddress 
= TileNumber * BoundaryValue<BR><BR><B>OBJ Attribute 0 and 2</B><BR>Setting the 
OBJ Mode bits (Attr 0, Bit10-11) to a value of 3 has been prohibited in GBA, 
however, in NDS it selects the the new Bitmap OBJ mode; in that mode, the Color 
depth bit (Attr 0, Bit13) should be set to zero; also in that mode, the color 
bits (Attr 2, Bit 12-15) are used as Alpha-OAM value (instead of as palette 
setting).<BR><BR><B>OBJ Vertical Wrap</B><BR>On the GBA, a large OBJ located 
near the bottom of the screen has been wrapped to the top of the screen (and was 
NOT displayed at the bottom. This problem has been "corrected" in the NDS 
(except in GBA mode), presumably by displaying the OBJ only at the screen 
bottom, or BOTH wrapped at top and bottom?<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsvideoextendedpalettes"></A><FONT size="+2">&nbsp;DS Video 
      Extended Palettes</FONT></TD></TR></TBODY></TABLE><BR><B>Extended 
Palettes</B><BR>When allocating extended palettes, the allocated memory is not 
mapped to the CPU bus, so the CPU can access extended palette only when 
temporarily de-allocating it.<BR><BR>BG Extended Palette enabled in DISPCNT Bit 
31, when enabled,<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> standard palette --&gt; used for 16x16 color tiles, and 256 color bitmaps,
                      256 color tiles with 8bit bgmap entries (rot/scal mode)
 extended palette --&gt; used for 256x16 color tiles (16bit bgmap entries)
</PRE></TD></TR></TBODY></TABLE>color 
0 of all standard/extended palettes is transparent, color 0 of BG standard 
palette 0 is used as backdrop. extended palette memory must be allocated to 
VRAM. Allocated VRAM is split into 4 slots of 8K each (32K used in total), 
normally BG0..3 are using Slot 0..3, however BG0 and BG1 can be optionally 
changed to BG0=Slot2, and BG1=Slot3 via BG0CNT and BG1CNT.<BR><BR>OBJ Extended 
Palette enabled in DISPCNT Bit 30, when enabled,<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> 16 colors x 16 palettes --&gt; standard palette memory (=256 colors)
 256 colors x 16 palettes --&gt; extended palette memory (=4096 colors)
</PRE></TD></TR></TBODY></TABLE>color 
0 of all standard/extended palettes is transparent, color 0 of BG standard 
palette 0 is used as backdrop. extended palette memory must be allocated to VRAM 
F, G, or I (which are 16K) of which only the first 8K are used for extended 
palettes (=1000h 16bit entries).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsvideocaptureandmainmemorydisplaymode"></A><FONT 
      size="+2">&nbsp;DS Video Capture and Main Memory Display 
  Mode</FONT></TD></TR></TBODY></TABLE><BR><B>4000064h - DISPCAPCNT - 32bit - 
Display Capture Control Register (R/W)</B><BR>Capture is supported for Display 
Engine A only.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-4   EVA               (0..16 = Blending Factor for Source A)
  5-7   Not used
  8-12  EVB               (0..16 = Blending Factor for Source B)
  13-15 Not used
  16-17 VRAM Write Block  (0..3 = VRAM A..D) (VRAM must be allocated to LCDC)
  18-19 VRAM Read Offset  (0=00000h, 0=08000h, 0=10000h, 0=18000h)
  20-21 Capture Size      (0=128x128, 1=256x64, 2=256x128, 3=256x192 dots)
  22-23 Not used
  24    Source A          (0=Graphics Screen BG+3D+OBJ, 1=3D Screen)
  25    Source B          (0=VRAM, 1=Main Memory Display FIFO)
  26-27 VRAM Write Offset (0=00000h, 0=08000h, 0=10000h, 0=18000h)
  28    Not used
  29-30 Capture Source    (0=Source A, 1=Source B, 2/3=Sources A+B blended)
  31    Capture Enable    (0=Disable/Ready, 1=Enable/Busy)
</PRE></TD></TR></TBODY></TABLE>Notes:<BR>
VRAM Read Block (VRAM A..D) is selected in DISPCNT Bits 18-19.<BR>VRAM Read 
Block can be (or must be ?) allocated to LCDC (MST=0).<BR>VRAM Read Offset is 
ignored (zero) in VRAM Display Mode (DISPCNT.16-17).<BR>VRAM Read/Write Offsets 
wrap to 00000h when exceeding 1FFFFh (max 128K).<BR>After setting the Capture 
Enable bit, capture starts at next line 0.<BR>The capture enable bit is 
automatically cleared at end of capture.<BR><BR>Capture data is 15bit color 
depth (even when capturing 18bit 3D-images).<BR>Capture A:  Dest_Intensity = 
SrcA_Intensitity ; Dest_Alpha=SrcA_Alpha.<BR>Capture B:  Dest_Intensity = 
SrcB_Intensitity ; Dest_Alpha=SrcB_Alpha.<BR>Capture A+B (blending):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> Dest_Intensity = (  (SrcA_Intensitity * SrcA_Alpha * EVA)
                   + (SrcB_Intensitity * SrcB_Alpha * EVB) ) / 16
 Dest_Alpha = (SrcA_Alpha AND (EVA&gt;0)) OR (SrcB_Alpha AND EVB&gt;0))
</PRE></TD></TR></TBODY></TABLE><BR>
Capture provides a couple of interesting effects.<BR>For example, 3D Engine 
output can be captured via source A (to LCDC-allocated VRAM), in the next frame, 
either Graphics Engine A or B can display the captured 3D image in VRAM image as 
BG2, BG3, or OBJ (from BG/OBJ-allocated VRAM); this method requires to switch 
between LCDC- and BG/OBJ-allocation.<BR>Another example would be to capture 
Engine A output, the captured image can be displayed (via VRAM Display mode) in 
the following frames, simultaneously the new Engine A output can be captured, 
blended with the old captured image; in that mode moved objects will leave 
traces on the screen; this method works with a single LCDC-allocated VRAM 
block.<BR><A href="#dsvideodisplaysystemblockdiagram">DS 
Video Display System Block Diagram</A><BR><BR><B>4000068h - DISP_MMEM_FIFO - 
32bit - Main Memory Display FIFO (R?/W)</B><BR>Intended to send 256x192 pixel 
32K color bitmaps by DMA directly<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> - to Screen A             (set DISPCNT to Main Memory Display mode), or
 - to Display Capture unit (set DISPCAPCNT to Main Memory Source).
</PRE></TD></TR></TBODY></TABLE>The 
FIFO can receive 4 words (8 pixels) at a time, each pixel is a 15bit RGB value 
(the upper bit, bit15, is unused).<BR>Set DMA to Main Memory mode, 32bit 
transfer width, word count set to 4, destination address to DISP_MMEM_FIFO, 
source address must be in Main Memory.<BR>Transfer starts at next frame.<BR>Main 
Memory Display/Capture is supported for Display Engine A only.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsvideodisplaysystemblockdiagram"></A><FONT 
      size="+2">&nbsp;DS Video Display System Block 
Diagram</FONT></TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>             _____________               __________
  VRAM A --&gt;| 2D Graphics |--------OBJ-&gt;|          |
  VRAM B --&gt;| Engine A    |--------BG3-&gt;| Layering |
  VRAM C --&gt;|             |--------BG2-&gt;| and      |
  VRAM D --&gt;|             |--------BG1-&gt;| Special  |
  VRAM E --&gt;|             |   ___       | Effects  |
  VRAM F --&gt;|             |-&gt;|SEL|      |          |          ______
  VRAM G --&gt;| - - - - - - |  |BG0|-BG0-&gt;|          |----+---&gt;|      |
            | 3D Graphics |-&gt;|___|      |__________|    |    |Select|
            | Engine      |                             |    |Video |
            |_____________|--------3D----------------+  |    |Input |
             _______      _______              ___   |  |    |      |
            |       |    |       |&lt;-----------|SEL|&lt;-+  |    |and   |--&gt;
            |       |    |       |    _____   |A  |     |    |      |
  VRAM A &lt;--|Select |    |Select |   |     |&lt;-|___|&lt;----+    |Master|
  VRAM B &lt;--|Capture|&lt;---|Capture|&lt;--|Blend|   ___           |Bright|
  VRAM C &lt;--|Dest.  |    |Source |   |_____|&lt;-|SEL|&lt;----+    |A     |
  VRAM D &lt;--|       |    |       |            |B  |     |    |      |
            |_______|    |_______|&lt;-----------|___|&lt;-+  |    |      |
             _______                                 |  |    |      |
  VRAM A --&gt;|Select |                                |  |    |      |
  VRAM B --&gt;|Display|--------------------------------+------&gt;|      |
  VRAM C --&gt;|VRAM   |                                   |    |      |
  VRAM D --&gt;|_______|   _____________                   |    |      |
                       |Main Memory  |                  |    |      |
  Main   ------DMA----&gt;|Display FIFO |------------------+---&gt;|______|
  Memory               |_____________|
             _____________               __________           ______
  VRAM C --&gt;| 2D Graphics |--------OBJ-&gt;| Layering |         |      |
  VRAM D --&gt;| Engine B    |--------BG3-&gt;| and      |         |Master|
  VRAM H --&gt;|             |--------BG2-&gt;| Special  |--------&gt;|Bright|--&gt;
  VRAM I --&gt;|             |--------BG1-&gt;| Effects  |         |B     |
            |_____________|--------BG0-&gt;|__________|         |______|
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dssound"></A><FONT size="+2">&nbsp;DS 
  Sound</FONT></TD></TR></TBODY></TABLE><BR>The DS contains 16 hardware sound 
channels.<BR>The console contains two speakers, arranged left and right of the 
upper screen, and so, provides stereo sound even without using the headphone
 socket.<BR><BR><A href="#dssoundchannels015">DS 
Sound Channels 0..15</A><BR><A href="#dssoundcontrolregisters">DS 
Sound Control Registers</A><BR><A href="#dssoundcapture">DS 
Sound Capture</A><BR><A href="#dssoundblockdiagrams">DS 
Sound Block Diagrams</A><BR><A href="#dssoundnotes">DS 
Sound Notes</A><BR><BR>Power control<BR>When restoring power supply to the sound 
circuit, do not output any sound during the first 15 milliseconds.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dssoundchannels015"></A><FONT size="+2">&nbsp;DS Sound 
      Channels 0..15</FONT></TD></TR></TBODY></TABLE><BR>Each of the 16 sound channels 
occopies 16 bytes in the I/O region, starting with channel 0 at 
4000400h..400040Fh, up to channel 15 at 40004F0h..40004FFh.<BR><BR><B>40004x0h - 
ARM7 - SOUNDxCNT - Sound Channel X Control Register (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-6    Volume       (0..127=silent..loud)
  Bit7      Not used     (always zero)
  Bit8-9    Data Shift   (0=Normal, 1=Div2, 2=Div4, 3=Div16)
  Bit10-14  Not used     (always zero)
  Bit15     Hold         (0=Nothing, 1=Hold)               (?)
  Bit16-22  Panning      (0..127=left..right) (64=half volume on both speakers)
  Bit23     Not used     (always zero)
  Bit24-26  Wave Duty    (0..7) ;HIGH=(N+1)*12.5%, LOW=(7-N)*12.5% (PSG only)
  Bit27-28  Repeat Mode  (0=Manual, 1=Loop Infinite, 2=One-Shot, 3=Prohibited)
  Bit29-30  Format       (0=PCM8, 1=PCM16, 2=IMA-ADPCM, 3=PSG/Noise)
  Bit31     Start/Status (0=Stop, 1=Start/Busy)
</PRE></TD></TR></TBODY></TABLE>All 
channels support ADPCM/PCM formats, PSG rectangular wave can be used only on 
channels 8..13, and white noise only on channels 14..15.<BR><BR><B>40004x4h - 
ARM7 - SOUNDxSAD - Sound Channel X Data Source Register (W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-26  Source Address
  Bit27-31 Not used
</PRE></TD></TR></TBODY></TABLE><BR><B>40004x8h 
- ARM7 - SOUNDxTMR - Sound Channel X Timer Register (W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-15  Timer Value, Sample frequency, timerval=-(16777216 / freq)
</PRE></TD></TR></TBODY></TABLE>The 
PSG Duty Cycles are composed of eight "samples", and so, the frequency for 
Rectangular Wave is 1/8th of the selected sample frequency.<BR>For PSG Noise, 
the noise frequency is equal to the sample frequency.<BR><BR><B>40004xAh - ARM7 
- SOUNDxPNT - Sound Channel X Loopstart Register (W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-15  Loop Start, Sample loop start position
</PRE></TD></TR></TBODY></TABLE><BR><B>40004xCh 
- ARM7 - SOUNDxLEN - Sound Channel X Length Register (W)</B><BR>The number of 
samples for N words is 4*N PCM8 samples, 2*N PCM16 samples, or 8*(N-1) ADPCM 
samples (the first word containing the ADPCM header). The Sound Length is not 
used in PSG mode.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-21  Sound length (counted in words, ie. N*4 bytes)
  Bit22-31 Not used
</PRE></TD></TR></TBODY></TABLE>Minimum 
length is 4 words (16 bytes), smaller values (0..3 words) are interpreted as 
zero length (no sound output).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dssoundcontrolregisters"></A><FONT size="+2">&nbsp;DS Sound 
      Control Registers</FONT></TD></TR></TBODY></TABLE><BR><B>4000500h - SOUNDCNT - 
ARM7 - Sound Control Register (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-6   Master Volume          (0..127=silent..loud)
  Bit7     Not used               (always zero)
  Bit8-9   Left Out      (probably selects Mixer or "Bypassed" channels?)
  Bit10-11 Right Out     (probably selects Mixer or "Bypassed" channels?)
  Bit12    Output Sound Channel 1 (0=To Mixer, 1=Bypass Mixer)
  Bit13    Output Sound Channel 3 (0=To Mixer, 1=Bypass Mixer)
  Bit14    Not used               (always zero)
  Bit15    Master Enable          (0=Disable, 1=Enable)
</PRE></TD></TR></TBODY></TABLE><BR><B>4000504h 
- SOUNDBIAS - ARM7 - Sound Bias Register (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-9   Sound Bias    (0..3FFh, usually 200h)
  Bit10-31 Not used      (always zero)
</PRE></TD></TR></TBODY></TABLE>After 
applying the master volume, the signed left/right audio signals are in range 
-200h..+1FFh (with medium level zero), the Bias value is then added to convert 
the signed numbers into unsigned values (with medium level 200h).<BR><BR>The 
sampling frequency of the mixer is 1.04876 MHz with an amplitude resolution of 
24 bits, but the sampling frequency after mixing with PWM modulation is 32.768 
kHz with an amplitude resolution of 10 bits.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dssoundcapture"></A><FONT size="+2">&nbsp;DS Sound 
      Capture</FONT></TD></TR></TBODY></TABLE><BR>The DS contains 2 built-in sound 
capture devices that can capture output waveform data to memory.<BR>Sound 
capture 0 can capture output from left-mixer or output from channel 0.<BR>Sound 
capture 1 can capture output from right-mixer or output from channel 
2.<BR><BR><B>4000508h - SNDCAP0CNT - ARM7 - Sound Capture 0 Control Register 
(R/W)</B><BR><B>4000508h - SNDCAP1CNT - ARM7 - Sound Capture 1 Control Register 
(R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0     Control of Associated Sound Channels
            SNDCAP0CNT: Output Sound Channel 1 (0=As such, 1=Add to Channel 0)
            SNDCAP1CNT: Output Sound Channel 3 (0=As such, 1=Add to Channel 2)
  Bit1     Capture Source Selection
            SNDCAP0CNT: Capture 0 Source (0=Left Mixer, 1=Channel 0)
            SNDCAP1CNT: Capture 1 Source (0=Right Mixer, 1=Channel 2)
  Bit2     Capture Repeat        (0=Loop, 1=One-shot)
  Bit3     Capture Format        (0=PCM16, 1=PCM8)
  Bit4-6   Not used              (always zero)
  Bit7     Capture Start/Status  (0=Stop, 1=Start/Busy)
</PRE></TD></TR></TBODY></TABLE><BR><B>4000510h 
- SNDCAP0DAD - ARM7 - Sound Capture 0 Destination Address 
(R/W)</B><BR><B>4000518h - SNDCAP1DAD - ARM7 - Sound Capture 1 Destination 
Address (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-26  Destination address
  Bit27-31 Not used       (always zero)
</PRE></TD></TR></TBODY></TABLE>Capture 
start address (also used as re-start address for looped 
capture).<BR><BR><B>4000514h - SNDCAP0LEN - ARM7 - Sound Capture 0 Length 
(W)</B><BR><B>400051Ch - SNDCAP1LEN - ARM7 - Sound Capture 1 Length (W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-15  Buffer length (1..FFFFh words) (ie. N*4 bytes)
  Bit16-31 Not used
</PRE></TD></TR></TBODY></TABLE>Minimum 
length is 1 word (attempts to use 0 words are interpreted as 1 
word).<BR><BR><B>SOUND1TMR - Sound Channel 1 Timer shared as Capture 0 
Timer</B><BR><B>SOUND3TMR - Sound Channel 3 Timer shared as Capture 1 
Timer</B><BR>There are no separate capture frequency registers, instead, the 
sample frequency of Channel 1/3 is shared for Capture 0/1. These channels are
 intended to output the captured data, so it makes sense that both capture and
 sound output use the same frequency.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dssoundblockdiagrams"></A><FONT size="+2">&nbsp;DS Sound 
      Block Diagrams</FONT></TD></TR></TBODY></TABLE><BR><B>Left Mixer with Capture 
0</B><BR><B>(Right Mixer with Capture 1, respectively)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>                       _____
  Ch0.L -------------&gt;|     |  +---------------------&gt; to Capture 0
           ___        |     |  |      Ch0..Ch15  ___
  Ch1.L -&gt;|Sel|------&gt;|     |--+---------------&gt;|   |
          |___|----+  |Left |                   |   |
  Ch2.L -----------|-&gt;|Mixer|                   |Sel|    ______
           ___     |  |     |                   |   |   |Master|
  Ch3.L -&gt;|Sel|----|-&gt;|     |               Ch1 |   |--&gt;|Volume|--&gt; L
          |___|--+ |  |     |  +---------------&gt;|   |   |______|
  Ch4.L ---------|-|-&gt;|     |  |                |   |
  ...   ---------|-|-&gt;|     |  |                |   |
  Ch15.L---------|-|-&gt;|_____|  |   ___          |   |
                 | +-----------+-&gt;|Add| Ch1+Ch3 |   |
                 +---------------&gt;|___|--------&gt;|___|
</PRE></TD></TR></TBODY></TABLE><BR><B>Channel 
0 and 1, Capture 0 with input from Left Mixer</B><BR><B>(Channel 2 and 3, 
Capture 1 with input from Right Mixer, respectively)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  ____     _________     ___     ___      ___
 |FIFO|--&gt;|Channel 0|--&gt;|Vol|--&gt;|Add|-+-&gt;|Pan|--&gt; Ch0.L
 |____|   |_________|   |___|   |___| |  |___|--&gt; Ch0.R
  ____     _________     ___      ^   |
 |FIFO|&lt;--|Capture 0|&lt;--|Sel|&lt;----|---+
 |____|   |_ _____ _|   |___|&lt;----|-------------- Left Mixer
  ____     _:Timer:_     ___     _|_      ___
 |FIFO|--&gt;|Channel 1|--&gt;|Vol|--&gt;|Sel|---&gt;|Pan|--&gt; Ch1.L
 |____|   |_________|   |___|   |___|    |___|--&gt; Ch1.R
</PRE></TD></TR></TBODY></TABLE><BR><B>Channel 
4 (Channel 5..15, respectively)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  ____     _________     ___              ___
 |FIFO|--&gt;|Channel 4|--&gt;|Vol|-----------&gt;|Pan|--&gt; Ch4.L
 |____|   |_________|   |___|            |___|--&gt; Ch4.R
</PRE></TD></TR></TBODY></TABLE><BR>
The FIFO isn't used in PSG/Noise modes (supported on channel 8..15).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dssoundnotes"></A><FONT size="+2">&nbsp;DS Sound 
    Notes</FONT></TD></TR></TBODY></TABLE><BR><B>Sound delayed Start/Restart</B><BR>
A sound will be started/restarted when changing its start bit from 0 to 1,
 however, the sound won't start immediately: PSG/Noise starts after 1 sample,
 PCM starts after 3 samples, and ADPCM starts after 11 samples (3 dummy samples 
as for PCM, plus 8 dummy samples for the ADPCM header).<BR><BR><B>7bit Volume 
and Panning Values</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  data.vol = data*N/128
  data.left = data*(128-N)/128
  data.right = data*N/128.
</PRE></TD></TR></TBODY></TABLE>Register 
settings of 0..126,127 are interpreted as N=0..126,128.<BR><BR><B>PSG 
Sound</B><BR>The output volume equals to PCM16 values +7FFFh (HIGH) and -7FFFh 
(LOW).<BR>PSG sound is always Infinite (the SOUNDxLEN Register, and the 
SOUNDxCNT Repeat Mode bits have no effect). The PSG hardware doesn't support 
sound length, sweep, or volume envelopes, however, these effects can be produced 
by software with little overload (or, more typically, with enormous overload,
 depending on the programming language used).<BR><BR><B>PSG Wave Duty (channel 
8..13 in PSG mode)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0  12.5% "_______-_______-_______-"
  1  25.0% "______--______--______--"
  2  37.5% "_____---_____---_____---"
  3  50.0% "____----____----____----"
  4  62.5% "___-----___-----___-----"
  5  75.0% "__------__------__------"
  6  87.5% "_-------_-------_-------"
  7   0.0% "________________________"
</PRE></TD></TR></TBODY></TABLE>Each 
duty cycle consists of eight HIGH or LOW samples, so the sound frequency is 
1/8th of the selected sample rate. The duty cycle always starts at the begin of 
the LOW period when the sound gets (re-)started.<BR><BR><B>PSG Noise (channel 
14..15 in PSG mode)</B><BR>Noise randomly switches between HIGH and LOW samples, 
the output levels are calculated, at the selected sample rate, as such:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  X=X SHR 1, IF carry THEN Out=LOW, X=X XOR 6000h ELSE Out=HIGH
</PRE></TD></TR></TBODY></TABLE>The 
initial value when (re-)starting the sound is X=7FFFh. The formula is more or 
less same as "15bit polynomial counter" used on 8bit Gameboy and 
GBA.<BR><BR><B>PCM8 and PCM16</B><BR>Signed samples in range -80h..+7Fh (PCM8), 
or -8000h..+7FFFh (PCM16).<BR>The output volume of PCM8=NNh is equal to 
PCM16=NN00h.<BR><BR><B>IMA-ADPCM Format</B><BR>IMA-ADPCM is a Adaptive 
Differential Pulse Code Modulation (ADPCM) variant, designed by International 
Multimedia Association (IMA), the format is used, among others, in IMA-ADPCM 
compressed Windows .WAV files.<BR>The NDS data consist of a 32bit header, 
followed by 4bit values (so each byte contains two values, the first value in 
the lower 4bits, the second in upper 4 bits). The 32bit header contains initial 
values:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-15   Initial PCM16 Value (Pcm16bit = -8000h..+7FFF)
  Bit16-22  Table Index Initial Value (Index = 0..88)
  Bit23-31  Not used (zero)
</PRE></TD></TR></TBODY></TABLE>The 
4bit values are decoded into PCM16 values, as such:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Diff = ((Data4bit AND 7)*2+1)*AdpcmTable[Index]/8
  IF (Data4bit AND 8) THEN Diff = -Diff
  Pcm16bit = MinMax (Pcm16bit+Diff,-8000h,+7FFFh)
  Index = MinMax (Index+IndexTable[Data4bit AND 7],0,88)
</PRE></TD></TR></TBODY></TABLE>Whereas, 
IndexTable[0..7] = -1,-1,-1,-1,2,4,6,8. And AdpcmTable [0..88] =<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0007h,0008h,0009h,000Ah,000Bh,000Ch,000Dh,000Eh,0010h,0011h,0013h,0015h
  0017h,0019h,001Ch,001Fh,0022h,0025h,0029h,002Dh,0032h,0037h,003Ch,0042h
  0049h,0050h,0058h,0061h,006Bh,0076h,0082h,008Fh,009Dh,00ADh,00BEh,00D1h
  00E6h,00FDh,0117h,0133h,0151h,0173h,0198h,01C1h,01EEh,0220h,0256h,0292h
  02D4h,031Ch,036Ch,03C3h,0424h,048Eh,0502h,0583h,0610h,06ABh,0756h,0812h
  08E0h,09C3h,0ABDh,0BD0h,0CFFh,0E4Ch,0FBAh,114Ch,1307h,14EEh,1706h,1954h
  1BDCh,1EA5h,21B6h,2515h,28CAh,2CDFh,315Bh,364Bh,3BB9h,41B2h,4844h,4F7Eh
  5771h,602Fh,69CEh,7462h,7FFFh
</PRE></TD></TR></TBODY></TABLE>The 
closest way to reproduce the AdpcmTable with 32bit integer maths appears:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  X=000776d2h, FOR I=0 TO 88, Table[I]=X SHR 16, X=X+(X/10), NEXT I
  Table[3]=000Ah, Table[4]=000Bh, Table[88]=7FFFh, Table[89..127]=0000h
</PRE></TD></TR></TBODY></TABLE>When 
using ADPCM and loops, set the loopstart position to the data part, rather than 
the header. Do not change the ADPCM loop start position during
 playback.<BR><BR><B>Microphone Input</B><BR>For Touchscreen (and Microphone) 
inputs, see<BR><A href="#dstouchscreencontrollertsc">DS 
Touch Screen Controller (TSC)</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsvarious"></A><FONT size="+2">&nbsp;DS 
  Various</FONT></TD></TR></TBODY></TABLE><BR><B>System Clock</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bus clock = somewhat 33MHz
  NDS7 clock = somewhat 33MHz (same as bus clock)
  NDS9 clock = somewhat 66MHz (twice bus clock)
</PRE></TD></TR></TBODY></TABLE>Most 
timings in this document should be specified for 33MHz clock (not for the 66MHz 
clock). Respectively, NDS9 timings are counted in "half cycles".<BR>All external 
memory access (and I/O) is delayed to bus clock (or slower in case of additional 
waitstates), so the full 66MHz can be used only internally in the NDS9 CPU core, 
ie. with cache and TCM.<BR>The exact bus clock is specified as 33.513982 MHz 
(1FF61FEh Hertz).<BR>On my own NDS, measured in relation to the RTC seconds IRQ, 
it appears more like 1FF6231h, that inaccuary of 1 cycle per 657138 cycles 
(about one second per week) on either oscillator, isn't too significant 
though.<BR><BR><B>DS Display Dimensions / Timings</B><BR>Dot clock = 5.585664 
MHz (=33.513982 MHz / 6)<BR>H-Timing: 256 dots visible, 99 dots blanking, 355 
dots total (15.7343KHz)<BR>V-Timing: 192 lines visible, 71 lines blanking, 263 
lines total (59.8261 Hz)<BR>The V-Blank cycle for the 3D Engine consists of the 
23 lines, 191..213.<BR>Screen size 62.5mm x 47.0mm (each) (256x192 pixels)<BR>
Vertical space between screens 22mm (equivalent to 90 
pixels)<BR><BR><B>RCNT</B><BR>RCNT (134h) should be set to 80xxh (general 
purpose mode) before accessing EXTKEYIN (136h) or RTC (138h). No idea why 
(except for RTC/SI-interrupt).<BR><BR><B>DS Serial Port</B><BR>The SI line is 
labeled "INT" on the NDS mainboard, it is connected to Pin 1 of the RTC chip 
(ie. the /INT interrupt pin).<BR>I have no idea where to find SO, SC, and SD. 
I've written a test proggy that pulsed all four RCNT bits - but all I could find 
was the SI signal. However, the BIOS contains some code that uses SIO normal 
mode transfers (for the debug version), so at least SI, SO, SC should 
exist.<BR><BR><B>WLAN and 3D</B><BR>Still missing in this document. Haven't done 
any research yet.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsdmatransfers"></A><FONT size="+2">&nbsp;DS DMA 
      Transfers</FONT></TD></TR></TBODY></TABLE><BR>The DS includes four DMA channels 
for each CPU (ie. eight channels in total), which are working more or less the 
same as on GBA:<BR><A href="#dmatransfers">DMA 
Transfers</A><BR>All NDS9 and NDS7 DMA Registers are R/W. Word count is expanded 
to 21bits, max 1..1FFFFFh units, or 0=200000h units. All channels support the 
same regions and lengths. The gamepak bit (Bit 27) has been removed, instead, 
the mode bits have been expanded to a 3bit value (see below).<BR><BR>NDS9 DMACNT 
Bit27-29:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0  Start Immediately
  1  Start at V-Blank
  2  Start at H-Blank (paused during V-Blank)
  3  Synchronize to start of display
  4  Main memory display
  5  DS Cartridge Slot
  6  GBA Cartridge Slot
  7  Geometry Command FIFO
</PRE></TD></TR></TBODY></TABLE><BR>
NDS7 DMACNT Bit28-29: (Bit27 unused?)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0  Start Immediately
  1  Start at V-Blank
  2  DS Cartridge Slot
  3  DMA0/DMA2: Wireless interrupt, DMA1/DMA3: GBA Cartridge Slot
</PRE></TD></TR></TBODY></TABLE><BR><B>40000E0h 
- NDS9 only - DMA0FILL - ARM9 - DMA 0 Filldata (R/W)</B><BR><B>40000E4h - NDS9 
only - DMA1FILL - ARM9 - DMA 1 Filldata (R/W)</B><BR><B>40000E8h - NDS9 only - 
DMA2FILL - ARM9 - DMA 2 Filldata (R/W)</B><BR><B>40000ECh - NDS9 only - DMA3FILL 
- ARM9 - DMA 3 Filldata (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-31 Filldata
</PRE></TD></TR></TBODY></TABLE>The DMA Filldata 
registers contain 16 bytes of general purpose WRAM, intended to be used as fixed 
source addresses for DMA memfill operations.<BR>This is useful because DMA 
cannot read from TCM, and reading from Main RAM would require to recurse cache 
&amp; write buffer.<BR><BR><B>NDS7 Sound DMA</B><BR>The NDS additionally 
includes 16 Sound DMA channels, plus 2 Sound Capture DMA channels (see Sound 
chapter). The priority of these channels is unknown.<BR><BR><B>NDS9 Cache, 
Writebuffer, DTCM, and ITCM</B><BR>Cache and tightly coupled memory are 
connected directly to the NDS9 CPU, without using the system bus. So that, DMA 
cannot access DTCM/ITCM, and access to cached memory regions must be handled 
with care: Drain the writebuffer before DMA-reads, and invalidate the cache 
after DMA-writes. See,<BR><A href="#armcp15systemcontrolcoprocessor">ARM 
CP15 System Control Coprocessor</A><BR>The CPU can be kept running during DMA, 
provided that it is accessing only TCM (or cached memory), otherwise the CPU is 
halted until DMA finishes.<BR>Respectively, interrupts executed during DMA will 
usually halt the CPU (unless the IRQ handler uses only TCM and cache; the IRQ 
vector at FFFF00xxh must be cached, or in TCM, and the IRQ handler may not 
access IE, IF, or other I/O ports).<BR><BR><B>NDS Sequential Main Memory 
DMA</B><BR>Main RAM has different access time for sequential and non-sequential 
access. Normally DMA uses sequential access (except for the first word), 
however, if the source and destination addresses are both in Main RAM, then all 
accesses become non-sequential. In that case it would be faster to use two DMA
 transfers, one from Main RAM to a scratch buffer in WRAM, and one from WRAM to 
Main RAM.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dstimers"></A><FONT size="+2">&nbsp;DS 
  Timers</FONT></TD></TR></TBODY></TABLE><BR>Same as GBA, except F = 33.514 MHz 
(for ARM9 at least).<BR><A href="#timers">Timers</A><BR>
Both ARM9 and ARM7 have four Timers each, eight Timers in total.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsinterrupts"></A><FONT size="+2">&nbsp;DS 
    Interrupts</FONT></TD></TR></TBODY></TABLE><BR><B>4000208h - IME - 16bit - 
Interrupt Master Enable (R/W)</B><BR>Same as GBA.<BR><BR><B>4000210h - IE - 
32bit - Interrupt Enable (R/W)</B><BR><B>4000214h - IF - 32bit - Interrupt 
Request Flags (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit 0-6   Same as GBA
  Bit 7     NDS7 only: SIO/RCNT/RTC (Real Time Clock)
  Bit 8..   Same as GBA
  Bit 16    IPC Sync
  Bit 17    IPC Send FIFO Empty
  Bit 18    IPC Recv FIFO Not Empty
  Bit 19    Game Card Data Transfer Completion
  Bit 20    Game Card IREQ_MC
  Bit 21    NDS9 only: Geometry Command FIFO
  Bit 22    NDS7 only: Screens unfolding
  Bit 23    NDS7 only: SPI bus
  Bit 24    NDS7 only: Wifi
  Bit 25-31 Not used
</PRE></TD></TR></TBODY></TABLE>Raw 
TCM-only IRQs can be processed even during DMA ?<BR>For the "Same as GBA" Bits, 
see<BR><A 
href="#interruptcontrol">Interrupt 
Control</A><BR><BR><B>DTCM+3FFCh - NDS9 IRQ Handler (hardcoded RAM 
address)</B><BR><B>380FFFCh - NDS7 IRQ Handler (hardcoded RAM address)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit 0-31  Pointer to IRQ Handler
</PRE></TD></TR></TBODY></TABLE>NDS7 
Handler must use ARM code, NDS9 Handler can be ARM/THUMB 
(Bit0=Thumb).<BR><BR><B>DTCM+3FF8h - NDS9 IRQ Check Bits (hardcoded RAM 
address)</B><BR><B>380FFF8h - NDS7 IRQ Check Bits (hardcoded RAM 
address)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit 0-31  IRQ Flags (same format as IE/IF registers)
</PRE></TD></TR></TBODY></TABLE>When 
processing &amp; acknowleding interrupts via IF register, the user interrupt
 handler should also set the corresponding bits of the IRQ Check value (required 
for BIOS IntrWait and VBlankIntrWait SWI functions).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsmaths"></A><FONT size="+2">&nbsp;DS 
  Maths</FONT></TD></TR></TBODY></TABLE><BR><B>4000280h - NDS9 - DIVCNT - 16bit 
Division Control (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-1   Division Mode (0-2=See below, 3=Reserved)
  2-13  Not used
  14    Division by zero    (0=Okay, 1=Division by zero error)
  15    Busy                (0=Ready, 1=Busy) (Execution time see below)
</PRE></TD></TR></TBODY></TABLE>Division 
Modes and Busy Execution Times<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Mode  Numer / Denum = Result, Remainder ; Cycles
  0     32bit / 32bit = 32bit , 32bit     ; 18 clks
  1     64bit / 32bit = 64bit , 32bit     ; 34 clks
  2     64bit / 64bit = 64bit , 64bit     ; 34 clks
</PRE></TD></TR></TBODY></TABLE><BR><B>4000290h 
- NDS9 - DIV_NUMER - 64bit Division Numerator (R/W)</B><BR><B>4000298h - NDS9 - 
DIV_DENOM - 64bit Division Denominator (R/W)</B><BR><B>40002A0h - NDS9 - 
DIV_RESULT - 64bit Division Quotient (=Numer/Denom) (R/W?)</B><BR><B>40002A8h - 
NDS9 - DIVREM_RESULT - 64bit Remainder (=Numer MOD Denom) (R/W?)</B><BR>All 
parameters are signed 64bit values. No info if values in 32bit-mode are signed 
and if sign is in bit31 or bit63? Division is started when writing to... what... 
presumably... Denom... Msb/Lsb?<BR>The upper 32bit of DIV_DENOM must be zero in 
32bit mode (the Division by Zero check always tests all 64bits, and fails if the 
unused/upper bits are non-zero).<BR><BR><B>40002B0h - NDS9 - SQRTCNT - 16bit - 
Square Root Control (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0     Mode (0=32bit input, 1=64bit input)
  1-14  Not used
  15    Busy (0=Ready, 1=Busy) (Execution time is 13 clks, in either Mode)
</PRE></TD></TR></TBODY></TABLE><BR><B>40002B4h 
- NDS9 - SQRT_RESULT - 32bit - Square Root Result (R/W?)</B><BR><B>40002B8h - 
NDS9 - SQRT_PARAM - 64bit - Square Root Parameter Input (R/W)</B><BR>Unsigned 
64bit parameter, and unsigned 32bit result.<BR><BR><B>Notes</B><BR>Push all 
DIV/SQRT values (parameters, control, and result registers) when using DIV/SQRT 
registers on interrupt level.<BR>The NDS9 and NDS7 BIOSes additionally contain 
software based division and square root functions, which are NOT using above 
hardware registers (even the NDS9 functions are raw software).<BR>The Div/Sqrt 
timings are probably counted in 33.51MHz units?<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsinterprocesscommunicationipc"></A><FONT size="+2">&nbsp;DS 
      Inter Process Communication (IPC)</FONT></TD></TR></TBODY></TABLE><BR>Allows to 
exchange status information between ARM7 and ARM9 CPUs.<BR>The register can be 
accessed simultaneously by both CPUs (without violating access permissions, and 
without generating waitstates at either side).<BR><BR><B>4000180h - IPCSYNC - 
ARM9/ARM7 - IPC Synchronize Register (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit  Dir  Expl.
  0-3  R    Data input from IPCSYNC Bit8-11 of remote CPU (00h..0Fh)
  4-7  -    Not used
  8-11 R/W  Data output to IPCSYNC Bit0-3 of remote CPU   (00h..0Fh)
  12   -    Not used
  13   W    Send IRQ to remote CPU      (0=None, 1=Send IRQ)
  14   R/W  Enable IRQ from remote CPU  (0=Disable, 1=Enable)
  15   -    Not used
</PRE></TD></TR></TBODY></TABLE><BR><B>4000184h 
- IPCFIFOCNT - ARM9/ARM7 - IPC Fifo Control Register (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit  Dir  Expl.
  0    R    Send Fifo Empty Status      (0=Not Empty, 1=Empty)
  1    R    Send Fifo Full Status       (0=Not Full, 1=Full)
  2    R/W  Send Fifo Empty IRQ         (0=Disable, 1=Enable)
  3    W    Send Fifo Clear             (0=Nothing, 1=Flush Send Fifo)
  8    R    Receive Fifo Empty          (0=Not Empty, 1=Empty)
  9    R    Receive Fifo Full           (0=Not Full, 1=Full)
  10   R/W  Receive Fifo Not Empty IRQ  (0=Disable, 1=Enable)
  14   R/W  Error, Read Empty/Send Full (0=No Error, 1=Error/Acknowledge)
  15   R/W  Enable Send/Receive Fifo    (0=Disable, 1=Enable)
</PRE></TD></TR></TBODY></TABLE><BR><B>4000188h 
- IPCFIFOSEND - ARM9/ARM7 - IPC Send Fifo (W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-31  Send Fifo Data
</PRE></TD></TR></TBODY></TABLE><BR><B>4100000h - 
IPCFIFORECV - ARM9/ARM7 - IPC Receive Fifo (R)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-31  Receive Fifo Data
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dskeypad"></A><FONT size="+2">&nbsp;DS 
  Keypad</FONT></TD></TR></TBODY></TABLE><BR>For the GBA-buttons: Same as GBA, 
both ARM7 and ARM9 have keyboard input registers, and each its own keypad IRQ 
control register.<BR><A href="#keypadinput">Keypad 
Input</A><BR><BR>For Touchscreen (and Microphone) inputs, see<BR><A href="#dstouchscreencontrollertsc">DS 
Touch Screen Controller (TSC)</A><BR><BR><B>4000136h - ARM7 - EXTKEYIN - Key X/Y 
Input (R)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0      Button X     (0=Pressed, 1=Released)
  1      Button Y     (0=Pressed, 1=Released)
  3      DEBUG button (0=Pressed, 1=Released/None such)
  6      Pen down     (0=Pressed, 1=Released/Disabled)
  7      Hinge/folded (0=Open, 1=Closed)
  2,4,5  Unknown / set
  8..15  Unknown / zero
</PRE></TD></TR></TBODY></TABLE>The 
Hinge stuff is a magnetic sensor somewhere underneath of the Start/Select
 buttons, it will be triggered by the magnet field from the right speaker when
 the console is closed. The hinge generates an interrupt request (there seems to 
be no way to disable this, unlike as for all other IRQ sources), however, the 
interrupt execution can be disabled in IE register (as for other IRQ
 sources).<BR>The Pen Down is the /PENIRQ signal from the Touch Screen 
Controller (TSC), if it is enabled in the TSC control register, then it will 
notify the program when the screen pressed, the program should then read data 
from the TSC (if there's no /PENIRQ then doing unneccassary TSC reads would just 
waste CPU power). However, the user may release the screen before the program 
performs the TSC read, so treat the screen as not pressed if you get invalid TSC
 values (even if /PENIRQ was LOW).<BR>Not sure if the TSC /PENIRQ is actually 
triggering an IRQ in the NDS?<BR>The Debug Button should be connected to R03 and 
GND (R03 is the large soldering point between the SL1 jumper and the VR1 
potentiometer).<BR>Interrupts are reportedly not supported for X,Y 
buttons.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsrealtimeclockrtc"></A><FONT size="+2">&nbsp;DS Real-Time 
      Clock (RTC)</FONT></TD></TR></TBODY></TABLE><BR>Seiko Instruments Inc. S-35180 
(compatible with S-35190A)<BR>Miniature 8pin RTC with 3-wire serial 
bus<BR><BR><B>4000138h - Real Time Clock Register</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit  Expl.
  0    Data I/O   (0=Low, 1=High)
  1    Clock Out  (0=Low, 1=High)
  2    Select Out (0=Low, 1=High/Select)
  4    Data  Direction  (0=Read, 1=Write)
  5    Clock Direction  (should be 1=Write)
  6    Select Direction (should be 1=Write)
  3,8-11   Unused I/O Lines
  7,12-15  Direction for Bit8-11 (usually 0)
</PRE></TD></TR></TBODY></TABLE><BR><B>Serial 
Transfer Flowchart</B><BR>Chipselect and Command/Parameter Sequence:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Init CS=LOW and /SCK=HIGH, and wait at least 1us
  Switch CS=HIGH, and wait at least 1us
  Send the Command byte (see bit-transfer below)
  Send/receive Parameter byte(s) associated with the command (see below)
  Switch CS to LOW
</PRE></TD></TR></TBODY></TABLE>Bit 
transfer (repeat 8 times per cmd/param byte) (bits transferred LSB first):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Output /SCK=LOW and SIO=databit (when writing), then wait at least 5us
  Output /SCK=HIGH, wait at least 5us, then read SIO=databit (when reading)
</PRE></TD></TR></TBODY></TABLE>In 
this document &lt;both&gt; commands and parameters are specified in LSB-first
 transmission bit-order (unlike the original Seiko document which used mixed
 LSB-first and MSB-first conventions).<BR><BR><B>Command Register</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Command Register
    Fwd  Rev
    0-3  7-4 Fixed Code (must be 06h = 0110b) (same for Fwd and Rev)
    4-6  3-1 Command
             Fwd Rev Parameter bytes (read/write access)
             0   0   1 byte, status register 1
             4   1   1 byte, status register 2
             2   2   7 bytes, date &amp; time (year,month,day,day_of_week,hour,minute, second)
             6   3   3 bytes, time (hour,minute,second)
             1*  4*  1 byte, int1, frequency duty setting
             1*  4*  3 bytes, int1, alarm time 1 (day_of_week, hour, minute)
             5   5   3 bytes, int2, alarm time 2 (day_of_week, hour, minute)
             3   6   1 byte, clock adjustment register
             7   7   1 byte, free register
    7    0   Parameter Read/Write Access (0=Write, 1=Read)
</PRE></TD></TR></TBODY></TABLE>* 
INT1: Type and number of parameters depend on INT1 setting in stat reg2.<BR>The 
"Fwd" bit numbers and command values for LSB-first command transfers (ie. both 
commands and parameters use the same bit-order).<BR>The "Rev" numbers/values are 
for MSB-first command transfers (ie. commands using opposite bit-order than 
parameters, as being suggested by Seiko).<BR><BR><B>Control and Status 
Registers</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Status Register 1
    0   W   Reset                (0=Normal, 1=Reset)
    1   R/W 12/24 hour mode      (0=12 hour, 1=24 hour)
    2-3 R/W General purpose bits
    4   R   Interrupt 1 Flag (1=Yes)                      ;auto-cleared on read
    5   R   Interrupt 2 Flag (1=Yes)                      ;auto-cleared on read
    6   R   Power Low Flag (0=Normal, 1=Power is/was low) ;auto-cleared on read
    7   R   Power Off Flag (0=Normal, 1=Power was off)    ;auto-cleared on read
    Power off indicates that the battery was removed or fully discharged,
    all registers are reset to 00h (or 01h), and must be re-initialized.
  Status Register 2
    0-3 R/W INT1 Mode/Enable
            0000b Disable
            0x01b Selected Frequency steady interrupt
            0x10b Per-minute edge interrupt
            0011b Per-minute steady interrupt 1 (duty 30.0 secomds)
            0100b Alarm 1 interrupt
            0111b Per-minute steady interrupt 2 (duty 0.0079 secomds)
            1xxxb 32kHz output
    4-5 R/W General purpose bits
    6   R/W INT2 Enable
            0b    Disable
            1b    Alarm 2 interrupt
    7   R/W Test Mode (0=Normal, 1=Test, don't use) (cleared on Reset)
  Clock Adjustment Register (to compensate oscillator inaccuracy)
    0-7 R/W Adjustment (00h=Normal, no adjustment)
  Free Register
    0-7 R/W General purpose bits
</PRE></TD></TR></TBODY></TABLE><BR><B>Date 
Registers</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Year Register
    0-7 R/W Year     (BCD 00h..99h = 2000..2099)
  Month Register
    0-4 R/W Month    (BCD 01h..12h = January..December)
    5-7 -   Not used (always zero)
  Day Register
    0-5 R/W Day      (BCD 01h..28h,29h,30h,31h, range depending on month/year)
    6-7 -   Not used (always zero)
  Day of Week Register (septenary counter)
    0-2 R/W Day of Week (00h..06h, custom assignment, usually 0=Monday?)
    3-7 -   Not used (always zero)
</PRE></TD></TR></TBODY></TABLE><BR><B>Time 
Registers</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Hour Register
    0-5 R/W Hour     (BCD 00h..23h in 24h mode, or 00h..11h in 12h mode)
    6   *   AM/PM    (0=AM before noon, 1=PM after noon)
            * 24h mode: AM/PM flag is read only (PM=1 if hour = 12h..23h)
            * 12h mode: AM/PM flag is read/write-able
            * 12h mode: Observe that 12 o'clock is defined as 00h (not 12h)
    7   -   Not used (always zero)
  Minute Register
    0-6 R/W Minute   (BCD 00h..59h)
    7   -   Not used (always zero)
  Second Register
    0-6 R/W Minute   (BCD 00h..59h)
    7   -   Not used (always zero)
</PRE></TD></TR></TBODY></TABLE><BR><B>Alarm 
1 and Alarm 2 Registers</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Alarm1 and Alarm2 Day of Week Registers (INT1 and INT2 each)
    0-2 R/W Day of Week (00h..06h)
    3-6 -   Not used (always zero)
    7   R/W Compare Enable (0=Alarm every day, 1=Alarm only at specified day)
  Alarm1 and Alarm2 Hour Registers (INT1 and INT2 each)
    0-5 R/W Hour     (BCD 00h..23h in 24h mode, or 00h..11h in 12h mode)
    6   R/W AM/PM    (0=AM, 1=PM) (must be correct even in 24h mode?)
    7   R/W Compare Enable (0=Alarm every hour, 1=Alarm only at specified hour)
  Alarm1 and Alarm2 Minute Registers (INT1 and INT2 each)
    0-6 R/W Minute   (BCD 00h..59h)
    7   R/W Compare Enable (0=Alarm every min, 1=Alarm only at specified min)
  Selected Frequency Steady Interrupt Register (INT1 only) (when Stat2/Bit2=0)
    0   R/W Enable 1Hz Frequency  (0=Disable, 1=Enable)
    1   R/W Enable 2Hz Frequency  (0=Disable, 1=Enable)
    2   R/W Enable 4Hz Frequency  (0=Disable, 1=Enable)
    3   R/W Enable 8Hz Frequency  (0=Disable, 1=Enable)
    4   R/W Enable 16Hz Frequency (0=Disable, 1=Enable)
            The signals are ANDed when two or more frequencies are enabled,
            ie. the /INT signal gets LOW when either of the signals is LOW.
    5-7 R/W General purpose bits
</PRE></TD></TR></TBODY></TABLE>Note: 
There is only one register shared as "Selected Frequency Steady Interrupt" 
(accessed as single byte parameter when Stat2/Bit2=0) and as "Alarm1 Minute" 
(accessed as 3rd byte of 3-byte parameter when Stat2/Bit2=1), changing either 
value will also change the other value.<BR><BR><B>Interrupt</B><BR>There's only 
one /INT signal, shared for both INT1 and INT2.<BR>In the NDS, it is connected 
to the SI-input of the SIO unit (and so, also shared with SIO interrupts). To 
enable the interrupt, RCNT should be set to 8144h (Bit14-15=General Purpose 
mode, Bit8=SI Interrupt Enable, Bit6,2=SI Output/High).<BR>Not sure why 
Output/High... maybe as pullup... however, it seems to be working also as 
Input... ie. RCNT=8100h.<BR><BR><B>Pin-Outs</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  1 /INT      8 VDD
  2 XOUT      7 SIO
  3 XIN       6 /SCK
  4 GND       5 CS
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsserialperipheralinterfacebusspi"></A><FONT 
      size="+2">&nbsp;DS Serial Peripheral Interface Bus 
  (SPI)</FONT></TD></TR></TBODY></TABLE><BR><B>Serial Peripheral Interface 
Bus</B><BR>SPI Bus is a 4-wire (Data In, Data Out, Clock, and Chipselect) serial 
bus.<BR>The NDS supports the following SPI devices (each with its own 
chipselect).<BR><A href="#dsfirmwareserialflashmemory">DS 
Firmware Serial Flash Memory</A><BR><A href="#dstouchscreencontrollertsc">DS 
Touch Screen Controller (TSC)</A><BR><A href="#dspowermanagement">DS 
Power Management</A><BR><BR><B>40001C0h - SPICNT - NDS7 - SPI Bus Control/Status 
Register</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-1 Baudrate   (0=4MHz/Firmware, 1=2MHz/Touchscr, 2=1MHz/Powerman., 3=512KHz)
  2-6 Not used            (Zero)
  7   Busy Flag           (0=Ready, 1=Busy) (presumably Read-only)
  8-9 Device Select       (0=Powerman., 1=Firmware, 2=Touchscr, 3=Reserved)
  10  Transfer Size       (0=8bit, 1=16bit)
  11  Chipselect Hold     (0=Deselect after transfer, 1=Keep selected)
  12  Unknown (usually 0) (set equal to Bit11 when BIOS accesses firmware)
  13  Unknown (usually 0) (set to 1 when BIOS accesses firmware)
  14  Interrupt Request   (0=Disable, 1=Enable)
  15  SPI Bus Enable      (0=Disable, 1=Enable)
</PRE></TD></TR></TBODY></TABLE>The 
"Hold" flag should be cleared BEFORE transferring the LAST data unit, the
 chipselect will be then automatically cleared after the transfer, the program
 should issue a WaitByLoop(3) manually AFTER the LAST 
transfer.<BR><BR><B>40001C2h - SPIDATA - NDS7 - SPI Bus Data/Strobe Register 
(R/W)</B><BR>The SPI transfer is started on writing to this register, so one 
must &lt;write&gt; a dummy value (should be zero) even when intending to 
&lt;read&gt; from SPI bus.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-7  Data
  8-15 Used only in 16bit mode, then containing first-or-second-8bits?
</PRE></TD></TR></TBODY></TABLE>During 
transfer, the Busy flag in SPICNT is set, and the written SPIDATA value is 
transferred to the device (via output line), simultaneously data is received 
(via input line). Upon transfer completion, the Busy flag goes off (with 
optional IRQ), and the received value can be then read from SPIDATA, if
 desired.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dstouchscreencontrollertsc"></A><FONT size="+2">&nbsp;DS 
      Touch Screen Controller (TSC)</FONT></TD></TR></TBODY></TABLE><BR><B>Texas 
Instruments TSC2046</B><BR>The Touch Screen Controller is accessed via SPI 
bus,<BR><A href="#dsserialperipheralinterfacebusspi">DS 
Serial Peripheral Interface Bus (SPI)</A><BR><BR>The lower LCD screen can be 
used as Touch Panel.<BR><BR>Control Byte (transferred MSB first)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-1  Power Down Mode Select
  2    Reference Select (0=Differential, 1=Single-Ended)
  3    Conversion Mode  (0=12bit, max CLK=2MHz, 1=8bit, max CLK=3MHz)
  4-6  Channel Select   (0-7, see below)
  7    Start Bit (Must be set to access Control Byte)
</PRE></TD></TR></TBODY></TABLE><BR>
Channel<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0 Temperature 0 (requires calibration, step 2.1mV per 1'C accuracy)
  1 Touchscreen Y-Position  (somewhat 0B0h..F20h, or FFFh=released)
  2 Battery Voltage         (not used, connected to GND in NDS, always 000h)
  3 Touchscreen Z1-Position (diagonal position for pressure measurement)
  4 Touchscreen Z2-Position (diagonal position for pressure measurement)
  5 Touchscreen X-Position  (somewhat 100h..ED0h, or 000h=released)
  6 AUX Input               (connected to Microphone in the NDS)
  7 Temperature 1 (difference to Temp 0, without calibration, 2'C accuracy)
</PRE></TD></TR></TBODY></TABLE>All 
channels can be accessed in Single-Ended mode.<BR>In differential mode, only 
channel 1,3,4,5 (X,Z1,Z2,Y) can be accessed.<BR><BR><B>Power Down Mode</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Mode /PENIRQ   VREF  ADC   Recommended use
  0    Enabled   Auto  Auto  Differential Mode (Touchscreen, Penirq)
  1    Disabled  Off   On    Single-Ended Mode (Temperature, Microphone)
  2    Enabled   On    Off   Don't use
  3    Disabled  On    On    Don't use
</PRE></TD></TR></TBODY></TABLE>Allows 
to enable/disable the /PENIRQ output, the internal reference voltage (VREF), and 
the Analogue-Digital Converter.<BR><BR><B>Reference Voltage (VREF)</B><BR>VREF 
is used as reference voltage in single ended mode, at 12bit resolution one ADC 
step equals to VREF/4096. The TSC generates an internal VREF of 2.5V (+/-0.05V), 
however, the NDS uses as external VREF of 3.33V (sinks to 3.31V at low battery 
charge), the external VREF is always enabled, no matter if internal VREF is on 
or off. Power Down Mode 1 disables the internal VREF, which may reduce power 
consumption in single ended mode. After conversion, Power Down Mode 0 should be 
restored to re-enable the Penirq signal.<BR><BR><B>Sending the first Command 
after Chip-Select</B><BR>Switch chipselect low, then output the command byte 
(MSB first).<BR><BR><B>Reply Data</B><BR>The following reply data is received 
(via Input line) after the Command byte has been transferred: One dummy bit 
(zero), followed by the 8bit or 12bit conversion result (MSB first), followed by 
endless padding (zero).<BR>Note: The returned ADC value may become unreliable if 
there are longer delays between sending the command, and receiving the reply 
byte(s).<BR><BR><B>Sending further Commands during/after receiving Reply 
Data</B><BR>In general, the Output line should be LOW during the reply period, 
however, once when Data bit6 has been received (or anytime later), a new Command 
can be invoked (started by sending the HIGH-startbit, ie. Command bit7),
 simultanously, the remaining reply-data bits (bit5..0) can be received.<BR>In 
other words, the new command can be output after receiving 3 bits in 8bit mode 
(the dummy bit, and data bits 7..6), or after receiving 7 bits in 12bit mode 
(the dummy bit, and data bits 11..6).<BR>In practice, the NDS SPI register 
always transfers 8 bits at once, so that one would usually receive 8 bits 
(rather than above 3 or 7 bits), before outputting a new 
command.<BR><BR><B>Touchscreen Position</B><BR>Read the X and Y positions in 
12bit differential mode, then convert the touchscreen values (adc) to 
screen/pixel positions (scr), as such:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  scr.x = (adc.x-adc.x1) * (scr.x2-scr.x1) / (adc.x2-adc.x1) + (scr.x1-1)
  scr.y = (adc.y-adc.y1) * (scr.y2-scr.y1) / (adc.y2-adc.y1) + (scr.y1-1)
</PRE></TD></TR></TBODY></TABLE>The 
X1,Y1 and X2,Y2 calibration points are found in Firmware User Settings,<BR><A 
href="#dsfirmwareusersettings">DS 
Firmware User Settings</A><BR>scr.x1,y1,x2,y2 are originated at 1,1 (converted 
to 0,0 by above formula).<BR><BR><B>Touchscreen Pressure</B><BR>To calculate the 
pressure resistance, in respect to X/Y/Z positions and X/Y plate resistances, 
either of below formulas can be used,<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Rtouch = (Rx_plate*Xpos*(Z2pos/Z1pos-1))/4096
  Rtouch = (Rx_plate*Xpos*(4096/Z1pos-1)-Ry_plate*(1-Ypos))/4096
</PRE></TD></TR></TBODY></TABLE>The 
second formula requires less CPU load (as it doesn't require to measure Z2), the 
downside is that one must know both X and Y plate resistance (or at least their 
ratio). The first formula doesn't require that ratio, and so Rx_plate can be set 
to any value, setting it to 4096 results in<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  touchval = Xpos*(Z2pos/Z1pos-1)
</PRE></TD></TR></TBODY></TABLE>Of 
course, in that case, touchval is just a number, not a resistance in 
Ohms.<BR><BR><B>Touchscreen Notes</B><BR>It may be impossible to press locations 
close to the screen borders.<BR>When pressing two or more locations the TSC 
values will be somewhere in the middle of these locations.<BR>The TSC values may 
be garbage if the screen becomes newly pressed or released, to avoid invalid 
inputs: read TSC values at least two times, and ignore BOTH positions if ONE 
position was invalid.<BR><BR><B>Microphone / AUX Channel</B><BR>Observe that the 
microphone amplifier is switched off after power up, see:<BR><A href="#dspowermanagement">DS 
Power Management</A><BR><BR><B>Temperature Calculation</B><BR>TP0 decreases by 
circa 2.1mV per degree Kelvin. The voltage difference between TP1 minus TP0 
increases by circa 0.39mV (1/2573 V) per degree Kelvin. At VREF=3.33V, one 12bit 
ADC step equals to circa 0.8mV (VREF/4096).<BR>Temperature can be calculated at 
best resolution when using the current TP0 value, and two calibration values (an 
ADC value, and the corresponding temperature in degrees kelvin):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  K = (CAL.TP0-ADC.TP0) * 0.4 + CAL.KELVIN
</PRE></TD></TR></TBODY></TABLE>Alternately, 
temperature can be calculated at rather bad resolution, but without calibration, 
by using the difference between TP1 and TP0:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  K = (ADC.TP1-ADC.TP0) * 8568 / 4096
</PRE></TD></TR></TBODY></TABLE>To 
convert Kelvin to other formats,<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Celsius:     C = (K-273.15)
  Fahrenheit:  F = (K-273.15)*9/5+32
  Reaumur:     R = (K-273.15)*4/5
  Rankine:     X = (K)*9/5
</PRE></TD></TR></TBODY></TABLE>The 
Temperature Range for the TSC chip is -40'C .. +85'C. According to Nintendo, the 
DS should not be exposed to "extreme" heat or cold, the optimal battery charging 
temperature is specified as +10'C..+40'C.<BR>The original firmware does not 
support temperature calibration, calibration is supported by nocash firmware (if 
present). See Extended Settings,<BR><A href="#dsfirmwareextendedsettings">DS 
Firmware Extended Settings</A><BR><BR><B>Pin-Outs</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>         ________
  VCC  1|o       |16 DCLK
  X+   2|        |15 /CS
  Y+   3|  TSC   |14 DIN
  X-   4|  2046  |13 BUSY
  Y-   5|        |12 DOUT
  GND  6|        |11 /PENIRQ
  VBAT 7|        |10 IOVDD
  AUX  8|________|9  VREF
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dspowermanagement"></A><FONT size="+2">&nbsp;DS Power 
      Management</FONT></TD></TR></TBODY></TABLE><BR>The DS contains several Power 
Managment functions, some accessed via I/O ports, some accessed via SPI bus 
(described later on below).<BR><BR><B>4000304h - POWCNT1 - NDS9 - Graphics Power 
Control Register (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0     Enable Flag for both LCDs (0=Disable) (Prohibited, see notes)
  1     2D Graphics Engine A      (0=Disable) (Ports 008h-05Fh, Pal 5000000h)
  2     3D Rendering Engine       (0=Disable) (Ports 320h-3FFh)
  3     3D Geometry Engine        (0=Disable) (Ports 400h-6FFh)
  4-8   Not used
  9     2D Graphics Engine B      (0=Disable) (Ports 1008h-105Fh, Pal 5000400h)
  10-14 Not used
  15    Display Swap (0=Send Display A to Lower Screen, 1=To Upper Screen)
</PRE></TD></TR></TBODY></TABLE>Use 
SwapBuffers command once after enabling Rendering/Geometry Engine.<BR>Improper 
use of Bit0 may damage the hardware?<BR>When disabled, corresponding Ports 
become Read-only, corresponding (palette-) memory becomes 
read-only-zero-filled.<BR><BR><B>4000304h - POWCNT2 - NDS7 - Sound/Wifi Power 
Control Register (R/W)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Sound Speakers (0=Disable, 1=Enable)
  1     Wifi           (0=Disable, 1=Enable)
  2-15  Not used
</PRE></TD></TR></TBODY></TABLE>Note: 
Bit0 disables the internal Speaker only, headphones are not 
disabled.<BR><BR><B>4000206h - NDS7 - Unknown</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-15  Unknown (set to 0030h) somehow WLAN/POWCNT related?
</PRE></TD></TR></TBODY></TABLE><BR><B>4000301h 
- NDS7 - HALTCNT - Low Power Mode Control (R/W)</B><BR>In Halt mode, the CPU is 
paused as long as (IE AND IF)=0.<BR>In Sleep mode, most of the hardware 
including sound and video are paused, this very-low-power mode could be used 
much like a screensaver.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-5   Not used (zero)
  6-7   Power Down Mode  (0=No function, 1=Enter GBA Mode, 2=Halt, 3=Sleep)
</PRE></TD></TR></TBODY></TABLE>The 
HALTCNT register should not be accessed directly. Instead, the BIOS Halt, Sleep, 
CustomHalt, IntrWait, or VBlankIntrWait SWI functions should be used.<BR><A 
href="#bioshaltfunctions">BIOS Halt 
Functions</A><BR><A href="#armcp15systemcontrolcoprocessor">ARM 
CP15 System Control Coprocessor</A><BR>The NDS9 does not have a HALTCNT 
register, instead, the Halt function uses the co-processor opcode "mcr 
p15,0,r0,c7,c0,4" - this opcode locks up if interrupts are disabled via IME=0 
(unlike NDS7 HALTCNT method which doesn't check IME).<BR><BR><B>4000300h - 
NDS7/NDS9 - POSTFLG - BYTE - Post Boot Flag (R/W)</B><BR>The NDS7 and NDS9 post 
boot flags are usually set upon BIOS/Firmware boot completion, once when set the 
reset vector is redirected to the debug handler of Nintendo's hardware debugger. 
That allows the NDS7 debugger to capture accidental jumps to address 0, that 
appears to be a common problem with HLL-programmers, asm-coders know that (and 
why) they should not jump to 0.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0     Post Boot Flag (0=Boot in progress, 1=Boot completed)
  1     NDS7: Not used (always zero), NDS9: Bit1 is read-writeable
  2-7   Not used (always zero)
</PRE></TD></TR></TBODY></TABLE>There 
are some write-restrictions: The NDS7 register can be written to only from code 
executed in BIOS. Bit0 of both NDS7 and NDS9 registers cannot be cleared (except 
by Reset) once when it is set.<BR><BR><B>Power Management Device</B><BR>The 
Power Management Device is accessed via SPI bus,<BR><A href="#dsserialperipheralinterfacebusspi">DS 
Serial Peripheral Interface Bus (SPI)</A><BR>To access the device, write the 
Index Register, then read or write the data register, and release the chipselect 
line when finished.<BR><BR>Index Register<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-1 Register Select          (0..3)
  Bit2-6 Not used
  Bit7   Register Direction       (0=Write, 1=Read)
</PRE></TD></TR></TBODY></TABLE>Register 
0 - Powermanagement Control (R/W)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0   Sound Amplifier          (0=Disable, 1=Enable)
         (When disabled, sound becomes very silent, but it is still audible)
  Bit1   Sound related?           (0=Disable, 1=Enable)
  Bit2   Lower Backlight          (0=Disable, 1=Enable)
  Bit3   Upper Backlight          (0=Disable, 1=Enable)
  Bit4   Power LED Blink Enable   (0=Always ON, 1=Blinking OFF/ON)
  Bit5   Power LED Blink Speed    (0=Slow, 1=Fast) (only if Blink enabled)
  Bit6   DS System Power          (0=Normal, 1=Shut Down)
  Bit7   Not used
</PRE></TD></TR></TBODY></TABLE>Register 
1 - Battery Status (R)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0   Battery Power LED Status (0=Power Good/Green, 1=Power Low/Red)
  Bit1-7 Not used
</PRE></TD></TR></TBODY></TABLE>Register 
2 - Microphone Amplifier Control (R/W)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0   Amplifier                (0=Disable, 1=Enable)
  Bit1-7 Not used
</PRE></TD></TR></TBODY></TABLE>Register 
3 - Microphone Amplifier Gain Control (R/W)<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit0-1 Gain                     (0..3=Gain 20, 40, 80, 160)
  Bit2-7 Not used
</PRE></TD></TR></TBODY></TABLE><BR><B>Backlight 
Dimming / Backlight caused Shut-Down(s)</B><BR>The above bits are essentially 
used to switch Backlights on or off. However, there a number of strange effects. 
Backlight dimming is possible by pulse width modulation, ie. by using a timer 
interrupt to issue pulse widths of N% ON, and 100-N% OFF. Too long pulses are 
certainly resulting in flickering. Too short pulses are ignored, the backlights 
will remain OFF, even if the ON and OFF pulses are having the same length. Much 
too short pulses cause the power supply to shut-down; after changing the 
backlight state, further changes must not occur within the next (circa) 2500 
clock cycles. The mainboard can be operated without screens &amp; backlights 
connected, however, if so, the power supply will shut-down as soon as backlights 
are enabled.<BR><BR><B>Memory Power Down Functions</B><BR><A href="#dsmainmemorycontrol">DS 
Main Memory Control</A><BR><A href="#dsfirmwareserialflashmemory">DS 
Firmware Serial Flash Memory</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsmainmemorycontrol"></A><FONT size="+2">&nbsp;DS Main Memory 
      Control</FONT></TD></TR></TBODY></TABLE><BR><B>Main Memory</B><BR>The DS Main 
Memory is 2Mx16bit (4MByte), 1.8V Pseudo SRAM (PSRAM); all Dynamic RAM refresh 
is handled internally, the chip doesn't require any external refresh signals, 
and alltogether behaves like Static RAM. Non-sequential access time is 70ns, 
sequential (burst) access time is 12ns.<BR><BR><B>Main Memory Control</B><BR>The 
memory chips contain built-in Control functions, which can be accessed via Port 
27FFFFEh and/or by EXMEMCNT Bit 14. Nintendo is using at least two different 
types of memory chips in DS consoles, Fujitsu 82DBS02163C-70L, and ST 
M69AB048BL70ZA8, both appear to have different control mechanisms, other chips 
(with 8MB size) are used in the semi-professional DS hardware debuggers, and 
further chips may be used in future, so using the memory control functions may 
lead into compatibitly problems.<BR><BR><B>Power Consumption / Power 
Control</B><BR>Power Consumption during operation (read/write access) is 
somewhat 30mA, in standby mode (no read/write access) consumption is reduced to 
100uA.<BR>Furthermore, a number of power-down modes are supported: In "Deep" 
Power Down mode the refresh is fully disabled, consumption is 10uA (and all data 
will be lost), in "Partial" Power Down modes only fragment of memory is 
refreshed, for smallest fragments, consumption goes to down to circa 50uA. The 
chip cannot be accessed while it is in Deep or Partial Power Down 
mode.<BR><BR><B>Fujitsu 82DBS02163C-70L</B><BR>The Configuration Register (CR) 
can be written to by the following sequence:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  LDRH R0,[27FFFFEh]      ;read one value
  STRH R0,[27FFFFEh]      ;write should be same value as above
  STRH R0,[27FFFFEh]      ;write should be same value as above
  STRH R0,[27FFFFEh]      ;write any value
  STRH R0,[27FFFFEh]      ;write any value
  LDRH R0,[2400000h+CR*2] ;read, address-bits are defining new CR value
</PRE></TD></TR></TBODY></TABLE>Do 
not access any other Main Memory addresses during above sequence (ie. disable 
interrupts, and do not execute the sequence by code located in Main Memory). The 
CR value is write-only. The CR bits are:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit    Expl.
  0-6    Reserved         (Must be 7Fh)
  7      Write Control
           0=WE Single Clock Pulse Control without Write Suspend Function
           1=WE Level Control with Write Suspend Function)
          Burst Read/Single Write is not supported at WE Single Clock Mode.
  8      Reserved         (Must be 1)
  9      Valid Clock Edge (0=Falling Edge, 1=Rising Edge)
  10     Single Write     (0=Burst Read/Burst Write, 1=Burst Read/Single Write)
  11     Burst Sequence   (0=Reserved, 1=Sequential)
  12-14  Read Latency     (1=3 clocks, 2=4 clocks, 3=5 clocks, other=Reserved)
  15     Mode
           0=Synchronous:  Burst Read, Burst Write
           1=Asynchronous: Page Read, Normal Write
          In Mode 1 (Async), only the Partial Size bits are used,
          all other bits, CR bits 0..18, must be "1".
  16-18  Burst Length     (2=8 Words, 3=16Words, 7=Continous, other=Reserved)
  19-20  Partial Size     (0=1MB, 1=512KB, 2=Reserved, 3=Deep/0 bytes)
</PRE></TD></TR></TBODY></TABLE>The 
Power Down mode is entered by setting CE2=LOW, this can be probably done by 
setting EXMEMCNT Bit14 to zero.<BR><BR><B>ST Microelectronics 
M69AB048BL70ZA8</B><BR>The chip name decodes as PSRAM (M96), Asynchronous (A), 
1.8V Burst (B), 2Mx16 (048), Two Chip Enables (B), Low Leakage (L), 70ns (70), 
Package (ZA), -30..+85'C (8).<BR>There are three data sheets for different PSRAM 
chips available at <A title="Linkification: http://www.st.com" class="linkification-ext" 
href="http://www.st.com/">http://www.st.com/</A> (unfortunately none for 
M69AB048BL70ZA8), each using different memory control mechanisms.<BR><BR><B>NDS9 
BIOS</B><BR>The NDS9 BIOS contains the following Main Memory initialization 
code, that method doesn't match up with any ST (nor Fujitsu) data sheets that 
I've seen. At its best, it looks like a strange (and presumably non-functional) 
mix-up of different ST control methods.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  STRH 2000h,[4000204h]
  LDRH R0,[27FFFFEh]
  STRH R0,[27FFFFEh]
  STRH R0,[27FFFFEh]
  STRH FFDFh,[27FFFFEh]
  STRH E732h,[27FFFFEh]
  LDRH R0,[27E57FEh]
  STRH 6000h,[4000204h]
</PRE></TD></TR></TBODY></TABLE>In 
the above BIOS code, EXMEMCNT.14 appears to be used to unlock the control
 register. However, the NDS Firmware appears to use EXMEMCNT.14 to switch Main
 Memory into Power Down mode before entering GBA mode.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dscartridgesencryptionfirmware"></A><FONT size="+2">&nbsp;DS 
      Cartridges, Encryption, 
Firmware</FONT></TD></TR></TBODY></TABLE><BR><B>Cartridges</B><BR><A href="#dscartridgeheader">DS 
Cartridge Header</A><BR><A href="#dscartridgesecurearea">DS 
Cartridge Secure Area</A><BR><A href="#dscartridgeicontitle">DS 
Cartridge Icon/Title</A><BR><A href="#dscartridgeprotocol">DS 
Cartridge Protocol</A><BR><A href="#dscartridgeioports">DS 
Cartridge I/O Ports</A><BR><A href="#dscartridgenitroromfilesystem">DS 
Cartridge NitroROM File System</A><BR><A href="#dscartridgepassmepassthrough">DS 
Cartridge PassMe/PassThrough</A><BR><BR><B>Encryption</B><BR><A href="#dsencryptionbygamecodeidcodekey1">DS 
Encryption by Gamecode/Idcode (KEY1)</A><BR><A href="#dsencryptionbyrandomseedkey2">DS 
Encryption by Random Seed (KEY2)</A><BR><BR><B>Firmware</B><BR><A href="#dsfirmwareserialflashmemory">DS 
Firmware Serial Flash Memory</A><BR><A href="#dsfirmwareheader">DS 
Firmware Header</A><BR><A href="#dsfirmwareusersettings">DS 
Firmware User Settings</A><BR><A href="#dsfirmwareextendedsettings">DS 
Firmware Extended Settings</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dscartridgeheader"></A><FONT size="+2">&nbsp;DS Cartridge 
      Header</FONT></TD></TR></TBODY></TABLE><BR><B>Header Overview (loaded from ROM 
Addr 0 to Main RAM 27FFE00h on Power-up)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Address Bytes Expl.
  000h    12    Game Title  (Uppercase ASCII, padded with 00h)
  00Ch    4     Gamecode    (Uppercase ASCII, NTR-&lt;code&gt;)        (0=homebrew)
  010h    2     Makercode   (Uppercase ASCII, eg. "01"=Nintendo) (0=homebrew)
  012h    1     Unitcode    (00h=Nintendo DS)
  013h    1     Encryption Seed Select (00..07h, usually 00h)
  014h    1     Devicecapacity         (Chipsize = 128KB SHL nn) (eg. 7 = 16MB)
  015h    9     Reserved           (zero filled)
  01Eh    1     ROM Version        (usually 00h)
  01Fh    1     Autostart (Bit2: Skip "Press Button" after Health and Safety)
                (Also skips bootmenu, even in Manual mode &amp; even Start pressed)
  020h    4     ARM9 rom_offset    (4000h and up, align 1000h)
  024h    4     ARM9 entry_address (2000000h..23BFE00h)
  028h    4     ARM9 ram_address   (2000000h..23BFE00h)
  02Ch    4     ARM9 size          (max 3BFE00h) (3839.5KB)
  030h    4     ARM7 rom_offset    (8000h and up)
  034h    4     ARM7 entry_address (2000000h..23BFE00h, or 37F8000h..3807E00h)
  038h    4     ARM7 ram_address   (2000000h..23BFE00h, or 37F8000h..3807E00h)
  03Ch    4     ARM7 size          (max 3BFE00h, or FE00h) (3839.5KB, 63.5KB)
  040h    4     File Name Table (FNT) offset
  044h    4     File Name Table (FNT) size
  048h    4     File Allocation Table (FAT) offset
  04Ch    4     File Allocation Table (FAT) size
  050h    4     File ARM9 overlay_offset
  054h    4     File ARM9 overlay_size
  058h    4     File ARM7 overlay_offset
  05Ch    4     File ARM7 overlay_size
  060h    4     Port 40001A4h setting for normal commands (usually 00586000h)
  064h    4     Port 40001A4h setting for KEY1 commands   (usually 001808F8h)
  068h    4     Icon_title_offset (0=None) (8000h and up)
  06Ch    2     Secure Area Checksum, CRC-16 of [ [20h]..7FFFh]
  06Eh    2     Secure Area Loading Timeout (usually 051Eh)
  070h    4     ARM9 Auto Load List RAM Address (?)
  074h    4     ARM7 Auto Load List RAM Address (?)
  078h    8     Secure Area Disable (by encrypted "NmMdOnly") (usually zero)
  080h    4     Total Used ROM size (remaining/unused bytes usually FFh-padded)
  084h    4     ROM Header Size (4000h)
  088h    38h   Reserved (zero filled)
  0C0h    9Ch   Nintendo Logo (compressed bitmap, same as in GBA Headers)
  15Ch    2     Nintendo Logo Checksum, CRC-16 of [0C0h-15Bh], fixed CF56h
  15Eh    2     Header Checksum, CRC-16 of [000h-15Dh]
  160h    4     Debug rom_offset   (0=none) (8000h and up)       ;only if debug
  164h    4     Debug size         (0=none) (max 3BFE00h)        ;version with
  168h    4     Debug ram_address  (0=none) (2400000h..27BFE00h) ;SIO and 8MB
  16Ch    4     Reserved (zero filled) (transferred, and stored, but not used)
  170h    90h   Reserved (zero filled) (transferred, but not stored in RAM)
</PRE></TD></TR></TBODY></TABLE><BR>
For more info about CRC-16, see description of GetCRC16 BIOS function,<BR><A 
href="#biosmiscfunctions">BIOS Misc 
Functions</A><BR>For the Logo checksum, the BIOS verifies only [15Ch]=CF56h, it 
does NOT verify the actual data at [0C0h-15Bh] (nor it's checksum), however, the 
data is verified by the firmware.<BR><BR>Secure Area Loading Timeout (usually 
X=051Eh) used to initialize timer counter to (0-((X AND 3FFFh)+2)). (In case of 
Header checksum error it is ANDed with 1FFFh instead of 3FFFh, no idea 
why).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dscartridgesecurearea"></A><FONT size="+2">&nbsp;DS Cartridge 
      Secure Area</FONT></TD></TR></TBODY></TABLE><BR>The Secure Area is located in 
ROM at 4000h..7FFFh, it can contain normal program code and data, however, it 
can be used only for ARM9 boot code, it cannot be used for ARM7 boot code, 
icon/title, filesystem, or other data.<BR><BR><B>Secure Area Size</B><BR>The 
Secure Area exists if the ARM9 boot code ROM source address (src) is located 
within 4000h..7FFFh, if so, it will be loaded (by BIOS via KEY1 encrypted 
commands) in 4K portions, starting at src, aligned by 1000h, up to address 
7FFFh. The secure area size if thus 8000h-src, regardless of the ARM9 boot code 
size entry in header.<BR><BR><B>Secure Area ID</B><BR>The first 8 bytes of the 
secure area are containing the Secure Area ID, the ID is required (verified by 
BIOS boot code), the ID value changes during boot process:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Value                Expl.
  "encryObj"           raw ID before encryption (raw ROM-image)
  (encrypted)          encrypted ID after encryption (encrypted ROM-image)
  "encryObj"           raw ID after decryption (verified by BIOS boot code)
  E7FFDEFFh,E7FFDEFFh  destroyed ID (overwritten by BIOS after verify)
</PRE></TD></TR></TBODY></TABLE><BR><B>Secure 
Area First 2K Encryption</B><BR>The first 2K of the Secure Area (if it exists) 
are KEY1 encrypted. In Nintendo's cartridges, the first 2K of the secure area 
are containing only a few SWI calls, and the rest of it appears to be filled 
with random values (presumably for confusion purposes). Anyways, that 
confusion/random values aren't required, the first 2K may contain normal program 
code and data.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dscartridgeicontitle"></A><FONT size="+2">&nbsp;DS Cartridge 
      Icon/Title</FONT></TD></TR></TBODY></TABLE><BR>The ROM offset of the Icon/Title 
is defined in Cartridge Header [68h].<BR>If it is present (nonzero), then 
Icon/Title are displayed in the bootmenu.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Addr  Siz  Expl.
  000h  2    Version  (0001h)
  002h  2    CRC16 across entries 020h..83Fh
  004h  1Ch  Reserved (zero-filled)
  020h  200h Icon Bitmap  (32x32 pix) (4x4 tiles, each 4x8 bytes, 4bit depth)
  220h  20h  Icon Palette (16 colors, 16bit, range 0000h-7FFFh)
             (Color 0 is transparent, so the 1st palette entry is ignored)
  240h  100h Title 0 Japanese (128 characters, 16bit Unicode)
  340h  100h Title 1 English  ("")
  440h  100h Title 2 French   ("")
  540h  100h Title 3 German   ("")
  640h  100h Title 4 Italian  ("")
  740h  100h Title 5 Spanish  ("")
  840h  -    End of Icon/Title structure (next 1C0h bytes usually FFh-filled)
</PRE></TD></TR></TBODY></TABLE>Usually, 
for non-multilanguage games, the same (english) title is stored in all title 
entries. The title may consist of ASCII characters 0020h-007Fh, character 000Ah 
(linefeed), and should be terminated/padded by 0000h. The whole text should not 
exceed the dimensions of the DS cart field in the bootmenu. The title is usually 
split into a primary title, optional sub-title, and manufacturer, each separated 
by 000Ah character(s). For example, "America",000Ah,"The Axis of 
War",000Ah,"Cynicware",0000h<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dscartridgeprotocol"></A><FONT size="+2">&nbsp;DS Cartridge 
      Protocol</FONT></TD></TR></TBODY></TABLE><BR>Communication with Cartridge ROM 
relies on sending 8 byte commands to the cartridge, after the sending the 
command, a data stream can be received from the cartridge (the length of the 
data stream isn't fixed, below descriptions show the default length in brackets, 
but one may receive more, or less bytes, if desired).<BR><BR><B>Cartridge Memory 
Map</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0000h-0FFFh Header (unencrypted)
  1000h-3FFFh Not read-able (zero filled in ROM-images)
  4000h-7FFFh Secure Area, 16KBytes (first 2Kbytes with extra encryption)
  8000h-...   Main Data Area
</PRE></TD></TR></TBODY></TABLE>Cartridge 
memory must be copied into Work RAM (the CPU cannot execute code in
 ROM).<BR><BR><B>Command Summary, Cmd/Reply-Encryption Type, Default 
Length</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Command/Params    Expl.                             Cmd  Reply Len
  -- Unencrypted Load --
  9F00000000000000h Dummy (read HIGH-Z bytes)         RAW  RAW   2000h
  0000000000000000h Get Cartridge Header              RAW  RAW   200h
  9000000000000000h 1st Get ROM Chip ID               RAW  RAW   4
  00aaaaaaaa000000h Unencrypted Data (debug ver only) RAW  RAW   200h
  3Ciiijjjxkkkkkxxh Activate KEY1 Encryption Mode     RAW  RAW   0
  -- Secure Area Load --
  4llllmmmnnnkkkkkh Activate KEY2 Encryption Mode     KEY1 FIX   910h+0
  1lllliiijjjkkkkkh 2nd Get ROM Chip ID               KEY1 KEY2  910h+4
  xxxxxxxxxxxxxxxxh Invalid - Get KEY2 Stream XOR 00h KEY1 KEY2  910h+...
  2bbbbiiijjjkkkkkh Get Secure Area Block (4Kbytes)   KEY1 KEY2  910h+11A8h
  6lllliiijjjkkkkkh Optional KEY2 Disable             KEY1 KEY2  910h+?
  Alllliiijjjkkkkkh Enter Main Data Mode              KEY1 KEY2  910h+0
  -- Main Data Load --
  B7aaaaaaaa000000h Encrypted Data Read               KEY2 KEY2  200h
  B800000000000000h 3rd Get ROM Chip ID               KEY2 KEY2  4
  xxxxxxxxxxxxxxxxh Invalid - Get KEY2 Stream XOR 00h KEY2 KEY2  ...
</PRE></TD></TR></TBODY></TABLE>The 
parameter digits contained in above commands are:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  aaaaaaaa     32bit ROM address (command B7 can access only 8000h and up)
  bbbb         Secure Area Block number (0004h..0007h for addr 4000h..7000h)
  x,xx         Random, not used in further commands
  iii,jjj,llll Random, must be SAME value in further commands
  kkkkk        Random, must be INCREMENTED after FURTHER commands
  mmm,nnn      Random, used as KEY2-encryption seed
</PRE></TD></TR></TBODY></TABLE><BR>
++++ Unencrypted Commands (First Part of Boot Procedure) 
++++<BR><BR><B>Cartridge Reset</B><BR>The /RES Pin switches the cartridge into 
unencrypted mode. After reset, the first two commands (9Fh and 00h) are 
transferred at 4MB/s CLK rate.<BR><BR><B>9F00000000000000h (2000h) - 
Dummy</B><BR>Dummy command send after reset, returns endless stream of HIGH-Z 
bytes (ie. usually receiving FFh, immediately after sending the command, the 
first 1-2 received bytes may be equal to the last command 
byte).<BR><BR><B>0000000000000000h (200h) - Get Header</B><BR>Returns RAW 
unencrypted cartridge header, repeated every 1000h bytes. The interesting area 
are the 1st 200h bytes, the rest is typically zero filled.<BR>The Gamecode 
header entry is used later on to initialize the encryption. Also, the ROM 
Control entries define the length of the KEY1 dummy periods (typically 910h 
clocks), and the CLK transfer rate for further commands (typically faster than 
the initial 4MB/s after power up).<BR><BR><B>9000000000000000h (4) - 1st Get ROM 
Chip ID</B><BR>Returns RAW unencrypted Chip ID (C2h,0Fh,00h,00h), repeated every 
4 bytes.<BR>The first byte identifies the manufacturer (C2h = Macronix).<BR>The 
MSB of the Chip ID (bit7 of the fourth byte) selects the Secure Area Block 
transfer mode (8x200h or 1000h).<BR><BR><B>3Ciiijjjxkkkkkxxh (0) - Activate KEY1 
Encryption Mode</B><BR>The 3Ch command returns endless stream of HIGH-Z bytes, 
all following commands, and their return values, are encrypted. The random 
parameters iii,jjj,kkkkk must be re-used in further commands; the 20bit kkkkk 
value is to be incremented by one after each &lt;further&gt; command (it is 
&lt;not&gt; incremented after the 3Ch command).<BR><BR>++++ KEY1 Encrypted 
Commands (2nd Part of Boot procedure) ++++<BR><BR><B>4llllmmmnnnkkkkkh (910h) - 
Activate KEY2 Encryption Mode</B><BR>KEY1 encrypted command, parameter mmmnnn is 
used to initialize the KEY2 encryption stream. Returns 910h dummy bytes (which 
are still subject to old KEY2 settings; at pre-initialization time, this is 
fixed: HIGH-Z, C5h, 3Ah, 81h, etc.). The new KEY2 seeds are then applied, and 
the first KEY2 byte is then precomputed. The 910h dummy stream is followed by 
that precomputed byte value endless repeated (this is the same value as that 
"underneath" of the first HIGH-Z dummy-byte of the next 
command).<BR><BR><B>1lllliiijjjkkkkkh (914h) - 2nd Get ROM Chip ID / Get KEY2 
Stream</B><BR>KEY1 encrypted command. Returns 910h dummy bytes, followed by KEY2 
encrypted Chip ID repeated every 4 bytes, which must be identical as for the 1st 
Get ID command. The BIOS randomly executes this command once or twice. Changing 
the first command byte to any other value returns an endless KEY2 encrypted
 stream of 00h bytes, that is the easiest way to retrieve encryption values and 
to bypass the copyprotection.<BR><BR><B>2bbbbiiijjjkkkkkh (19B8h) - Get Secure 
Area Block</B><BR>KEY1 encrypted command. Used to read a secure area block (bbbb 
in range 0004h..0007h for addr 4000h..7000h), each block is 4K, so it requires 
four Get Secure Area commands to receive the whole Secure Area (ROM locations
 4000h-7FFFh), the BIOS is reading these blocks in random order.<BR>Normally (if 
the upper bit of the Chip ID is set): Returns 910h dummy bytes, followed by 200h 
KEY2 encrypted Secure Area bytes, followed by 18h KEY2 encrypted 00h bytes, then 
the next 200h KEY2 encrypted Secure Area bytes, again followed by 18h KEY2 
encrypted 00h bytes, and so on. That stream is repeated every 10C0h bytes 
(8x200h data bytes, plus 8x18h zero bytes).<BR>Alternately (if the upper bit of 
the Chip ID is zero):  Returns 910h dummy bytes, followed by 1000h KEY2 
encrypted Secure Area bytes, presumably followed by 18h bytes, too.<BR>Aside 
from above KEY2 encryption (which is done by hardware), the first 2K of the 
Secure Area is additionally KEY1 encrypted (which must be resolved after
 transfer by software).<BR><BR><B>6lllliiijjjkkkkkh (0) - Optional KEY2 
Disable</B><BR>KEY1 encrypted command. Returns 910h dummy bytes (which are still 
KEY2 affected), followed by endless stream of RAW 00h bytes. KEY2 encryption is
 disabled for all following commands.<BR>This command is send only if 
firmware[18h] matches encrypted string "enPngOFF", and ONLY if firmware 
get_crypt_keys had completed BEFORE completion of secure area loading, this 
timing issue may cause unstable results.<BR><BR><B>Alllliiijjjkkkkkh (910h) - 
Enter Main Data Mode</B><BR>KEY1 encrypted command. Returns 910h dummy bytes, 
followed by endless KEY2 encrypted stream of 00h bytes. All following commands 
are KEY2 encrypted.<BR><BR>++++ KEY2 Encrypted Commands (Main Data Transfer) 
++++<BR><BR><B>B7aaaaaaaa000000h (200h) - Get Data</B><BR>KEY2 encrypted 
command. The desired ROM address is specifed, MSB first, in parameter bytes (a). 
Can be used only for addresses 8000h and up, smaller addresses will be silently 
redirected to address "8000h+(addr AND 1FFh)". There is no alignment restriction 
for the address. However, the datastream wraps to the begin of the current 4K 
block when address+length crosses a 4K boundary (1000h bytes). Returned data is 
KEY2 encrypted.<BR><BR><B>B800000000000000h (4) - 3rd Get ROM Chip ID</B><BR>
KEY2 encrypted command. Returns KEY2 encrypted Chip ID repeated every 4
 bytes.<BR><BR><B>xxxxxxxxxxxxxxxxh - Invalid Command</B><BR>Any other command 
(anything else than above B7h and B8h) in KEY2 command mode causes communcation 
failures. The invalid command returns an endless KEY2 encrypted stream of 00h 
bytes. After the invalid command, the KEY2 stream is NOT advanced for further 
command bytes, further commands seems to return KEY2 encrypted 00h bytes, of 
which, the first returned byte appears to be HIGH-Z.<BR>Ie. the cartridge seems 
to have switched back to a state similar to the KEY1-phase, although it doesn't 
seem to be possible to send KEY1 commands.<BR><BR>++++ Notes ++++<BR><BR><B>KEY1 
Command Encryption / 910h Dummy Bytes</B><BR>All KEY1 encrypted commands are 
followed by 910h dummy byte transfers, these 910h clock cycles are probably used 
to decrypt the command at the cartridge side; communication will fail when 
transferring less than 910h bytes.<BR>The return values for the dummy transfer 
are: A single HIGH-Z byte, followed by 90Fh KEY2-encrypted 00h bytes. The KEY2 
encryption stream is advanced for all 910h bytes, including for the HIGH-Z 
byte.<BR>Note: Current cartridges are using 910h bytes, however, other carts 
might use other amounts of dummy bytes, the 910h value can be calculated based 
on ROM Control entries in cartridge header. For the KEY1 formulas, see:<BR><A 
href="#dsencryptionbygamecodeidcodekey1">DS 
Encryption by Gamecode/Idcode (KEY1)</A><BR><BR><B>KEY2 Command/Data 
Encryption</B><BR><A href="#dsencryptionbyrandomseedkey2">DS 
Encryption by Random Seed (KEY2)</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dscartridgeioports"></A><FONT size="+2">&nbsp;DS Cartridge 
      I/O Ports</FONT></TD></TR></TBODY></TABLE><BR>The Gamecard bus registers can be 
mapped to NDS7 or NDS9 via EXMEMCNT, see<BR><A href="#dsmemorycontrol">DS 
Memory Control</A><BR><BR><B>40001A1h - Gamecard Bus Whatever</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-5   Always zero
  6     Transfer Ready IRQ (0=Disable, 1=Enable) (see Port 40001A4h/Bit31)
  7     Always set (1=Enable?)
</PRE></TD></TR></TBODY></TABLE>Maybe 
used to reset the cartridge? Maybe this (or another register) controls gamecard 
BACKUP memory?<BR><BR><B>40001A4h - Gamecard Bus ROMCTRL</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit   Expl.
  0-12  KEY1 length part1 (0-1FFFh) (forced min 08F8h by BIOS)
  13    Unknown?
  14    Unknown?
  15    Unknown? (read-only, or write-only?)
  16-21 KEY1 length part2 (0-3Fh)   (forced min 18h by BIOS)
  22    Unknown?
  23    Data-Word Status  (0=Busy, 1=Ready/DRQ) (Read-only)
  24-26 Data Block size   (0=None, 1..6=100h SHL (1..6) bytes, 7=4 bytes)
  27    Transfer CLK rate (0=6.7MHz=33.51MHz/5, 1=4.2MHz=33.51MHz/8)
  28    Secure Area Mode  (0=normal, 1=other)
  29    Unknown (always 1 ?)
  30    Unknown (always 0 ?)
  31    Block Start/Status (0=Ready, 1=Start/Busy) (IRQ See Port 40001A1h)
</PRE></TD></TR></TBODY></TABLE>The 
cartridge header is booted at 4.2MHz CLK rate, and following transfers are then 
using ROMCTRL settings specified in cartridge header entries [060h] and [064h], 
which are usually using 6.7MHz CLK rate. When using other CLK rate, the Timeout 
in header [06Eh] must be probably adjusted accordingly.<BR>Transfer length of 
null, four, and 200h..4000h bytes are supported by the console, however, regular 
cartridges support only max 1000h bytes.<BR><BR><B>40001A8h - Gamecard bus 
8-byte Command Out</B><BR>The separate commands are described in the Cartridge 
Protocol chapter, however, once when the BIOS boot procedure has completed, one 
would usually only need command "B7aaaaaaaa000000h", for reading data (usually 
200h bytes) from address aaaaaaaah.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-7   1st Command Byte       (MSB, at 40001A8h)
  ...   2nd..7th Command Bytes (at 40001A9..1AEh)
  56-63 8th Command Byte       (LSB, at 40001AFh)
</PRE></TD></TR></TBODY></TABLE>Observe 
that the command/parameter MSB is located at the smallest memory location 
(40001A8h), ie. compared with the CPU, the byte-order is 
reversed.<BR><BR><B>4100010h - Gamecard bus 4-byte Data In</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0-7   1st received Data Byte (at 4100010h)
  8-15  2nd received Data Byte (at 4100011h)
  16-23 3rd received Data Byte (at 4100012h)
  24-31 4th received Data Byte (at 4100013h)
</PRE></TD></TR></TBODY></TABLE>After 
sending a command, data can be read from this register manually (when the DRQ 
bit is set), or by DMA (with DMASAD=4100010h, Fixed Source Address, Length=1, 
Size=32bit, Repeat=On, Mode=DS Gamecard).<BR><BR><B>40001B0h - 32bit - 
Encryption Seed 0 Lower 32bit</B><BR><B>40001B4h - 32bit - Encryption Seed 1 
Lower 32bit</B><BR><B>40001B8h - 16bit - Encryption Seed 0 Upper 7bit (bit8-15 
unused)</B><BR><B>40001BAh - 16bit - Encryption Seed 1 Upper 7bit (bit8-15 
unused)</B><BR>These registers are used by the NDS7 BIOS to initialize KEY2 
encryption,<BR>after that, the registers should not (cannot?) be changed.<BR><A 
href="#dsencryptionbyrandomseedkey2">DS 
Encryption by Random Seed (KEY2)</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dscartridgenitroromfilesystem"></A><FONT size="+2">&nbsp;DS 
      Cartridge NitroROM File 
System</FONT></TD></TR></TBODY></TABLE><BR><B>NitroROM</B><BR>The NitroROM 
Filesystem is used by many commercial games, at least those that have been 
developed with Nintendo's tools. The filesystem allows to load data from 
cartridge ROM by filenames and/or by Overlay IDs.<BR>However, the DS hardware, 
BIOS, and Firmware do NOT contain any built-in filesystem functions. The 
ARM9/ARM7 boot code (together max 3903KB), and Icon/Title information are 
automatically loaded on power-up.<BR>Programs that require to load additional 
data from cartridge ROM may do that either by implementing whatever functions to 
translate filenames to ROM addresses, or by reading from ROM 
directly.<BR><BR><B>File Allocation Table (FAT) (base/size defined in cart 
header)</B><BR>Contains ROM addresses for up to 61440 files (File IDs 0000h and 
up).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Addr Size Expl.
  00h  4    Start address of file in ROM (8000h and up)    (0=Unused Entry)
  04h  4    End address of file in ROM   (Start+Len...-1?) (0=Unused Entry)
</PRE></TD></TR></TBODY></TABLE>Directories 
are fully defined in FNT area, and do not require FAT entries.<BR><BR><B>File 
Name Table (FNT) (base/size defined in cart header)</B><BR>Consists of the FNT 
Directory Table, followed by one or more FNT Sub-Tables.<BR>To interprete the 
directory tree: Start at the 1st Main-Table entry, which is referencing to a 
Sub-Table, any directories in the Sub-Table are referencing to Main-Table 
entries, which are referencing to further Sub-Tables, and so on.<BR><BR><B>FNT 
Directory Main-Table (base=FNT+0, size=[FNT+06h]*8)</B><BR>Consists of a list of 
up to 4096 directories (Directory IDs F000h and up).<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Addr Size Expl.
  00h  4    Offset to Sub-table             (originated at FNT base)
  04h  2    ID of first file in Sub-table   (0000h..EFFFh)
</PRE></TD></TR></TBODY></TABLE>For 
first entry (ID F000h, root directory):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  06h  2    Total Number of directories     (1..4096)
</PRE></TD></TR></TBODY></TABLE>Further 
entries (ID F001h..FFFFh, sub-directories):<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  06h  2    ID of parent directory (F000h..FFFEh)
</PRE></TD></TR></TBODY></TABLE><BR><B>FNT 
Sub-tables (base=FNT+offset, ends at Type/Length=00h)</B><BR>Contains ASCII 
names for all files and sub-directories within a directory.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Addr Size Expl.
  00h  1    Type/Length
              01h..7Fh File Entry          (Length=1..127, without ID field)
              81h..FFh Sub-Directory Entry (Length=1..127, plus ID field)
              00h      End of Sub-Table
              80h      Reserved
  01h  LEN  File or Sub-Directory Name, case-sensitive, without any ending
              zero, ASCII 20h..7Eh, except for characters \/?"&lt;&gt;*:;|
</PRE></TD></TR></TBODY></TABLE>Below 
for Sub-Directory Entries only:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  LEN+1 2    Sub-Directory ID (F001h..FFFFh) ;see FNT+(ID AND FFFh)*8
</PRE></TD></TR></TBODY></TABLE>File 
Entries do not have above ID field. Instead, File IDs are assigned in
 incrementing order (starting at the "First ID" value specified in the Directory 
Table).<BR><BR><B>ARM9 and ARM7 Overlay Tables (OVT) (base/size defined in cart 
header)</B><BR>Somehow related to Nintendo's compiler, allows to assign compiler 
Overlay IDs to filesystem File IDs, and to define additional information such 
like load addresses.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Addr Size Expl.
  00h  4    Overlay ID
  04h  4    RAM Address ;Point at which to load
  08h  4    RAM Size    ;Amount to load
  0Ch  4    BSS Size    ;Size of BSS data region
  10h  4    Static initialiser start address
  14h  4    Static initialiser end address
  18h  4    File ID  (0000h..EFFFh)
  1Ch  4    Reserved (zero)
</PRE></TD></TR></TBODY></TABLE><BR><B>Cartridge 
Header</B><BR>The base/size of FAT, FNT, OVT areas is defined in cartridge 
header,<BR><A href="#dscartridgeheader">DS 
Cartridge Header</A><BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dscartridgepassmepassthrough"></A><FONT size="+2">&nbsp;DS 
      Cartridge PassMe/PassThrough</FONT></TD></TR></TBODY></TABLE><BR>PassMe is an 
adapter connected between the DS and an original NDS cartridge, used to boot 
unencrypted code from a flash cartridge in the GBA slot, it replaces the 
following entries in the original NDS cartridge header:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Addr  Siz Patch
  004h  4   E59FF018h  ;opcode LDR PC,[027FFE24h] at 27FFE04h
  01Fh  1   04h        ;set autostart bit
  022h  1   01h        ;set ARM9 rom offset to nn01nnnnh (above secure area)
  024h  4   027FFE04h  ;patch ARM9 entry address to endless loop
  034h  4   080000C0h  ;patch ARM7 entry address in GBA slot
  15Eh  2   nnnnh      ;adjust header crc16
</PRE></TD></TR></TBODY></TABLE>After 
having verified the encrypted chip IDs (from the original cartridge), the 
console thinks that it has successfully loaded a NDS cartridge, and then jumps 
to the (patched) entrypoints.<BR><BR><B>GBA Flashcard Format</B><BR>Although the 
original PassMe requires only the entrypoint, PassMe programs should 
additionally contain one (or both) of the ID values below, allowing firmware 
patches to identify &amp; start PassMe games without real PassMe hardware.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  0A0h  GBA-style Title    ("DSBooter")
  0ACh  GBA-style Gamecode ("PASS")
  0C0h  ARM7 Entrypoint    (32bit ARM code)
</PRE></TD></TR></TBODY></TABLE>Of 
course, that applies only to early homebrew programs, newer games should use 
normal NDS cartridge headers.<BR><BR><B>ARM9 Entrypoint</B><BR>The GBA-slot 
access rights in the EXMEMCNT register are initially assigned to the ARM7 CPU, 
so the ARM9 cannot boot from the flashcard, instead it is switched into an 
endless loop in Main RAM (which contains a copy of the cartridge header at 
27FFE00h and up). The ARM7 must thus copy ARM9 code to Main RAM, and the set the 
ARM9 entry address by writing to [027FFE24h].<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsencryptionbygamecodeidcodekey1"></A><FONT 
      size="+2">&nbsp;DS Encryption by Gamecode/Idcode 
  (KEY1)</FONT></TD></TR></TBODY></TABLE><BR><B>KEY1 - Gamecode / Idcode 
Encryption</B><BR>The KEY1 encryption relies only on the gamecode (or firmware 
idcode), it does not contain any random components. The fact that KEY1 encrypted 
commands appear random is just because the &lt;unencrypted&gt; commands contain 
random values, so the encryption result looks random.<BR><BR>KEY1 encryption is 
used for KEY1 encrypted gamecart commands (ie. for loading the secure area). It 
is also used for resolving the extra decryption of the first 2K of the secure 
area, and for firmware decryption, and to decode some encrypted values in 
gamecart/firmware header.<BR><BR>Below are KEY1 encryption formulas. The 
formulas can be used only with a copy of the key table (1048h bytes) from the 
NDS ARM7 BIOS (address 0030h..1077h).<BR><BR><B>crypt_64bit_up(ptr) / 
crypt_64bit_down(ptr)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Y=[ptr+0]
  X=[ptr+4]
  FOR I=0 TO 0Fh (up), or FOR I=11h TO 02h (down)
    Z=[keybuf+I*4] XOR X
    X=[keybuf+048h+((Z SHR 24) AND FFh)*4]
    X=[keybuf+448h+((Z SHR 16) AND FFh)*4] + X
    X=[keybuf+848h+((Z SHR  8) AND FFh)*4] XOR X
    X=[keybuf+C48h+((Z SHR  0) AND FFh)*4] + X
    X=Y XOR X
    Y=Z
  NEXT I
  [ptr+0]=X XOR [keybuf+40h], or [ptr+0]=X XOR [keybuf+4h] (down)
  [ptr+4]=Y XOR [keybuf+44h], or [ptr+4]=Y XOR [keybuf+0h] (down)
</PRE></TD></TR></TBODY></TABLE><BR><B>apply_keycode(modulo)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  crypt_64bit_up(keycode+4)
  crypt_64bit_up(keycode+0)
  [scratch]=0000000000000000h   ;S=0 (64bit)
  FOR I=0 TO 44h STEP 4         ;xor with reversed byte-order (bswap)
    [keybuf+I]=[keybuf+I] XOR bswap_32bit([keycode+(I MOD modulo)])
  NEXT I
  FOR I=0 TO 1040h STEP 8
    crypt_64bit_up(scratch)     ;encrypt S (64bit) by keybuf
    [keybuf+I]=[scratch]        ;write S (64bit) to keybuf
  NEXT I
</PRE></TD></TR></TBODY></TABLE><BR><B>init_keycode(idcode,level,modulo)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  copy [arm7bios+0030h..1077h] to [keybuf+0..1047h]
  [keycode+0]=[idcode]
  [keycode+4]=[idcode]/2
  [keycode+8]=[idcode]*2
  IF level&gt;=1 THEN apply_keycode(modulo) ;first apply (always)
  IF level&gt;=2 THEN apply_keycode(modulo) ;second apply (optional)
  [keycode+4]=[keycode+4]*2
  [keycode+8]=[keycode+8]/2
  IF level&gt;=3 THEN apply_keycode(modulo) ;third apply (optional)
</PRE></TD></TR></TBODY></TABLE><BR><B>firmware_decryption</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  init_keycode(firmware_header+08h,1,0Ch) ;idcode (usually "MACP"), level 1
  crypt_64bit_down(firmware_header+18h)   ;rominfo
  init_keycode(firmware_header+08h,2,0Ch) ;idcode (usually "MACP"), level 2
  decrypt ARM9 and ARM7 bootcode by crypt_64bit_down (each 8 bytes)
  decompress ARM9 and ARM7 bootcode by LZ77 function (swi)
  calc CRC16 on decrypted/decompressed ARM9 bootcode followed by ARM7 bootcode
</PRE></TD></TR></TBODY></TABLE>Note: 
The sizes of the compressed/encrypted bootcode areas are unknown (until they are 
fully decompressed), one way to solve that problem is to decrypt the next 8 
bytes each time when the decompression function requires more 
data.<BR><BR><B>gamecart_decryption</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  init_keycode(cart_header+0Ch,1,08h)   ;gamecode, level 1, modulo 8
  crypt_64bit_down(cart_header+78h)     ;rominfo (secure area disable)
  init_keycode(cart_header+0Ch,2,08h)   ;gamecode, level 2, modulo 8
  crypt_64bit_up all KEY1 commands (1st command byte in MSB of 64bit value)
  after loading the secure_area, calculate secure_area crc, then
  crypt_64bit_down(secure_area+0)       ;first 8 bytes of secure area
  init_keycode(cart_header+0Ch,3,08h)   ;gamecode, level 3, modulo 8
  crypt_64bit_down(secure_area+0..7F8h) ;each 8 bytes in first 2K of secure
</PRE></TD></TR></TBODY></TABLE>After 
decryption, the ID field in the first 8 bytes should be "encryObj", if it 
matches then first 8 bytes are filled with E7FFDEFFh, otherwise the whole 2K are 
filled by that value.<BR><BR><B>Gamecart Command Register</B><BR>Observe that 
the byte-order of the command register is reversed.<BR>The CPU's STR [addr] 
opcode writes the MSB to [addr+0], and LSB to [addr+3], and, when using the 
"crypt_64bit_up" function for KEY1-encrypted commands, the MSB of the 64bit 
command should be at [addr+7], the LSB at [addr+0].<BR>Respectively, the value 
in &lt;memory&gt; should be transferred MSB first, however, the DS transfers the 
&lt;register&gt; value LSB first. Thus, the byte order must be reversed when 
copying the value from memory to the command register.<BR><BR><B>Note</B><BR>The 
KEY1 encryption is based on Bruce Schneier's "Blowfish Encryption
 Algorithm".<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsencryptionbyrandomseedkey2"></A><FONT size="+2">&nbsp;DS 
      Encryption by Random Seed (KEY2)</FONT></TD></TR></TBODY></TABLE><BR><B>KEY2 
39bit Seed Values</B><BR>The pre-initialization settings at cartridge-side 
(after reset) are:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Seed0 = 58C56DE0E8h
  Seed1 = 5C879B9B05h
</PRE></TD></TR></TBODY></TABLE>The 
post-initialization settings (after sending command 4llllmmmnnnkkkkkh to the 
cartridge, and after writing the Seed values to Port 40001Bxh) are:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Seed0 = (mmmnnn SHL 15)+6000h+Seedbyte
  Seed1 = 5C879B9B05h
</PRE></TD></TR></TBODY></TABLE>The 
seedbyte is selected by Cartridge Header [013h].Bit0-2, this index value should 
be usually in range 0..5, however, possible values for index 0..7 are:
 E8h,4Dh,5Ah,B1h,17h,8Fh,99h,D5h.<BR>The 24bit random value (mmmnnn) is derived 
from the real time clock setting, and also scattered by KEY1 encryption, 
anyways, it's just random and doesn't really matter where it comes 
from.<BR><BR><B>KEY2 Encryption</B><BR>Relies on two 39bit registers (x and y), 
which are initialized as such:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  x = reversed_bit_order(seed0)  ;ie. LSB(bit0) exchanged with MSB(bit38), etc.
  y = reversed_bit_order(seed1)
</PRE></TD></TR></TBODY></TABLE>During 
transfer, x, y, and transferred data are modified as such:<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  x = (((x shr 5)xor(x shr 17)xor(x shr 18)xor(x shr 31)) and 0FFh)+(x shl 8)
  y = (((y shr 5)xor(y shr 23)xor(y shr 18)xor(y shr 31)) and 0FFh)+(y shl 8)
  data = (data xor x xor y) and 0FFh
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsfirmwareserialflashmemory"></A><FONT size="+2">&nbsp;DS 
      Firmware Serial Flash Memory</FONT></TD></TR></TBODY></TABLE><BR><B>ST 
Microelectronics SPI Bus Compatible Serial Flash Memory</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  ST M45PE20 - ID 20h, 40h, 12h - 256 KBytes (used in original DS)
  ST M25PE40 - ID 20h, 80h, 13h - 512 KBytes (used in some/all newer DS)
</PRE></TD></TR></TBODY></TABLE>More 
than 100,000 Write Cycles, more than 20 Year Data Retention<BR>The Firmware 
Flash Memory is accessed via SPI bus,<BR><A href="#dsserialperipheralinterfacebusspi">DS 
Serial Peripheral Interface Bus (SPI)</A><BR><BR><B>Instruction Codes</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  06h  WREN Write Enable (No Parameters)
  04h  WRDI Write Disable (No Parameters)
  9Fh  RDID Read JEDEC Identification (Read 1..3 ID Bytes)
             (Manufacturer, Device Type, Capacity)
  05h  RDSR Read Status Register (Read Status Register, endless repeated)
             Bit7-2  Not used (zero)
             Bit1    WEL Write Enable Latch             (0=No, 1=Enable)
             Bit0    WIP Write/Program/Erase in Progess (0=No, 1=Busy)
  03h  READ Read Data Bytes (Write 3-Byte-Address, read endless data stream)
  0Bh  FAST Read Data Bytes at Higher Speed (Write 3-Byte-Address, write 1
             dummy-byte, read endless data stream) (max 25Mbit/s)
  0Ah  PW   Page Write (Write 3-Byte-Address, write 1..256 data bytes)
             (changing bits to 0 or 1) (reads unchanged data, erases the page,
             then writes new &amp; unchanged data) (11ms typ, 25ms max)
  02h  PP   Page Program (Write 3-Byte-Address, write 1..256 data bytes)
             (changing bits from 1 to 0) (1.2ms typ, 5ms max)
  DBh  PE   Page Erase 100h bytes (Write 3-Byte-Address) (10ms typ, 20ms max)
  D8h  SE   Sector Erase 10000h bytes (Write 3-Byte-Address) (1s typ, 5s max)
  B9h  DP   Deep Power-down (No Parameters) (consumption 1uA typ, 10uA max)
             (3us) (ignores all further instructions, except RDP)
  ABh  RDP  Release from Deep Power-down (No Parameters) (30us)
</PRE></TD></TR></TBODY></TABLE>Write/Program 
may not cross page-boundaries. Write/Program/Erase are rejected during first 
1..10ms after power up. The WEL bit is automatically cleared on Power-Up, on 
/Reset, and on completion of WRDI/PW/PP/PE/SE instructions. WEL is set by WREN 
instruction (which must be issued before any write/program/erase instructions). 
Don't know how RDSR behaves when trying to write to the write-protected 
region?<BR><BR><B>Communication Protocol</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Set Chip Select LOW to invoke the command
  Transmit the instruction byte
  Transmit any parameter bytes
  Transmit/receive any data bytes
  Set Chip Select HIGH to finish the command
</PRE></TD></TR></TBODY></TABLE>All 
bytes (and 3-byte addresses) transferred most significant bit/byte 
first.<BR><BR><B>Pin-Outs</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  1   D    Serial Data In (latched at rising clock edge)          _________
  2   C    Serial Clock (max 25MHz)                             /|o        |
  3   /RES Reset                                            1 -| |         |- 8
  4   /S   Chip Select (instructions start at falling edge) 2 -| |         |- 7
  5   /W   Write Protect (makes first 256 pages read-only)  3 -| |_________|- 6
  6   VCC  Supply (2.7V..3.6V typ) (4V max)                 4 -|/          |- 5
  7   VSS  Ground                                              |___________|
  8   Q    Serial Data Out (changes at falling clock edge)
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsfirmwareheader"></A><FONT size="+2">&nbsp;DS Firmware 
      Header</FONT></TD></TR></TBODY></TABLE><BR><B>Firmware Memory Map</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  00000h-001FFh  Firmware Header
  00200h-3FDFFh  Firmware Code/Data
  3FE00h-3FEFFh  User Settings Area 1
  3FF00h-3FFFFh  User Settings Area 2
</PRE></TD></TR></TBODY></TABLE><BR><B>Firmware 
Header (00000h-001FFh)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Addr Size Expl.
</PRE></TD></TR></TBODY></TABLE><B>Memory 
Addresses...</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  000h 2    part3 romaddr/8 (arm9 code) (LZ/huffman compression)
  002h 2    part4 romaddr/8 (arm7 code) (LZ/huffman compression)
  004h 2    part3/4 CRC16
  006h 2    part1/2 CRC16 arm9/7 boot code
  008h 4    firmware identifier (usually nintendo "MACP") (or nocash "XBOO")
  00Ch 2    part1 arm9 boot code romaddr/2^(2+shift1) (LZSS compressed)
  00Eh 2    part1 arm9 boot code 2800000h-ramaddr/2^(2+shift2)
  010h 2    part2 arm7 boot code romaddr/2^(2+shift3) (LZSS compressed)
  012h 2    part2 arm7 boot code 3810000h-ramaddr/2^(2+shift4)
  014h 2    bit0-2=shift1, bit3-5=shift2, bit6-8=shift3, bit9-11=shift4
  016h 2    part5 data/gfx romaddr/8 (LZ/huffman compression)
  018h 8    Unknown (xx xx xx 1x 04 FF FF FF)
            (or encrypted "enPngOFF"=Cartridge KEY2 Disable)
  020h 2    User Settings Offset (div8) (usually 3FE00h/8)
  022h 2     C0 7E   Whatever (maybe div8) (7EC0h*8 = 3F600h ?)
             (maybe size of used memory, excluding header..)
  024h 2     40 7E       (=3F200h)
  026h 2    part5 data/gfx CRC16
</PRE></TD></TR></TBODY></TABLE><B>WLAN Calibration 
Data...</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  028h 2    Unknown/unused (FFh-filled)
  02Ah 2    CRC16 (with initial value 0) of [2Ch..2Ch+config_length-1]
  02Ch 2    config_length (usually 0138h)
  02Eh 8    Unknown/unused (00h-filled)
  036h 6    00 09 BF xx xx xx         48bit MAC address (WLAN)
  03Ch 2    list of enabled channels ANDed with 7FFE,
             each bit represents one channel
  03Eh 2    ?
  040h 1    ?
  041h 1    ?
  042h 1    ?
  043h 1    ?
  044h 20h  list of 16 2-byte MAC reg values for a list of 16 hardcoded MAC
            reg addresses (see list below) related to RX &amp; TX
  064h 69h  list of 1-byte BBP reg values for BBP regs 0..x
  0CDh 1    Unknown
  0CEh ?    list of 1-byte RF values
  0D4h 6    Same as 1st entry at 00F2h
  0DAh 18h  Unknown
  0F2h 54h  list of 14 2x3-byte RF values for each channel (15 channels?),
            related to channel frequency, RF_Write( first 3-byte value),
            RF_Write( next 3-byte value)
  146h E    list of 14 1-byte BBP reg values, seem to go into BBP reg 1Eh
  154h E    list of 14 1-byte RF values, also channel frequency related,
            only lower 5 bits are used
  162h 1    Unknown
  163h 9Dh  Unused (FFh-filled)
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsfirmwareusersettings"></A><FONT size="+2">&nbsp;DS Firmware 
      User Settings</FONT></TD></TR></TBODY></TABLE><BR><B>Current Settings (RAM 
27FFC80h-27FFCFFh)</B><BR><B>User Settings 0 (Firmware 
3FE00h-3FEFFh)</B><BR><B>User Settings 1 (Firmware 3FF00h-3FFFFh)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Addr Size Expl.
  000h  2   Version (5)
  002h  1   Favorite color (0..15) (0=Gray, 1=Brown, etc.)
  003h  1   Birthday month (1..12) (Binary, non-BCD)
  004h  1   Birthday day   (1..31) (Binary, non-BCD)
  005h  1
  006h  20  Nickname string in UTF-16 format
  01Ah  2   Nickname length in characters    (0..10)
  01Ch  52  Message string in UTF-16 format
  050h  2   Message length in characters     (0..26)
  052h  1   Alarm hour     (0..23) (Binary, non-BCD)
  053h  1   Alarm minute   (0..59) (Binary, non-BCD)
  054h
  056h  1   80h=enable alarm (huh?), bit 0..6=enable?
  057h      Zero (1 byte)
  058h  2x2 touch-screen calibration point (adc.x1,y1) 12bit ADC-position
  05Ch  2x1 touch-screen calibration point (scr.x1,y1) 8bit pixel-position
  05Eh  2x2 touch-screen calibration point (adc.x2,y2) 12bit ADC-position
  062h  2x1 touch-screen calibration point (scr.x2,y2) 8bit pixel-position
  064h  2   Language and Flags (see below)
  066h  2   Unknown
  068h  4   RTC Offset (difference in seconds when RTC time/date was changed)
  06Ch  4   FFh-filled
  070h  1/2 update counter (used to check latest)
  072h  2   CRC16 of entries 00h..6Fh
  074h  ..  FFh-filled
</PRE></TD></TR></TBODY></TABLE><BR><B>Language 
and Flags (Entry 64h)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Bit
  0..2 Language (0=Japanese, 1=English, 2=French, 3=German,
       4=Italian, 5=Spanish) (this also implies time/data format)
  3    GBA mode screen selection. 0=upper, 1=lower
  6    Bootmenu Disable   (0=Manual/bootmenu, 1=Autostart game)
  9    User Settings Lost (0=Normal, 1=Prompt/Settings Lost)
  13
  14
 The Health and Safety message is skipped if Bit9=1, or if
 one or more of the following bits is zero: Bits 10,11,13,14,15.
 However, as soon as entering the bootmenu, the Prompt occurs.
</PRE></TD></TR></TBODY></TABLE>Bit9: 
 Prompt for User Info, and Language, and Calibration<BR>Bit10: Prompt for User 
Info<BR>Bit11: Same as Bit10<BR>Bit12: No function<BR>Bit13: Prompt for User 
Info, and Language<BR>Bit14: Same as Bit10<BR>Bit15: Same as Bit10<BR><BR><BR>
Note: There are two User Settings areas in the firmware chip, at offset 3FE00h 
and 3FF00h, if both areas have valid CRCs, then the current/newest area is that 
whose Update Counter is one bigger than in the other/older area.<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE> IF count1=((count0+1) AND 7Fh) THEN area1=newer ELSE area0=newer
</PRE></TD></TR></TBODY></TABLE>When 
changing settings, the older area is overwritten with new data (and incremented 
Update Counter). The two areas allow to recover previous settings in case of a 
write-error (eg. on a battery failure during write).<BR><BR><B>Battery 
Removal</B><BR>Even though the battery is required only for the RTC (not for the 
firmware flash memory), most of the firmware user settings are reset when 
removing the battery. This appears to be a strange bug-or-feature of the DS 
bios, at least, fortunately, it still keeps the rest of the firmware 
intact.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsfirmwareextendedsettings"></A><FONT size="+2">&nbsp;DS 
      Firmware Extended Settings</FONT></TD></TR></TBODY></TABLE><BR>Extended Settings 
contain some additional information which is not supported by the original 
firmware (current century, date/time formats, temperature calibration, etc.), 
the settings are supported by Nocash Firmware, by the no$gba emulator, and may 
be eventually also supported by other emulators. If present, the values can be 
used by games, otherwise games should use either whatever default settings, or 
contain their own configuration menu.<BR><BR><B>Extended Settings - loaded to 
23FEE00h (aka fragments of NDS9 boot code)</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Addr Siz Expl.
  00h  8  ID "XbooInfo"
  08h  2  CRC16 Value [0Ch..0Ch+Length-1]
  0Ah  2  CRC16 Length (from 0Ch and up)
  0Ch  1  Version (currently 01h)
  0Dh  1  Update Count (newer = (older+1) AND FFh)
  0Eh  1  Bootmenu Flags
            Bit6   Important Info  (0=Disable, 1=Enable)
            Bit7   Bootmenu Screen (0=Upper, 1=Lower)
  0Fh  1  GBA Border (0=Black, 1=Gray Line)
  10h  2  Temperature Calibration TP0 ADC value  (x16) (sum of 16 ADC values)
  12h  2  Temperature Calibration TP1 ADC value  (x16) (sum of 16 ADC values)
  14h  2  Temperature Calibration Degrees Kelvin (x100) (0=none)
  16h  1  Temperature Flags
            Bit0-1 Format (0=Celsius, 1=Fahrenheit, 2=Reaumur, 3=Kelvin)
  17h  1  Backlight Intensity (0=0ff .. FFh=Full)
  18h  4  Date Century Offset       (currently 20, for years 2000..2099)
  1Ch  1  Date Month Recovery Value (1..12)
  1Dh  1  Date Day Recovery Value   (1..31)
  1Eh  1  Date Year Recovery Value  (0..99)
  1Fh  1  Date/Time Flags
            Bit0-1 Date Format   (0=YYYY-MM-DD, 1=MM-DD-YYYY, 2=DD-MM-YYYY)
            Bit2   Friendly Date (0=Raw Numeric, 1=With Day/Month Names)
            Bit5   Time DST      (0=Hide DST, 1=Show DST=On/Off)
            Bit6   Time Seconds  (0=Hide Seconds, 1=Show Seconds)
            Bit7   Time Format   (0=24 hour, 1=12 hour)
  20h  1  Date Separator      (Ascii, usually Slash, or Dot)
  21h  1  Time Separator      (Ascii, usually Colon, or Dot)
  22h  1  Decimal Separator   (Ascii, usually Comma, or Dot)
  23h  1  Thousands Separator (Ascii, usually Comma, or Dot)
  24h  1  Daylight Saving Time (Nth)
             Bit 0-3 Activate on (0..4 = Last,1st,2nd,3rd,4th)
             Bit 4-7 Deactivate on (0..4 = Last,1st,2nd,3rd,4th)
  25h  1  Daylight Saving Time (Day)
             Bit 0-3 Activate on (0..7 = Mon,Tue,Wed,Thu,Fri,Sat,Sun,AnyDay)
             Bit 4-7 Deactivate on (0..7 = Mon,Tue,Wed,Thu,Fri,Sat,Sun,AnyDay)
  26h  1  Daylight Saving Time (of Month)
             Bit 0-3 Activate DST in Month   (1..12)
             Bit 4-7 Deactivate DST in Month (1..12)
  27h  1  Daylight Saving Time (Flags)
             Bit 0   Current DST State (0=Off, 1=On)
             Bit 1   Adjust DST Enable (0=Disable, 1=Enable)
</PRE></TD></TR></TBODY></TABLE>Note: 
With the original firmware, the memory region at 23FEE00h and up contains 
un-initialized, non-zero-filled data (fragments of boot code).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsbackwardscompatiblegbamode"></A><FONT size="+2">&nbsp;DS 
      Backwards-compatible GBA-Mode</FONT></TD></TR></TBODY></TABLE><BR>When booting a 
32pin GBA cartridge, the NDS is automatically switched into GBA mode, in that 
mode all NDS related features are disabled, and the console behaves (almost) 
like a GBA.<BR><BR><B>GBA Features that are NOT supported on NDS in GBA 
Mode.</B><BR>Unlike real GBA, the NDS does not support 8bit DMG/CGB 
cartridges.<BR>The undocumented Internal Memory Control register (Port 800h) 
isn't supported, so the NDS doesn't allow to use 'overclocked' RAM.<BR>The NDS 
doesn't have a link-port, so GBA games can be played only in single player mode, 
link-port accessories cannot be used, and the NDS cannot run GBA code via 
multiboot.<BR><BR><B>GBA Features that are slightly different on NDS in GBA 
Mode.</B><BR>The CPU, Timers, and Sound Frequencies are probably clocked at 
16.76MHz; 33.51Mhz/2; a bit slower than the original GBA's 16.78MHz clock?<BR>In 
the BIOS, a single byte in a formerly 00h-filled area has been changed from 00h 
to 01h, resulting in SWI 0Dh returning a different BIOS checksum.<BR>The GBA 
picture can be shown on upper or lower screen (selectable in boot-menu), the 
backlight for the selected screen is always on, resulting in different colors 
&amp; much better visibility than original GBA. Unlike GBA-SP, the NDS doesn't 
have a backlight-button.<BR><BR><B>Screen Border in GBA mode</B><BR>The GBA 
screen is centered in the middle of the NDS screen. The surrounding pixels are 
defined by 32K-color bitmap data in VRAM Block A and B. Each frame, the GBA 
picture is captured into one block, and is displayed in the next frame (while 
capturing new data to the other block).<BR>To get a flicker-free border, both 
blocks should be initialized to contain the same image before entering GBA mode 
(usually both are zero-filled, resulting in a plain black border).<BR>Note: When 
using two different borders, the flickering will be irregular - so there appears 
to be a frame inserted or skipped once every some seconds in GBA 
mode?!<BR><BR><B>Switching from NDS Mode to GBA Mode</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  --- NDS9: ---
  ZEROFILL VRAM A,B     ;init black screen border (or other color/image)
  POWCNT=8003h          ;enable 2D engine A on upper screen (0003h=lower)
  EXMEMCNT=...          ;set Async Main Memory mode (clear bit14)
  IME=0                 ;disable interrupts
  SWI 06h               ;halt with interrupts disabled (lockdown)
  --- NDS7: ---
  POWERMAN.REG0=09h     ;enable sound amplifier &amp; upper backlight (05h=lower)
  IME=0                 ;disable interrupts
  wait for VCOUNT=200   ;wait until VBlank
  SWI 1Fh with R2=40h   ;enter GBA mode, by CustomHalt(40h)
</PRE></TD></TR></TBODY></TABLE>After 
that, the GBA BIOS will be booted, the GBA Intro will be displayed, and the GBA 
cartridge (if any) will be started.<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="dsxboo"></A><FONT size="+2">&nbsp;DS 
Xboo</FONT></TD></TR></TBODY></TABLE><BR><B>DS XBOO Connection</B><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  Console Pin/Names             Parallel Port Pin/Names
  RFU.9    FMW.1 D    ---|&gt;|--- DSUB.14    CNTR.14    AutoLF
  RFU.6    FMW.2 C    ---|&gt;|--- DSUB.1     CNTR.1     Strobe
  RFU.10   FMW.3 /RES ---|&gt;|--- DSUB.16    CNTR.31    Init
  RFU.7    FMW.4 /S   ---|&gt;|--- DSUB.17    CNTR.36    Select
  RFU.5    FMW.5 /W   --. SL1A  -          -          N.C.
  RFU.28   FMW.6 VCC  __| SL1B  -          -          N.C.
  RFU.2,12 FMW.7 VSS  --------- DSUB.18-25 CNTR.19-30 Ground
  RFU.8    FMW.8 Q    --------- DSUB.11    CNTR.11    Busy
  P00 Joypad-A        --------- DSUB.2     CNTR.2     D0
  P01 Joypad-B        --------- DSUB.3     CNTR.3     D1
  P02 Joypad-Select   --------- DSUB.4     CNTR.4     D2
  P03 Joypad-Start    --------- DSUB.5     CNTR.5     D3
  P04 Joypad-Right    --------- DSUB.6     CNTR.6     D4
  P05 Joypad-Left     --------- DSUB.7     CNTR.7     D5
  P06 Joypad-Up       --------- DSUB.8     CNTR.8     D6
  P07 Joypad-Down     --------- DSUB.9     CNTR.9     D7
  RTC.1 INT aka SI    --------- DSUB.10    CNTR.10    /Ack
</PRE></TD></TR></TBODY></TABLE>Parts 
List: 15 wires, 4 "BAT 85" diodes, 1 parallel port socket.<BR><BR><B>DS XBOO 
Connection Notes</B><BR>The Firmware chip (FMW.Pins) hides underneath of the RFU 
shielding plate, so it'd be easier to connect the wires to the RFU.Pins. The 
easiest way for the /W-to-VCC connection is to shortcut SL1 by putting some 
solder onto it.<BR>The P00..P07 and INT signals are labeled on the switch-side 
of the mainboard, however, there should be more room for the cables when 
connecting them to via's at the bottom-side, image below may help to locate that 
pins,<BR>
<TABLE>
  <TBODY>
  <TR>
    <TD>
<PRE>  <A title="Linkification: http://nocash.emubase.de/nds-pins.gif" class="linkification-ext" href="http://nocash.emubase.de/nds-pins.gif">http://nocash.emubase.de/nds-pins.gif</A> (3.5 KBytes)
</PRE></TD></TR></TBODY></TABLE>At 
the parallel port side, DSUB.Pins or CNTR.Pins can be used for 25pin DSUB or 
36pin Centronics sockets, the latter one allowing to use a standard printer 
cable.<BR>The ring printed on the diodes is pointing towards parallel port side, 
the diodes are required to prevent the parallel port to pull-up LOW levels on 
the NDS side, be sure to use BAT85 diodes, cheaper ones like 1N4148 are loosing
 too much voltage and won't work stable.<BR><BR><B>DS XBOO Operation 
Notes</B><BR>The main Upload function is found in no$gba Utility menu, together 
with further functions in Remote Access sub-menu.<BR>Before uploading anything: 
download the original firmware, the file is saved as FIRMnnnn.BIN, whereas 
"nnnn" is equal to the last 16bit of the consoles 48bit MAC address, so 
Firmware-images from different consoles are having unique filenames. If you 
don't already have, also download the NDS BIOS, the BIOS contains encryption 
seed data required to encrypt/decrypt secure area; without having downloaded the 
BIOS, no$gba will be working only with unencrypted ROM-images. Next, select 
Patch Firmware to install the nocash firmware.<BR><BR><B>DS XBOO 
Troubleshooting</B><BR>Be sure that the console is switched on, and that the 
XBOO cable is connected, and that you have selected the correct parallel port in 
no$gba setup (the "multiboot" options in Various Options screen), and, of 
course, try avoid to be fiddling with the joypad during uploads.<BR>I've tested 
the cable on two computers, the overall upload/download stuff should work 
stable. The firmware access functions - which are required only for 
(un-)installation - worked only with one of the two computers; try using a 
different computer/parallel port in case of problems.<BR><BR><B>Nocash 
Firmware</B><BR>The primary purpose is to receive uploaded NDS-images via 
parallel port connection, additionally it's containing bootmenu and setup 
screens similar to the original firmware. The user interface is having less 
cryptic symbols and should be alltogether faster and easier to use. Important 
Information about Whatever is supported (but it can be disabled). The setup 
contains a couple of additional options like automatic daylight saving time 
adjustment.<BR>The bootmenu allows to boot normal NDS and GBA carts, it does 
additionally allow to boot NDS-images (or older PassMe-images) from flashcards 
in GBA slot. Furthermore, benefits of asm coding, the nocash firmware occupies 
less than 32KBytes, allowing to store (and boot) smaller NDS-images in the 
unused portion of the firmware memory (about 224KBytes), the zero-filled region
 between cart header and secure area, at 200h..3FFFh, is automatically excluded, 
so the image may be slightly bigger than the available free memory
 space.<BR><BR><B>Missing</B><BR>Unlike the original firmware, the current 
version cannot boot via WLAN. Help or hardware would be welcome (I am having 
only one NDS, and my PC doesn't have WLAN, so I cannot test any WLAN transfers 
right now).<BR><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR bgcolor="#cccccc">
    <TD><A name="aboutthisdocument"></A><FONT size="+2">&nbsp;About this 
      Document</FONT></TD></TR></TBODY></TABLE><BR><B>About</B><BR>GBATEK written 
2001-2006 by Martin Korth, programming specs for the GBA and NDS hardware, I've 
been trying to keep the specs both as short as possible, and as complete as 
possible. The document is part of the no$gba debuggers built-in help 
text.<BR><BR><B>Updates</B><BR>The standalone docs in TXT and HTM format are 
updated when having added any major changes to the document. The no$gba built-in 
version will be updated more regularly, including for minor changes, along with 
all no$gba updates.<BR><BR><B>Homepage</B><BR><A title="Linkification: http://nocash.emubase.de/gba.htm" 
class="linkification-ext" 
href="http://nocash.emubase.de/gba.htm">http://nocash.emubase.de/gba.htm</A> - 
no$gba homepage<BR><A title="Linkification: http://nocash.emubase.de/gbatek.htm" 
class="linkification-ext" 
href="http://nocash.emubase.de/gbatek.htm">http://nocash.emubase.de/gbatek.htm</A> 
- gbatek html version<BR><A title="Linkification: http://nocash.emubase.de/gbatek.txt" 
class="linkification-ext" 
href="http://nocash.emubase.de/gbatek.txt">http://nocash.emubase.de/gbatek.txt</A> 
- gbatek text version<BR><BR><B>Feedback</B><BR>If you find any information in 
this document to be misleading, incomplete, or incorrect, please say something! 
My email address will be eventually found on the no$gba webpage - depending on 
the amount of incoming garbage; mail from programmers only, 
please.<BR><BR><B>Credits</B><BR>Thanks for GBATEK fixes, and for info about GBA 
and NDS hardware,<BR>- Christian Auby<BR>- Damien Good<BR>- DarkFader<BR>- 
Dstek.xml, funny name, strange non-txt/htm format :-(<BR>- Jeff Frohwein<BR>- 
NDSTech Wiki, <A title="Linkification: http://www.bottledlight.com/ds/" class="linkification-ext" 
href="http://www.bottledlight.com/ds/">http://www.bottledlight.com/ds/</A><BR>- 
Randy Linden<BR>- Sebastian Rasmussen<BR><BR><BR></BODY></HTML>
